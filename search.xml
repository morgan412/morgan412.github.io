<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis主从复制的配置和实现原理]]></title>
    <url>%2Fblog%2Fredis-replication%2F</url>
    <content type="text"><![CDATA[Redis的持久化功能在一定程度上保证了数据的安全性，即便是服务器宕机的情况下，也可以保证数据的丢失非常少。通常，为了避免服务的单点故障，会把数据复制到多个副本放在不同的服务器上，且这些拥有数据副本的服务器可以用于处理客户端的读请求，扩展整体的性能 下面会介绍Redis的主从复制配置和实现原理，后续还会有Redis的高可用方案：哨兵机制（Sentinel）、分区集群（Cluster） 什么是主从复制我们可以通过slaveof &lt;host&gt; &lt;port&gt;命令，或者通过配置slaveof选项，来使当前的服务器（slave）复制指定服务器（master）的内容，被复制的服务器称为主服务器（master），对主服务器进行复制操作的为从服务器（slave） 主服务器master可以进行读写操作，当主服务器的数据发生变化，master会发出命令流来保持对salve的更新，而从服务器slave通常是只读的（可以通过slave-read-only指定），在主从复制模式下，即便master宕机了，slave是不能变为主服务器进行写操作的 一个master可以有多个slave，即一主多从；而slave也可以接受其他slave的连接，形成“主从链”层叠状结构（cascading-like structure），自 Redis 4.0 起，所有的sub-slave也会从master收到完全一样的复制流。如下图 主从复制的好处： 数据冗余，实现数据的热备份 故障恢复，避免单点故障带来的服务不可用 读写分离，负载均衡。主节点负载读写，从节点负责读，提高服务器并发量 高可用基础，是哨兵机制和集群实现的基础 主从复制的配置使用和配置主从复制是比较简单的，在从服务器slave的配置文件中设置slaveof选项，或者直接使用slaveof &lt;masterip&gt; &lt;masterport&gt;命令 这里我使用3台虚拟机来搭建一下，主服务器的ip为192.168.249.20，两个从服务器的ip分别为192.168.249.21和192.168.249.21，端口号都为6379，具体的配置如下 主服务器并不需要额外多配置什么，这里我们先把三台服务器的都需要改的地方列一下 12345678# 设置为后台运行daemonize yes# 保存pid的文件，如果是在一台机器搭建主从，需要区分一下pidfile /var/run/redis_6379.pid# 绑定的主机地址，这里注释掉，开放ip连接#bind 127.0.0.1# 指定日志文件logfile "6379.log" 在从服务器中添加配置slaveof &lt;masterport&gt; &lt;masterport&gt;选项，在5.0版本中使用了replicaof代替了slaveof（https://github.com/antirez/redis/issues/5335），slaveof还可以继续使用，不过建议使用replicaof。如果是使用命令行来复制的话，重启之后会无效 12# replicaof &lt;masterip&gt; &lt;masterport&gt;replicaof 192.168.249.20 6379 配置好redis.conf之后，我们分别启动3台服务器，可以用户命令info replication查看复制信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556192.168.249.20:6379&gt; info replication# Replicationrole:masterconnected_slaves:2slave0:ip=192.168.249.22,port=6379,state=online,offset=700,lag=0slave1:ip=192.168.249.21,port=6379,state=online,offset=700,lag=0master_replid:b80a4720c0001efb62940f5ad6abaf9cdaf7a813master_replid2:0000000000000000000000000000000000000000master_repl_offset:700second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:700192.168.249.21:6379&gt; info replication# Replicationrole:slavemaster_host:192.168.249.20master_port:6379master_link_status:upmaster_last_io_seconds_ago:3master_sync_in_progress:0slave_repl_offset:854slave_priority:100slave_read_only:1connected_slaves:0master_replid:b80a4720c0001efb62940f5ad6abaf9cdaf7a813master_replid2:0000000000000000000000000000000000000000master_repl_offset:854second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:57repl_backlog_histlen:798192.168.249.22:6379&gt; info replication# Replicationrole:slavemaster_host:192.168.249.20master_port:6379master_link_status:upmaster_last_io_seconds_ago:6master_sync_in_progress:0slave_repl_offset:854slave_priority:100slave_read_only:1connected_slaves:0master_replid:b80a4720c0001efb62940f5ad6abaf9cdaf7a813master_replid2:0000000000000000000000000000000000000000master_repl_offset:854second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:854 接下来我们可以在主服务器中写入数据，然后可以在其他的从服务器中读取数据 12345678192.168.249.20:6379&gt; set test 'Hello World'OK192.168.249.21:6379&gt; get test"Hello World"192.168.249.22:6379&gt; get test"Hello World" 然后我们试着在从服务器中写入数据，会提示不能在只读的从服务器中写入数据 12192.168.249.21:6379&gt; set test2 hello(error) READONLY You can't write against a read only replica. 如果我们需要slave对master的复制进行验证，可以在master中配置requirepass &lt;password&gt;选项设置密码 那么需要在从服务器中使用该密码，可以使用命令config set masterauth &lt;password&gt;，或者在配置文件中设置masterauth &lt;password&gt; 主从复制的实现原理主从复制的配置还是比较简单的，下面来了解下主从复制的实现原理 Redis的主从复制过程大体上分3个阶段：建立连接、数据同步、命令传播 建立连接这个阶段主要是从服务器发出slaveof命令之后，与主服务器如何建立连接，为数据同步做准备的过程。 1）在slaveof命令执行之后，从服务器根据设置的master的ip地址和端口，创建连向主服务器的socket套接字连接，连接成功后，从服务器会为这个套接字关联一个专门的处理器，用于处理后续的复制工作 2）建立连接之后，从服务器会向主服务器发送ping命令，确认主服务器是否可用，以及当前是否可用接受处理命令。如果收到主服务器的pong回复说明是可用的，否则有可能是网络超时或主服务器阻塞，从服务器会断开连接发起重连 3）身份验证。如果主服务器设置了requirepass选项，那么从服务器必须配置masterauth选项，且保证密码一致才能通过验证 4）身份验证完成之后，从服务器会发送自己的监听端口，主服务器会保存下来 12345192.168.249.20:6379&gt; info replication...slave0:ip=192.168.249.22,port=6379,state=online,offset=700,lag=0slave1:ip=192.168.249.21,port=6379,state=online,offset=700,lag=0... 数据同步在主从服务器建立连接确认各自身份之后，就开始数据同步，从服务器向主服务器发送PSYNC命令，执行同步操作，并把自己的数据库状态更新至主服务器的数据库状态 Redis的主从同步分为：完整重同步（full resynchronization）和部分重同步（partial resynchronization） 完整重同步有两种情况下是完整重同步，一是slave连接上master第一次复制的时候；二是如果当主从断线，重新连接复制的时候有可能是完整重同步，这个在后面说 下面是完整重同步的步骤 从服务器连接主服务器，发送SYNC命令 主服务器接收到SYNC命名后，开始执行bgsave命令生成RDB文件并使用缓冲区记录此后执行的所有写命令 主服务器basave执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令 部分重同步部分重同步是用于处理断线后重复制的情况，先介绍几个用于部分重同步的部分 runid(replication ID)，主服务器运行id，Redis实例在启动时，随机生成一个长度40的唯一字符串来标识当前节点 offset，复制偏移量。主服务器和从服务器各自维护一个复制偏移量，记录传输的字节数。当主节点向从节点发送N个字节数据时，主节点的offset增加N，从节点收到主节点传来的N个字节数据时，从节点的offset增加N replication backlog buffer，复制积压缓冲区。是一个固定长度的FIFO队列，大小由配置参数repl-backlog-size指定，默认大小1MB。需要注意的是该缓冲区由master维护并且有且只有一个，所有slave共享此缓冲区，其作用在于备份最近主库发送给从库的数据 当slave连接到master，会执行PSYNC &lt;runid&gt; &lt;offset&gt;发送记录旧的master的runid（replication ID）和偏移量offset，这样master能够只发送slave所缺的增量部分。但是如果master的复制积压缓存区没有足够的命令记录，或者slave传的runid(replication ID)不对，就会进行完整重同步，即slave会获得一个完整的数据集副本 PSYNC命令执行完整重同步和部分重同步的流程图 命令传播当完成数据同步之后，主从服务器的数据暂时达到一致状态，当主服务器执行了客户端的写命令之后，主从的数据便不再一致。为了能够使主从服务器的数据保持一致性，主服务器会对从服务器执行命令传播操作，即每执行一个写命令就会向从服务器发送同样的写命令 在命令传播阶段，从服务器会默认以每秒一次的频率向主服务器发送心跳检测 1REPLCONF ACK &lt;replication_offset&gt; 其中replication_offset是当前从服务器的复制偏移量，该命令的作用有三个 检测主从服务器的网络连接状态 辅助实现min-slaves选项 检测命令丢失 关闭持久化时，复制的安全性关于关闭持久化时，复制的安全性问题，我这里摘入官网的一段描述http://www.redis.cn/topics/replication.html 在使用Redis复制功能时的设置中，强烈建议在master和在slave中启用持久化。当不可能启用时，例如由于非常慢的磁盘性能而导致的延迟问题，应该配置实例来避免重置后自动重启。 为了更好地理解为什么关闭了持久化并配置了自动重启的 master 是危险的，检查以下故障模式，这些故障模式中数据会从 master 和所有 slave 中被删除： 我们设置节点 A 为 master 并关闭它的持久化设置，节点 B 和 C 从 节点 A 复制数据。 节点 A 崩溃，但是他有一些自动重启的系统可以重启进程。但是由于持久化被关闭了，节点重启后其数据集合为空。 节点 B 和 节点 C 会从节点 A 复制数据，但是节点 A 的数据集是空的，因此复制的结果是它们会销毁自身之前的数据副本。 当 Redis Sentinel 被用于高可用并且 master 关闭持久化，这时如果允许自动重启进程也是很危险的。例如， master 可以重启的足够快以致于 Sentinel 没有探测到故障，因此上述的故障模式也会发生。 任何时候数据安全性都是很重要的，所以如果 master 使用复制功能的同时未配置持久化，那么自动重启进程这项应该被禁用 参考：《Redis设计与实现》、redis replication]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis持久化机制：RDB和AOF]]></title>
    <url>%2Fblog%2Fredis-data-persistence%2F</url>
    <content type="text"><![CDATA[Redis数据持久化Redis作为一个内存数据库，数据是以内存为载体存储的，那么一旦Redis服务器进程退出，服务器中的数据也会消失。为了解决这个问题，Redis提供了持久化机制，也就是把内存中的数据保存到磁盘当中，避免数据意外丢失 Redis提供了两种持久化方案：RDB持久化和AOF持久化，一个是快照的方式，一个是类似日志追加的方式 RDB快照持久化RDB持久化是通过快照的方式，即在指定的时间间隔内将内存中的数据集快照写入磁盘。在创建快照之后，用户可以备份该快照，可以将快照复制到其他服务器以创建相同数据的服务器副本，或者在重启服务器后恢复数据。RDB是Redis默认的持久化方式 快照持久化RDB持久化会生成RDB文件，该文件是一个压缩过的二进制文件，可以通过该文件还原快照时的数据库状态，即生成该RDB文件时的服务器数据。RDB文件默认为当前工作目录下的dump.rdb，可以根据配置文件中的dbfilename和dir设置RDB的文件名和文件位置 1234567# 设置 dump 的文件名dbfilename dump.rdb# 工作目录# 例如上面的 dbfilename 只指定了文件名，# 但是它会写入到这个目录下。这个配置项一定是个目录，而不能是文件名。dir ./ 触发快照的时机 执行save和bgsave命令 配置文件设置save &lt;seconds&gt; &lt;changes&gt;规则，自动间隔性执行bgsave命令 主从复制时，从库全量复制同步主库数据，主库会执行bgsave 执行flushall命令清空服务器数据 执行shutdown命令关闭Redis时，会执行save命令 save和bgsave命令执行save和bgsave命令，可以手动触发快照，生成RDB文件，两者的区别如下 使用save命令会阻塞Redis服务器进程，服务器进程在RDB文件创建完成之前是不能处理任何的命令请求 12127.0.0.1:6379&gt; saveOK 而使用bgsave命令不同的是，basave命令会fork一个子进程，然后该子进程会负责创建RDB文件，而服务器进程会继续处理命令请求 12127.0.0.1:6379&gt; bgsaveBackground saving started fork()是由操作系统提供的函数，作用是创建当前进程的一个副本作为子进程 fork一个子进程，子进程会把数据集先写入临时文件，写入成功之后，再替换之前的RDB文件，用二进制压缩存储，这样可以保证RDB文件始终存储的是完整的持久化内容 自动间隔触发在配置文件中设置save &lt;seconds&gt; &lt;changes&gt;规则，可以自动间隔性执行bgsave命令 12345678910111213141516171819202122232425################################ SNAPSHOTTING ################################## Save the DB on disk:## save &lt;seconds&gt; &lt;changes&gt;## Will save the DB if both the given number of seconds and the given# number of write operations against the DB occurred.## In the example below the behaviour will be to save:# after 900 sec (15 min) if at least 1 key changed# after 300 sec (5 min) if at least 10 keys changed# after 60 sec if at least 10000 keys changed## Note: you can disable saving completely by commenting out all "save" lines.## It is also possible to remove all the previously configured save# points by adding a save directive with a single empty string argument# like in the following example:## save ""save 900 1save 300 10save 60 10000 save &lt;seconds&gt; &lt;changes&gt;表示在seconds秒内，至少有changes次变化，就会自动触发gbsave命令 save 900 1 当时间到900秒时，如果至少有1个key发生变化，就会自动触发bgsave命令创建快照 save 300 10 当时间到300秒时，如果至少有10个key发生变化，就会自动触发bgsave命令创建快照 save 60 10000 当时间到60秒时，如果至少有10000个key发生变化，就会自动触发bgsave命令创建快照 AOF持久化除了RDB持久化，Redis还提供了AOF（Append Only File）持久化功能，AOF持久化会把被执行的写命令写到AOF文件的末尾，记录数据的变化。默认情况下，Redis是没有开启AOF持久化的，开启后，每执行一条更改Redis数据的命令，都会把该命令追加到AOF文件中，这是会降低Redis的性能，但大部分情况下这个影响是能够接受的，另外使用较快的硬盘可以提高AOF的性能 可以通过配置redis.conf文件开启AOF持久化，关于AOF的配置如下 1234567891011121314151617181920212223242526# appendonly参数开启AOF持久化appendonly no# AOF持久化的文件名，默认是appendonly.aofappendfilename "appendonly.aof"# AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的dir ./# 同步策略# appendfsync alwaysappendfsync everysec# appendfsync no# aof重写期间是否同步no-appendfsync-on-rewrite no# 重写触发配置auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb# 加载aof出错如何处理aof-load-truncated yes# 文件重写策略aof-rewrite-incremental-fsync yes AOF的实现AOF需要记录Redis的每个写命令，步骤为：命令追加（append）、文件写入（write）和文件同步（sync） 命令追加(append)开启AOF持久化功能后，服务器每执行一个写命令，都会把该命令以协议格式先追加到aof_buf缓存区的末尾，而不是直接写入文件，避免每次有命令都直接写入硬盘，减少硬盘IO次数 文件写入(write)和文件同步(sync)对于何时把aof_buf缓冲区的内容写入保存在AOF文件中，Redis提供了多种策略 appendfsync always：将aof_buf缓冲区的所有内容写入并同步到AOF文件，每个写命令同步写入磁盘 appendfsync everysec：将aof_buf缓存区的内容写入AOF文件，每秒同步一次，该操作由一个线程专门负责 appendfsync no：将aof_buf缓存区的内容写入AOF文件，什么时候同步由操作系统来决定 appendfsync选项的默认配置为everysec，即每秒执行一次同步 关于AOF的同步策略是涉及到操作系统的write函数和fsync函数的，在《Redis设计与实现》中是这样说明的 为了提高文件写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区的空间被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。 这样的操作虽然提高了效率，但也为数据写入带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失。为此，系统提供了fsync、fdatasync同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保写入数据的安全性。 从上面的介绍我们知道，我们写入的数据，操作系统并不一定会马上同步到磁盘，所以Redis才提供了appendfsync的选项配置。当该选项时为always时，数据安全性是最高的，但是会对磁盘进行大量的写入，Redis处理命令的速度会受到磁盘性能的限制；appendfsync everysec选项则兼顾了数据安全和写入性能，以每秒一次的频率同步AOF文件，即便出现系统崩溃，最多只会丢失一秒内产生的数据；如果是appendfsync no选项，Redis不会对AOF文件执行同步操作，而是有操作系统决定何时同步，不会对Redis的性能带来影响，但假如系统崩溃，可能会丢失不定数量的数据 AOF重写(rewrite)在了解AOF重写之前，我们先来看看AOF文件中存储的内容是啥，先执行两个写操作 1234127.0.0.1:6379&gt; set s1 helloOK127.0.0.1:6379&gt; set s2 worldOK 然后我们打开appendonly.aof文件，可以看到如下内容 1234567891011121314*3$3set$2s1$5hello*3$3set$2s2$5world 该命令格式为Redis的序列化协议（RESP）。*3代表这个命令有三个参数，$3表示该参数长度为3 看了上面的AOP文件的内容，我们应该能想象，随着时间的推移，Redis执行的写命令会越来越多，AOF文件也会越来越大，过大的AOF文件可能会对Redis服务器造成影响，如果使用AOF文件来进行数据还原所需时间也会越长 时间长了，AOF文件中通常会有一些冗余命令，比如：过期数据的命令、无效的命令（重复设置、删除）、多个命令可合并为一个命令（批处理命令）。所以AOF文件是有精简压缩的空间的 AOF重写的目的就是减小AOF文件的体积，不过值得注意的是：AOF文件重写并不需要对现有的AOF文件进行任何读取、分享和写入操作，而是通过读取服务器当前的数据库状态来实现的 文件重写可分为手动触发和自动触发，手动触发执行bgrewriteaof命令，该命令的执行跟bgsave触发快照时类似的，都是先fork一个子进程做具体的工作 12127.0.0.1:6379&gt; bgrewriteaofBackground append only file rewriting started 自动触发会根据auto-aof-rewrite-percentage和auto-aof-rewrite-min-size 64mb配置来自动执行bgrewriteaof命令 123# 表示当AOF文件的体积大于64MB，且AOF文件的体积比上一次重写后的体积大了一倍（100%）时，会执行`bgrewriteaof`命令auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb 下面看一下执行bgrewriteaof命令，重写的流程 重写会有大量的写入操作，所以服务器进程会fork一个子进程来创建一个新的AOF文件 在重写期间，服务器进程继续处理命令请求，如果有写入的命令，追加到aof_buf的同时，还会追加到aof_rewrite_bufAOF重写缓冲区 当子进程完成重写之后，会给父进程一个信号，然后父进程会把AOF重写缓冲区的内容写进新的AOF临时文件中，再对新的AOF文件改名完成替换，这样可以保证新的AOF文件与当前数据库数据的一致性 数据恢复Redis4.0开始支持RDB和AOF的混合持久化（可以通过配置项 aof-use-rdb-preamble 开启） 如果是redis进程挂掉，那么重启redis进程即可，直接基于AOF日志文件恢复数据 如果是redis进程所在机器挂掉，那么重启机器后，尝试重启redis进程，尝试直接基于AOF日志文件进行数据恢复，如果AOF文件破损，那么用redis-check-aof fix命令修复 如果没有AOF文件，会去加载RDB文件 如果redis当前最新的AOF和RDB文件出现了丢失/损坏，那么可以尝试基于该机器上当前的某个最新的RDB数据副本进行数据恢复 RDB vs AOF上面介绍了RDB持久化和AOF持久化，那么来看一下他们各自的优缺点以及该如何选择持久化方案 RDB和AOF优缺点关于RDB和AOF的优缺点，官网上面也给了比较详细的说明https://redis.io/topics/persistence RDB 优点： RDB快照是一个压缩过的非常紧凑的文件，保存着某个时间点的数据集，适合做数据的备份，灾难恢复 可以最大化Redis的性能，在保存RDB文件，服务器进程只需fork一个子进程来完成RDB文件的创建，父进程不需要做IO操作 与AOF相比，恢复大数据集的时候会更快 缺点： RDB的数据安全性是不如AOF的，保存整个数据集的过程是比繁重的，根据配置可能要几分钟才快照一次，如果服务器宕机，那么就可能丢失几分钟的数据 Redis数据集较大时，fork的子进程要完成快照会比较耗CPU、耗时 AOF 优点： 数据更完整，安全性更高，秒级数据丢失（取决fsync策略，如果是everysec，最多丢失1秒的数据） AOF文件是一个只进行追加的日志文件，且写入操作是以Redis协议的格式保存的，内容是可读的，适合误删紧急恢复 缺点： 对于相同的数据集，AOF文件的体积要大于RDB文件，数据恢复也会比较慢 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。 不过在一般情况下， 每秒 fsync 的性能依然非常高 如何选择RDB和AOF 如果是数据不那么敏感，且可以从其他地方重新生成补回的，那么可以关闭持久化 如果是数据比较重要，不想再从其他地方获取，且可以承受数分钟的数据丢失，比如缓存等，那么可以只使用RDB 如果是用做内存数据库，要使用Redis的持久化，建议是RDB和AOF都开启，RDB方式更适合做数据的备份，AOF可以保证数据的不丢失]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入了解Redis底层数据结构]]></title>
    <url>%2Fblog%2Fredis-base-data-structure%2F</url>
    <content type="text"><![CDATA[说明说到Redis的数据结构，我们大概会很快想到Redis的5种常见数据结构：字符串(String)、列表(List)、散列(Hash)、集合(Set)、有序集合(Sorted Set)，以及他们的特点和运用场景。不过它们是Redis对外暴露的数据结构，用于API的操作，而组成它们的底层基础数据结构又是什么呢 简单动态字符串（SDS） 链表 字典 跳跃表 整数集合 压缩列表 Redis的GitHub地址https://github.com/antirez/redis 简单动态字符串（SDS）Redis是用C语言写的，但是Redis并没有使用C的字符串表示（C是字符串是以\0空字符结尾的字符数组），而是自己构建了一种简单动态字符串（simple dynamic string，SDS）的抽象类型，并作为Redis的默认字符串表示 在Redis中，包含字符串值的键值对底层都是用SDS实现的 SDS的定义SDS的结构定义在sds.h文件中，SDS的定义在Redis 3.2版本之后有一些改变，由一种数据结构变成了5种数据结构，会根据SDS存储的内容长度来选择不同的结构，以达到节省内存的效果，具体的结构定义，我们看以下代码 1234567891011121314151617181920212223242526272829303132333435363738394041// 3.0struct sdshdr &#123; // 记录buf数组中已使用字节的数量，即SDS所保存字符串的长度 unsigned int len; // 记录buf数据中未使用的字节数量 unsigned int free; // 字节数组，用于保存字符串 char buf[];&#125;;// 3.2/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */struct __attribute__ ((__packed__)) sdshdr5 &#123; unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr8 &#123; uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr16 &#123; uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr32 &#123; uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr64 &#123; uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];&#125;; 3.2版本之后，会根据字符串的长度来选择对应的数据结构 1234567891011static inline char sdsReqType(size_t string_size) &#123; if (string_size &lt; 1&lt;&lt;5) // 32 return SDS_TYPE_5; if (string_size &lt; 1&lt;&lt;8) // 256 return SDS_TYPE_8; if (string_size &lt; 1&lt;&lt;16) // 65536 64k return SDS_TYPE_16; if (string_size &lt; 1ll&lt;&lt;32) // 4294967296 4G return SDS_TYPE_32; return SDS_TYPE_64;&#125; 下面以3.2版本的sdshdr8看一个示例 len：记录当前已使用的字节数（不包括&#39;\0&#39;），获取SDS长度的复杂度为O(1) alloc：记录当前字节数组总共分配的字节数量（不包括&#39;\0&#39;） flags：标记当前字节数组的属性，是sdshdr8还是sdshdr16等，flags值的定义可以看下面代码 buf：字节数组，用于保存字符串，包括结尾空白字符&#39;\0&#39; 123456// flags值定义#define SDS_TYPE_5 0#define SDS_TYPE_8 1#define SDS_TYPE_16 2#define SDS_TYPE_32 3#define SDS_TYPE_64 4 上面的字节数组的空白处表示未使用空间，是Redis优化的空间策略，给字符串的操作留有余地，保证安全提高效率 SDS与C字符串的区别C语言使用长度为N+1的字符数组来表示长度为N的字符串，字符数组的最后一个元素为空字符&#39;\0&#39;，但是这种简单的字符串表示方法并不能满足Redis对于字符串在安全性、效率以及功能方面的要求，那么使用SDS，会有哪些好处呢 参考于《Redis设计与实现》 常数复杂度获取字符串长度 C字符串不记录字符串长度，获取长度必须遍历整个字符串，复杂度为O(N)；而SDS结构中本身就有记录字符串长度的len属性，所有复杂度为O(1)。Redis将获取字符串长度所需的复杂度从O(N)降到了O(1)，确保获取字符串长度的工作不会成为Redis的性能瓶颈 杜绝缓冲区溢出，减少修改字符串时带来的内存重分配次数 C字符串不记录自身的长度，每次增长或缩短一个字符串，都要对底层的字符数组进行一次内存重分配操作。如果是拼接append操作之前没有通过内存重分配来扩展底层数据的空间大小，就会产生缓存区溢出；如果是截断trim操作之后没有通过内存重分配来释放不再使用的空间，就会产生内存泄漏 而SDS通过未使用空间解除了字符串长度和底层数据长度的关联，3.0版本是用free属性记录未使用空间，3.2版本则是alloc属性记录总的分配字节数量。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化的空间分配策略，解决了字符串拼接和截取的空间问题 二进制安全 C字符串中的字符必须符合某种编码，除了字符串的末尾，字符串里面是不能包含空字符的，否则会被认为是字符串结尾，这些限制了C字符串只能保存文本数据，而不能保存像图片这样的二进制数据 而SDS的API都会以处理二进制的方式来处理存放在buf数组里的数据，不会对里面的数据做任何的限制。SDS使用len属性的值来判断字符串是否结束，而不是空字符 兼容部分C字符串函数 虽然SDS的API是二进制安全的，但还是像C字符串一样以空字符结尾，目的是为了让保存文本数据的SDS可以重用一部分C字符串的函数 C字符串与SDS对比 C字符串 SDS 获取字符串长度复杂度为O(N) 获取字符串长度复杂度为O(1) API是不安全的，可能会造成缓冲区溢出 API是安全的，不会造成缓冲区溢出 修改字符串长度必然会需要执行内存重分配 修改字符串长度N次最多会需要执行N次内存重分配 只能保存文本数据 可以保存文本或二进制数据 可以使用所有&lt;string.h&gt;库中的函数 可以使用一部分&lt;string.h&gt;库中的函数 链表链表是一种比较常见的数据结构了，特点是易于插入和删除、内存利用率高、且可以灵活调整链表长度，但随机访问困难。许多高级编程语言都内置了链表的实现，但是C语言并没有实现链表，所以Redis实现了自己的链表数据结构 链表在Redis中应用的非常广，列表（List）的底层实现就是链表。此外，Redis的发布与订阅、慢查询、监视器等功能也用到了链表 链表节点和链表的定义链表上的节点定义如下，adlist.h/listNode 12345678typedef struct listNode &#123; // 前置节点 struct listNode *prev; // 后置节点 struct listNode *next; // 节点值 void *value;&#125; listNode; 链表的定义如下，adlist.h/list 1234567891011121314typedef struct list &#123; // 链表头节点 listNode *head; // 链表尾节点 listNode *tail; // 节点值复制函数 void *(*dup)(void *ptr); // 节点值释放函数 void (*free)(void *ptr); // 节点值对比函数 int (*match)(void *ptr, void *key); // 链表所包含的节点数量 unsigned long len;&#125; list; 每个节点listNode可以通过prev和next指针分布指向前一个节点和后一个节点组成双端链表，同时每个链表还会有一个list结构为链表提供表头指针head、表尾指针tail、以及链表长度计数器len，还有三个用于实现多态链表的类型特定函数 dup：用于复制链表节点所保存的值 free：用于释放链表节点所保存的值 match：用于对比链表节点所保存的值和另一个输入值是否相等 链表结构图 链表特性 双端链表：带有指向前置节点和后置节点的指针，获取这两个节点的复杂度为O(1) 无环：表头节点的prev和表尾节点的next都指向NULL，对链表的访问以NULL结束 链表长度计数器：带有len属性，获取链表长度的复杂度为O(1) 多态：链表节点使用 void*指针保存节点值，可以保存不同类型的值 字典字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。字典中的每一个键都是唯一的，可以通过键查找与之关联的值，并对其修改或删除 Redis的键值对存储就是用字典实现的，散列（Hash）的底层实现之一也是字典 我们直接来看一下字典是如何定义和实现的吧 字典的定义实现Redis的字典底层是使用哈希表实现的，一个哈希表里面可以有多个哈希表节点，每个哈希表节点中保存了字典中的一个键值对 哈希表结构定义，dict.h/dictht 12345678910typedef struct dictht &#123; // 哈希表数组 dictEntry **table; // 哈希表大小 unsigned long size; // 哈希表大小掩码，用于计算索引值，等于size-1 unsigned long sizemask; // 哈希表已有节点的数量 unsigned long used;&#125; dictht; 哈希表是由数组table组成，table中每个元素都是指向dict.h/dictEntry结构的指针，哈希表节点的定义如下 12345678910111213typedef struct dictEntry &#123; // 键 void *key; // 值 union &#123; void *val; uint64_t u64; int64_t s64; double d; &#125; v; // 指向下一个哈希表节点，形成链表 struct dictEntry *next;&#125; dictEntry; 其中key是我们的键；v是键值，可以是一个指针，也可以是整数或浮点数；next属性是指向下一个哈希表节点的指针，可以让多个哈希值相同的键值对形成链表，解决键冲突问题 最后就是我们的字典结构，dict.h/dict 123456789101112typedef struct dict &#123; // 和类型相关的处理函数 dictType *type; // 私有数据 void *privdata; // 哈希表 dictht ht[2]; // rehash 索引，当rehash不再进行时，值为-1 long rehashidx; /* rehashing not in progress if rehashidx == -1 */ // 迭代器数量 unsigned long iterators; /* number of iterators currently running */&#125; dict; type属性和privdata属性是针对不同类型的键值对，用于创建多类型的字典，type是指向dictType结构的指针，privdata则保存需要传给类型特定函数的可选参数，关于dictType结构和类型特定函数可以看下面代码 1234567891011121314typedef struct dictType &#123; // 计算哈希值的行数 uint64_t (*hashFunction)(const void *key); // 复制键的函数 void *(*keyDup)(void *privdata, const void *key); // 复制值的函数 void *(*valDup)(void *privdata, const void *obj); // 对比键的函数 int (*keyCompare)(void *privdata, const void *key1, const void *key2); // 销毁键的函数 void (*keyDestructor)(void *privdata, void *key); // 销毁值的函数 void (*valDestructor)(void *privdata, void *obj);&#125; dictType; dict的ht属性是两个元素的数组，包含两个dictht哈希表，一般字典只使用ht[0]哈希表，ht[1]哈希表会在对ht[0]哈希表进行rehash（重哈希）的时候使用，即当哈希表的键值对数量超过负载数量过多的时候，会将键值对迁移到ht[1]`上 rehashidx也是跟rehash相关的，rehash的操作不是瞬间完成的，rehashidx记录着rehash的进度，如果目前没有在进行rehash，它的值为-1 结合上面的几个结构，我们来看一下字典的结构图（没有在进行rehash） 在这里，哈希算法和rehash(重新散列)的操作不再详细说明，有机会以后单独介绍 当一个新的键值对要添加到字典中时，会根据键值对的键计算出哈希值和索引值，根据索引值放到对应的哈希表上，即如果索引值为0，则放到ht[0]哈希表上。当有两个或多个的键分配到了哈希表数组上的同一个索引时，就发生了键冲突的问题，哈希表使用链地址法来解决，即使用哈希表节点的next指针，将同一个索引上的多个节点连接起来。当哈希表的键值对太多或太少，就需要对哈希表进行扩展和收缩，通过rehash(重新散列)来执行 跳跃表一个普通的单链表查询一个元素的时间复杂度为O(N)，即便该单链表是有序的。使用跳跃表（SkipList）是来解决查找问题的，它是一种有序的数据结构，不属于平衡树结构，也不属于Hash结构，它通过在每个节点维持多个指向其他节点的指针，而达到快速访问节点的目的 跳跃表是有序集合（Sorted Set）的底层实现之一，如果有序集合包含的元素比较多，或者元素的成员是比较长的字符串时，Redis会使用跳跃表做有序集合的底层实现 跳跃表的定义跳跃表其实可以把它理解为多层的链表，它有如下的性质 多层的结构组成，每层是一个有序的链表 最底层（level 1）的链表包含所有的元素 跳跃表的查找次数近似于层数，时间复杂度为O(logn)，插入、删除也为 O(logn) 跳跃表是一种随机化的数据结构(通过抛硬币来决定层数) 那么如何来理解跳跃表呢，我们从最底层的包含所有元素的链表开始，给定如下的链表 然后我们每隔一个元素，把它放到上一层的链表当中，这里我把它叫做上浮（注意，科学的办法是抛硬币的方式，来决定元素是否上浮到上一层链表，我这里先简单每隔一个元素上浮到上一层链表，便于理解），操作完成之后的结构如下 查找元素的方法是这样，从上层开始查找，大数向右找到头，小数向左找到头，例如我要查找17，查询的顺序是：13 -&gt; 46 -&gt; 22 -&gt; 17；如果是查找35，则是 13 -&gt; 46 -&gt; 22 -&gt; 46 -&gt; 35；如果是54，则是 13 -&gt; 46 -&gt; 54 上面是查找元素，如果是添加元素，是通过抛硬币的方式来决定该元素会出现到多少层，也就是说它会有 1/2的概率出现第二层、1/4 的概率出现在第三层…… 跳跃表节点的删除和添加都是不可预测的，很难保证跳表的索引是始终均匀的，抛硬币的方式可以让大体上是趋于均匀的 假设我们已经有了上述例子的一个跳跃表了，现在往里面添加一个元素18，通过抛硬币的方式来决定它会出现的层数，是正面就继续，反面就停止，假如我抛了2次硬币，第一次为正面，第二次为反面 跳跃表的删除很简单，只要先找到要删除的节点，然后顺藤摸瓜删除每一层相同的节点就好了 跳跃表维持结构平衡的成本是比较低的，完全是依靠随机，相比二叉查找树，在多次插入删除后，需要Rebalance来重新调整结构平衡 跳跃表的实现Redis的跳跃表实现是由redis.h/zskiplistNode和redis.h/zskiplist（3.2版本之后redis.h改为了server.h）两个结构定义，zskiplistNode定义跳跃表的节点，zskiplist保存跳跃表节点的相关信息 1234567891011121314151617181920212223242526/* ZSETs use a specialized version of Skiplists */typedef struct zskiplistNode &#123; // 成员对象 （robj *obj;） sds ele; // 分值 double score; // 后退指针 struct zskiplistNode *backward; // 层 struct zskiplistLevel &#123; // 前进指针 struct zskiplistNode *forward; // 跨度 // 跨度实际上是用来计算元素排名(rank)的，在查找某个节点的过程中，将沿途访过的所有层的跨度累积起来，得到的结果就是目标节点在跳跃表中的排位 unsigned long span; &#125; level[];&#125; zskiplistNode;typedef struct zskiplist &#123; // 表头节点和表尾节点 struct zskiplistNode *header, *tail; // 表中节点的数量 unsigned long length; // 表中层数最大的节点的层数 int level;&#125; zskiplist; zskiplistNode结构 level数组（层）：每次创建一个新的跳表节点都会根据幂次定律计算出level数组的大小，也就是次层的高度，每一层带有两个属性-前进指针和跨度，前进指针用于访问表尾方向的其他指针；跨度用于记录当前节点与前进指针所指节点的距离（指向的为NULL，阔度为0） backward（后退指针）：指向当前节点的前一个节点 score（分值）：用来排序，如果分值相同看成员变量在字典序大小排序 obj或ele：成员对象是一个指针，指向一个字符串对象，里面保存着一个sds；在跳表中各个节点的成员对象必须唯一，分值可以相同 zskiplist结构 header、tail表头节点和表尾节点 length表中节点的数量 level表中层数最大的节点的层数 假设我们现在展示一个跳跃表，有四个节点，节点的高度分别是2、1、4、3 zskiplist的头结点不是一个有效的节点，它有ZSKIPLIST_MAXLEVEL层(32层)，每层的forward指向该层跳跃表的第一个节点，若没有则为NULL，在Redis中，上面的跳跃表结构如下 每个跳跃表节点的层数在1-32之间 一个跳跃表中，节点按照分值大小排序，多个节点的分值是可以相同的，相同时，节点按成员对象大小排序 每个节点的成员变量必须是唯一的 整数集合整数集合（intset）是Redis用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t、int64_t的整数值，并且保证集合中不会出现重复元素 整数集合是集合（Set）的底层实现之一，如果一个集合只包含整数值元素，且元素数量不多时，会使用整数集合作为底层实现 整数集合的定义实现整数集合的定义为inset.h/inset 12345678typedef struct intset &#123; // 编码方式 uint32_t encoding; // 集合包含的元素数量 uint32_t length; // 保存元素的数组 int8_t contents[];&#125; intset; contents数组：整数集合的每个元素在数组中按值的大小从小到大排序，且不包含重复项 length记录整数集合的元素数量，即contents数组长度 encoding决定contents数组的真正类型，如INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64 整数集合的升级当想要添加一个新元素到整数集合中时，并且新元素的类型比整数集合现有的所有元素的类型都要长，整数集合需要先进行升级（upgrade），才能将新元素添加到整数集合里面。每次想整数集合中添加新元素都有可能会引起升级，每次升级都需要对底层数组已有的所有元素进行类型转换 升级添加新元素： 根据新元素类型，扩展整数集合底层数组的空间大小，并为新元素分配空间 把数组现有的元素都转换成新元素的类型，并将转换后的元素放到正确的位置，且要保持数组的有序性 添加新元素到底层数组 整数集合的升级策略可以提升整数集合的灵活性，并尽可能的节约内存 另外，整数集合不支持降级，一旦升级，编码就会一直保持升级后的状态 压缩列表压缩列表（ziplist）是为了节约内存而设计的，是由一系列特殊编码的连续内存块组成的顺序性（sequential）数据结构，一个压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者一个整数值 压缩列表是列表（List）和散列（Hash）的底层实现之一，一个列表只包含少量列表项，并且每个列表项是小整数值或比较短的字符串，会使用压缩列表作为底层实现（在3.2版本之后是使用quicklist实现） 压缩列表的构成一个压缩列表可以包含多个节点（entry），每个节点可以保存一个字节数组或者一个整数值 各部分组成说明如下 zlbytes：记录整个压缩列表占用的内存字节数，在压缩列表内存重分配，或者计算zlend的位置时使用 zltail：记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过该偏移量，可以不用遍历整个压缩列表就可以确定表尾节点的地址 zllen：记录压缩列表包含的节点数量，但该属性值小于UINT16_MAX（65535）时，该值就是压缩列表的节点数量，否则需要遍历整个压缩列表才能计算出真实的节点数量 entryX：压缩列表的节点 zlend：特殊值0xFF（十进制255），用于标记压缩列表的末端 压缩列表节点的构成每个压缩列表节点可以保存一个字节数字或者一个整数值，结构如下 previous_entry_ength：记录压缩列表前一个字节的长度 encoding：节点的encoding保存的是节点的content的内容类型 content：content区域用于保存节点的内容，节点内容类型和长度由encoding决定 对象上面介绍了Redis的主要底层数据结构，包括简单动态字符串（SDS）、链表、字典、跳跃表、整数集合、压缩列表。但是Redis并没有直接使用这些数据结构来构建键值对数据库，而是基于这些数据结构创建了一个对象系统，也就是我们所熟知的可API操作的Redis那些数据类型，如字符串(String)、列表(List)、散列(Hash)、集合(Set)、有序集合(Sorted Set) 根据对象的类型可以判断一个对象是否可以执行给定的命令，也可针对不同的使用场景，对象设置有多种不同的数据结构实现，从而优化对象在不同场景下的使用效率 类型 编码 BOJECT ENCODING 命令输出 对象 REDIS_STRING REDIS_ENCODING_INT “int” 使用整数值实现的字符串对象 REDIS_STRING REDIS_ENCODING_EMBSTR “embstr” 使用embstr编码的简单动态字符串实现的字符串对象 REDIS_STRING REDIS_ENCODING_RAW “raw” 使用简单动态字符串实现的字符串对象 REDIS_LIST REDIS_ENCODING_ZIPLIST “ziplist” 使用压缩列表实现的列表对象 REDIS_LIST REDIS_ENCODING_LINKEDLIST ‘“linkedlist’ 使用双端链表实现的列表对象 REDIS_HASH REDIS_ENCODING_ZIPLIST “ziplist” 使用压缩列表实现的哈希对象 REDIS_HASH REDIS_ENCODING_HT “hashtable” 使用字典实现的哈希对象 REDIS_SET REDIS_ENCODING_INTSET “intset” 使用整数集合实现的集合对象 REDIS_SET REDIS_ENCODING_HT “hashtable” 使用字典实现的集合对象 REDIS_ZSET REDIS_ENCODING_ZIPLIST “ziplist” 使用压缩列表实现的有序集合对象 REDIS_ZSET REDIS_ENCODING_SKIPLIST “skiplist” 使用跳跃表表实现的有序集合对象 参考：《Redis设计与实现》]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰模式-为类动态添加职责]]></title>
    <url>%2Fblog%2Fdesign-pattern-decorator%2F</url>
    <content type="text"><![CDATA[装饰模式定义 装饰模式（Decorator Pattern）- 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式相比生成子类更为灵活 装饰模式也可以叫做包装器（Wrapper），可以给一个类或对象增加行为 通常有两种方式来给类或对象来增加行为： 继承机制：通过继承一个现有的类可以使得子类在拥有自己方法的同时还可以拥有父类的方法，但是这种方式是静态的，用户不能控制增加行为的方式和时机 关联机制：将一个对象嵌到另一个对象中，并由另一个对象来决定是否调用嵌入对象的行为来扩展自己的行为，这个嵌入对象就是装饰器（Decorator） 模式结构角色职责 抽象构件（Component）：一个接口或抽象类，定义原始的对象 具体被装饰对象（ConcreteComponent）：具体的构件实现，被装饰的对象，可以给这个对象添加一些职责 抽象装饰类（Decorator）：持有一个指向Component实例的引用，并定义一个与Component接口一致的接口 具体装饰者（ConcreteDecorator）：具体的装饰对象，负责给构件对象添加职责 类图结构 代码实现大家在看视频的时候，视频网站都会在播放之前给你来一段小广告… 然后告诉你充钱可以变强，可以不用看广告，有一些视频像综艺节目或电影在播放完后还会有彩蛋 抽象构件，定义一个播放视频的接口 1234567public interface Video &#123; /** * 播放 */ void play();&#125; 具体的构件，被修饰的对象，写一个播放电影的类 1234567891011/** * Film 具体构件，被装饰的对象 * @author zouxq */public class Movie implements Video&#123; @Override public void play() &#123; System.out.println("看电影"); &#125;&#125; 抽象装饰类 12345678910111213141516171819/** * 抽象装饰类 * @author zouxq */public abstract class BaseVideoDecorator implements Video &#123; private Video video; // 通过构造函数传递被修饰者 public BaseVideoDecorator(Video video) &#123; this.video = video; &#125; // 委托给修饰者执行 @Override public void play() &#123; video.play(); &#125;&#125; 具体的装饰类，用来给具体的构件添加职责，这里给播放视频的对象添加播放广告的职责 1234567891011121314151617181920212223/** * 具体的修饰类 * @author zouxq */public class AdvertisingVideoDecorator extends BaseVideoDecorator &#123; // 定义被修饰者 public AdvertisingVideoDecorator(Video video) &#123; super(video); &#125; @Override public void play() &#123; addAdvertising(); super.play(); &#125; // 定义修饰的方法 private void addAdvertising()&#123; System.out.println("来看个广告，充钱可以不用看哦"); &#125;&#125; 下面的装饰类用来添加播放彩蛋的职责 1234567891011121314151617181920212223/** * 具体的修饰类 * @author zouxq */public class EasterEggsVideoDecorator extends BaseVideoDecorator &#123; // 定义被修饰者 public EasterEggsVideoDecorator(Video video) &#123; super(video); &#125; @Override public void play() &#123; super.play(); addEggs(); &#125; // 定义修饰的方法 private void addEggs()&#123; System.out.println("加个彩蛋..."); &#125;&#125; 测试使用 1234567891011@Testpublic void decoratorTest() &#123; Video movie = new Movie(); movie.play(); System.out.println("第一次装饰......"); movie = new AdvertisingVideoDecorator(movie); movie.play(); System.out.println("第二次装饰......"); movie = new EasterEggsVideoDecorator(movie); movie.play();&#125; 测试结果 12345678看电影第一次装饰......来看个广告，充钱可以不用看哦看电影第二次装饰......来看个广告，充钱可以不用看哦看电影加个彩蛋... 在上面的例子，我们是把四个角色都写出来了，但是实际运用的时候根据实际情况还可以更加的灵活。比如，如果能确定被装饰类就一个对象，可以只有一个ConcreteComponent类而不需要抽象的Component类，而Decorator类可以是ConcreteComponent的一个子类；同样我们只需为添加一个职责，就可以不要建立一个单独的Decoratorl类，直接写一个ConcreteDecorator就可以了 装饰模式的优缺点和使用场景 优缺点 装饰类和被装饰类可以相互独立，不会相互耦合。装饰类Decorator是从外部来扩展被装饰类Component的，不需要知道Component的内部实现 装饰模式是继承的一种替代方案，修饰返回的对象还是Component，是is-a的关系 装饰模式可以动态的扩展一个类的功能 可以把原始类中的装饰功能放到装饰类中，把类的核心职责和装饰功能区分开 装饰模式的一大缺点就是：多层的装饰会比较复杂，装饰的顺序也是很重要的，尽量要减少装饰类的数量，避免太过复杂 使用场景 需要扩展一个类的功能 动态的给对象增加功能，并且可以动态的撤销（继承是静态扩展） 为什么选择装饰模式而不是继承从上面的例子和总结，我们可以看出使用装饰模式的好处，那么装饰模式和继承同样是可以扩展类的功能，为什么会更偏向使用装饰模式 我们用一个例子来说明一下，我们去饮品店去买一杯饮料，比如买一杯奶茶MilkyTea，这时服务员问你想要加什么，可以加红豆、椰奶、珍珠… 至于加料之后的奶茶我们很容易想到使用继承去实现，比如红豆OrmosiaMilkyTea、椰奶CoconutMilkyTea、珍珠PearlMilkyTea，假如要加多种料呢？红豆椰奶OrmosiaCoconutMilkyTea …… 到这里就会发现，使用继承会要写许多的类，这里才3种加料，假如是可以加十几二十种配料呢，那自由组合的可能性就太多了，使用继承就会使我们的子类爆炸。使用继承我们要添加的功能是静态的，添加的功能便是在子类中实现，在编译时就已经确定下来；而使用装饰模式则是动态的添加功能，我需要什么功能便使用对应的装饰类去装饰，装饰的种类和顺序都是在客户端动态的加载，更加的灵活]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>装饰模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式-通过适配器来复用]]></title>
    <url>%2Fblog%2Fdesign-pattern-adapter%2F</url>
    <content type="text"><![CDATA[适配器模式是一种结构型设计模式，适配器模式主要是来解决接口不兼容的问题，使得原本没有关系的类可以协同工作。就好像我们笔记本电脑的电源适配器，在电压110v-220v之间都是可以正常工作的（那么大一坨），这适配器的工作就是把外部不稳定的电压转化成笔记本电脑能稳定使用的直流电压 适配器模式定义 适配器模式（Adapter Pattern）- 将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作 使用适配器模式其实就是把一个接口或者类转换成其他的接口和类，使其可以和其他模块一起工作，也可以被称为包装模式（Wrapper），同样有包装的功能还有装饰模式。适配器模式主要应用于想要复用现有的类，但是接口又与复用环境不一致的情况下 经常换手机的人可能会知道，手机的充电接口有几种，安卓的接口现在大多是Type-C了，一些低端机可能还在用Micro USB接口，而苹果则是用Lightining接口，假如我现在买了个新手机是Type-C接口，那我以前的那个Micro USB数据线还能不能继续用呢，是可以用的，只不过需要加上一个转接头，这个转接头便是一个适配器 适配器模式结构适配器模式角色 目标类（Target）：定义客户所需接口，可以是一个抽象类或接口，也可以是具体类 适配者（Adaptee）：或者叫源对象，需要被适配的角色，它是已经存在的类或对象，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码 适配器（Adapter）：它的职责就是要把适配者转换成目标角色，对Adaptee和Target进行适配，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系 适配器有两种分类：对象适配器、类(或接口)适配器。在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系 对象适配器 类适配器 优点和使用场景 优点 可以让两个没有关系的类在一起运行，引入一个适配器，可以不用修改原有代码 增加类的透明度，客户端只调用Target，不关心具体实现 提高类的复用度，原适配者类的功能还可以正常使用 灵活性和扩展性非常好，符合“开闭原则” 使用场景 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码 修改已投产的接口，可以考虑适配器模式 注意，适配器模式通常是用来解决系统扩展的问题，在系统开发过程中或已经项目维护中，当需要引入第三方的功能或要扩展的内容不符合原有设计的时候，才会考虑通过适配器模式来减少代码修改带来的风险。另外，项目一定要遵守依赖倒置原则和里氏替换原则，这样在使用适配器模式时，才不会有太多改动 总的来说，适配器模式属于补偿模式，专门用来在系统后期扩展、修改时使用，但要注意不要过度使用适配器模式 实例前些天刚入手一台新手机，满心欢喜啊，拿到手就忍不住开始“摩擦“，掂量一圈发现现在的手机是越来越好看、越来越薄了呀，一开心就想着拿出我的耳机想要沉浸在音乐的世界里，可下一秒蒙圈了，泥马没有耳机孔。原来啊，为了把手机做的更薄、更美，手机厂家牺牲了传统的3.mm耳机插孔，而使用复用充电接口Type-C，这下难道我又要去再搞一条Type-C接口的耳机吗？答案是可以不用，可以买一个接口转换器 Target目标类 - 要求使用Type-C接口 123public interface TypeC &#123; void useTypeCPort();&#125; Adaptee适配者 - 被适配的对象 1234567891011public interface Headset &#123; void listen();&#125;public class CommonHeadset implements Headset &#123; @Override public void listen() &#123; System.out.println("使用3.5mm耳机享受音乐..."); &#125;&#125; Adapter适配器 - 把适配对象和目标类关联起来，达到转换的目的 1234567891011121314public class CommonHeadsetAdapter implements TypeC &#123; private CommonHeadset headset; public CommonHeadsetAdapter(CommonHeadset headset)&#123; this.headset = headset; &#125; @Override public void useTypeCPort() &#123; System.out.println("使用Type-C转接头"); this.headset.listen(); &#125;&#125; 测试 123456@Testpublic void adapterTest()&#123; CommonHeadset headset = new CommonHeadset(); CommonHeadsetAdapter headsetAdapter = new CommonHeadsetAdapter(headset); headsetAdapter.useTypeCPort();&#125; 测试结果 12使用Type-C转接头使用3.5mm耳机享受音乐... 上面的是对象适配器，下面的是类适配器的做法 12345678public class CommonHeadsetAdapter2 extends CommonHeadset implements TypeC &#123; @Override public void useTypeCPort() &#123; System.out.println("使用Type-C转接头"); super.listen(); &#125;&#125; 适配器模式应用在我看来适配器模式主要是用在系统的扩展，或接入第三方接口。我们都不想破坏原有的设计和结构，为了适应新的需求，在它们之间增加一个适配层，这个适配器角色为我们转换数据或做连接。这样新的接口就能流畅调用旧的接口，达到复用的目的，符合开闭原则 要想理解适配器模式的应用或自己使用适配器，只要理清角色分工就很容易了。需要扩展一个怎样的新需求 (目标角色)，但不改变原有的设计结构 (被适配角色)，这个被适配角色可以是现有的接口、对象、类或第三方API，然后使用一个中间角色 (适配器)做数据转换或功能调用，使其满足新需求 JDBC - 驱动程序 - 数据库引擎API Java程序是通过JDBC来跟数据库连接的，JDBC给出了一套抽象的接口，即目标接口。而各种数据库就是我们要适配的对象的，在JDBC接口和数据库引擎API之间需要一个适配器，而这个适配器就是驱动程序。（比如MySql的连接程序就是一个适配器，它把数据库的API操作适配成JDBC的Java操作） Java I/O 库使用了适配器模式 如ByteArrayInputStream是一个适配器类，它继承了InputStream的接口，并且封装了一个 byte 数组。它将一个 byte 数组的接口适配成InputStream流处理器的接口； FileOutputStream 继承了 OutputStream 类型，同时持有一个对 FileDiscriptor 对象的引用。这是一个将 FileDiscriptor 接口适配成 OutputStream 接口形式的对象适配器模式； Reader类型的原始流处理器都是适配器模式的应用。StringReader是一个适配器类，StringReader类继承了Reader类型，持有一个对String对象的引用。它将String的接口适配成 Reader 类型的接口 Spring AOP中的适配器模式 在Spring的Aop中，使用Advice（通知）来增强被代理类的功能。 Advice的类型有：MethodBeforeAdvice、AfterReturningAdvice、ThrowsAdvice，而每个类型的Advice都有对应的拦截器：MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor、ThrowsAdviceInterceptor。Spring需要将每个Advice都封装成对应的拦截器类型，返回给容器，所以需要使用适配器模式对Advice进行转换 在这个应用中，Advice增强类其实只是普通的对象(被适配角色)，而我们的目标是通过拦截器对切入点增强功能，所以通过适配器将我们的Advice适配成拦截器达到增强切入点的目的 Adaptee适配者类 12345678910public interface MethodBeforeAdvice extends BeforeAdvice &#123; void before(Method method, Object[] args, @Nullable Object target) throws Throwable;&#125;public interface AfterReturningAdvice extends AfterAdvice &#123; void afterReturning(@Nullable Object returnValue, Method method, Object[] args, @Nullable Object target) throws Throwable;&#125;public interface ThrowsAdvice extends AfterAdvice &#123;&#125; Target目标接口 123456public interface AdvisorAdapter &#123; // 判断是否支持该增强，即是否匹配 boolean supportsAdvice(Advice advice); // 获取对应的拦截器 MethodInterceptor getInterceptor(Advisor advisor);&#125; Adapter适配器 12345678910111213141516171819202122232425262728293031323334353637383940class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable &#123; @Override public boolean supportsAdvice(Advice advice) &#123; return (advice instanceof MethodBeforeAdvice); &#125; @Override public MethodInterceptor getInterceptor(Advisor advisor) &#123; MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice(); return new MethodBeforeAdviceInterceptor(advice); &#125;&#125;class AfterReturningAdviceAdapter implements AdvisorAdapter, Serializable &#123; @Override public boolean supportsAdvice(Advice advice) &#123; return (advice instanceof AfterReturningAdvice); &#125; @Override public MethodInterceptor getInterceptor(Advisor advisor) &#123; AfterReturningAdvice advice = (AfterReturningAdvice) advisor.getAdvice(); return new AfterReturningAdviceInterceptor(advice); &#125;&#125;class ThrowsAdviceAdapter implements AdvisorAdapter, Serializable &#123; @Override public boolean supportsAdvice(Advice advice) &#123; return (advice instanceof ThrowsAdvice); &#125; @Override public MethodInterceptor getInterceptor(Advisor advisor) &#123; return new ThrowsAdviceInterceptor(advisor.getAdvice()); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式-封装不变，扩展可变]]></title>
    <url>%2Fblog%2Fdesign-pattern-template%2F</url>
    <content type="text"><![CDATA[模板方法模式是一种行为型设计模式，它比较简单，我们平时的编程中可能就经常用到了它 介绍定义 模板方法模式（Template Method Pattern）- 定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 简单来说，就是把可变的部分(方法)放在子类中实现，把不可变的部分放在父类中实现 举个例子，假如你赚钱了买了个房子，交房之后是个毛坯需要装修，装修的流程是水电、泥工、木工、再买家具电器等，这时关于装修哪种风格有了不同意见，你自己喜欢简约时尚的风格，而你爸妈喜欢中式风格，可不管是什么风格，整个装修的流程还是不变的，于是可以找装修公司制定两种风格的方案，这其中变化的是两种风格各个流程的具体材料、做工不同，不变的是装修的流程 模板方法结构通用类图 使用模板方法模式很简单，使用Java的继承机制即可，这里有两种角色 抽象模板(AbstractClass)：提供模板方法，让子类实现基本方法 基本方法： 基本方法也叫做基本操作，是由子类实现的方法，并且在模板方法被调用 模板方法： 可以有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调度，完成固定的逻辑 具体模板(ConcreteClass)：实现父类所定义的一个或多个抽象方法，也就是父类定义的基本方法在子类中得以实现 一般模板方法可以用final修饰，这样子类不能重写，避免被修改 优点以应用场景优点 封装不变部分，扩展可变部分。把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过继承来继续扩展 提取公共部分代码，便于维护 行为由父类控制，子类实现。子类可以通过扩展的方式增加相应的功能，符合开闭原则 应用场景 多个子类有公有的方法，并且逻辑基本相同时 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为 实例统计操作时间抽象模板，用于给操作统计时间，其中getTime()为模板方法，用于统计操作时间，该行为交给父类控制，code()钩子方法延迟到子类中实现 GetTimeTemplate.java12345678910111213141516171819202122public abstract class GetTimeTemplate &#123; /** * 基本方法，由子类实现 （钩子方法） */ public abstract void code(); /** * 模板方法 固定流程方法 */ public long getTime() &#123; // 获取起始时间 long t1 = System.currentTimeMillis(); // 调用基本方法 code(); // 获取结束时间 long t2 = System.currentTimeMillis(); return t2 - t1; &#125;&#125; 具体模板实现 - 统计复制文件操作时间 CopyFileDemo.java123456789101112131415161718192021222324public class CopyFileDemo extends GetTimeTemplate &#123; @Override public void code() &#123; //复制文件 try &#123; BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream("1.jpg")); BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream("2.jpg")); byte[] bs = new byte[256]; int len = 0; while ((len = inputStream.read(bs)) != -1) &#123; outputStream.write(bs, 0, len); outputStream.flush(); &#125; //释放资源 inputStream.close(); outputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 具体模板实现 - 统计循环操作时间 ForDemo.java123456789public class ForDemo extends GetTimeTemplate &#123; @Override public void code() &#123; //输出for循环 for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(i); &#125; &#125;&#125; 参考：《设计模式之禅》、《大话设计模式》]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>模板方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis介绍、安装以及数据结构(操作命令)]]></title>
    <url>%2Fblog%2Fredis-intro-install-datatype%2F</url>
    <content type="text"><![CDATA[Redis介绍什么是RedisRedis是用C语言开发的一个开源（BSD许可）的高性能键值对（key-value）内存数据库，可以用作数据库、缓存和消息中间件。它是一种NoSQL（NOT-Only Sql，泛指非关系型数据库）数据库 性能优秀，数据在内存中，读写速度非常快，支持并发10W QPS 单进程单线程，是线程安全的，采用IO多路复用 丰富数据类型：字符串（strings），散列（hashes），列表（lists），集合（sets），有序集合（sorted sets） 等 支持数据持久化，可以将内存中数据保存在磁盘中，重启时加载 主从复制 Redis应用场景 内存数据库（登录信息、购物车信息、用户浏览记录等） 缓存服务器（商品数据、广告数据等等）（最多使用） 解决分布式集群架构中的 session 分离问题（ session 共享） 任务队列（秒杀、抢购、12306等等） 分布式锁的实现 支持发布订阅的消息模式 应用排行榜(有序集合) 网站访问统计 数据过期处理（可以精确到毫秒） Redis安装启动(单机)Redis没有官方的Windows版本，建议在Linux系统上安装运行 Linux下安装启动安装Redis的官网为redis.io，在官网上可以获取最新的版本 下载解压 12$ wget http://download.redis.io/releases/redis-5.0.5.tar.gz$ tar xzf redis-5.0.5.tar.gz 进入目录、编译 12$ cd redis-5.0.5$ make 编译完成的二进制文件是在src目录下，其中redis-server为服务端程序，redis-cli为客户端程序 安装 还可以通过make install命令安装到指定目录，通过PREFIX指定安装目录 1$ make install PREFIX=/usr/local/redis 命令说明 redis-server：启动 redis 服务 redis-cli：进入 redis 命令客户端 redis-benchmark： 性能测试的工具 redis-check-aof： aof 文件进行检查的工具 redis-check-dump： rdb 文件进行检查的工具 redis-sentinel： 启动哨兵监控服务 启动启动Redis的命令为redis-server，运行安装目录下的redis-server 1$ /usr/local/redis/bin/redis-server 关闭ctrl+c，这种方式启动，我们的连接窗口关闭，Redis也会关闭，我们会希望它在后台一直运行着，就需要后端启动 后端启动（守护进程启动）‘ 1）从解压文件中redis-5.0.5复制redis.conf配置文件到安装目录下的bin目录 1$ cp /root/redis-5.0.5/redis.conf /usr/local/redis/bin/ 2）修改redis.conf配置文件 1$ vim redis.conf 123456# 将`daemonize`由`no`改为`yes`daemonize yes# 默认绑定的是回环地址，默认不能被其他机器访问# bind 127.0.0.1# 是否开启保护模式，由yes该为noprotected-mode no 3）启动redis-server服务 1./redis-server redis.conf 4）关闭服务 1./redis-cli shutdown 命令行客户端启动客户端的命令是redis-cli，它有两个参数 -h：redis服务器的ip地址（默认为127.0.0.1） -p：redis实例的端口号（默认为6379） 1./redis-cli -h 127.0.0.1 -p 6379 Windows安装虽然官方并没有Windows版本，但是Microsoft有开发和维护64位的Redis，下载地址为https://github.com/microsoftarchive/redis/releases 这里下载Redis-x64-xxx.zip并解压，进入解压后的目录，以下命令是启动redis 1redis-server redis.windows.conf 客户端连接为 1redis-cli.exe -h 127.0.0.1 -p 6379 Redis数据结构及操作命令Redis是通过key-value的格式来存储数据的，key是二进制安全的字符串，其中value是支持多种数据类型的，我们需要了解和掌握如下5种数据类型 字符串（String）：二进制安全的字符串，可以是字符串、整数或浮点数 散列（Hash）：一个String类型的field和value的映射表，适合存储对象 列表（List）：字符串列表，按插入顺序排序 集合（Set）：字符串无序集合，去重 有序集合（Sorted Set，zset）：与Set相同，不同的是根据score排序 字符串（String）命令set/get 赋值/取值 语法 123456# 赋值SET key value [EX seconds] [PX milliseconds] [NX|XX]# 取值 GET key# 设置新值，返回旧值GETSET key value EX seconds：键过期时间 PX milliseconds：为键设置毫秒级过期时间 NX：键必须不存在才可以设置成功，用于添加 XX：键必须存在，才可以设置成功，用于更新 示例： 1234127.0.0.1:6379&gt; set test 123OK127.0.0.1:6379&gt; get test"123" incr/incrby/decr/decrby 数值增减 当value值为整数时，才可以使用数值增减命令，incr/decr为增加/减少1，incrby/decrby为增加/减少具体的数值，数值的增减是原子操作 12345678910127.0.0.1:6379&gt; set counter 100OK127.0.0.1:6379&gt; incr counter(integer) 101127.0.0.1:6379&gt; incrby counter 20(integer) 121127.0.0.1:6379&gt; decr counter(integer) 120127.0.0.1:6379&gt; decrby counter 10(integer) 110 mset/mget 同时设置/获取多个键值 在单个命令中设置/获取多个键值是可以减少延迟的 123456127.0.0.1:6379&gt; mset k1 10 k2 20 k3 30OK127.0.0.1:6379&gt; mget k1 k2 k31) "10"2) "20"3) "30" 使用场景 常规的key-value缓存 计数：微博数、粉丝数等 应用INCR原子计数生产全局唯一id或单号 散列（Hash）命令hset/hget/hmset/hmget 设置/取值 123456789101112# 设置一个字段值HSET key field value # 设置多个字段值HMSET key field value [field value ...]# 字段不存在时赋值HMSETNX key field value# 获取一个字段值HGET key field # 获取多个字段值HMGET key field [field ...] # 获取所有字段值HGETALL key 12345678910111213127.0.0.1:6379&gt; hmset user name zou age 23OK127.0.0.1:6379&gt; hset user location Guangzhou(integer) 1127.0.0.1:6379&gt; hget user name"zou"127.0.0.1:6379&gt; hgetall user1) "name"2) "zou"3) "age"4) "23"5) "location"6) "Guangzhou" hincrby 增加数字 12# 增加数字HINCRBY key field increment 12127.0.0.1:6379&gt; hincrby user age 1(integer) 24 其他命令 12345678910# 判断字段是否存在HEXISTS key field# 只获取字段名HKEYS key# 只获取字段值HVALS key# 获取字段数量HLEN key# 获取所有字段和值HGETALL key String和Hash的区别Hash类型适合存储那些对象数据，特别是对象属性经常发生【增删改】操作的数据。 String类型也可以存储对象数据，将Java对象转成json字符串或序列化进行存储，这种存储适合【查询】操作 使用场景 存储结构化数据对象，如用户信息、商品信息 列表（List）Redis的列表是链表结构的，可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段 列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为0(1) ，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的 命令lpush/rpush 添加新元素到列表 1234# 列表的左端添加元素LPUSH key value [value ...]# 列表的右端添加元素RPUSH key value [value ...] 1234127.0.0.1:6379&gt; lpush list:1 1 2 3 (integer) 3 127.0.0.1:6379&gt; rpush list:1 4 5 6 (integer) 3 lrange 获取列表片段 获取列表中的某一片段，返回start、stop之间的所有元素（包含两端的元素），索引从0开始，索引可以是负数，表明从结尾开始计数：所以-1是最后一个元素，-2是列表的倒数第二个元素 1LRANGE key start stop 1234127.0.0.1:6379&gt; lrange list:1 0 2 1) "2" 2) "1" 3) "4" lpop/rpop 从列表两端弹出元素 从列表两端弹出一个元素，会分两步完成： 第一步是将列表左边的元素从列表中移除 第二步是返回被移除的元素值 12LPOP keyRPOP key 1234127.0.0.1:6379&gt;lpop list:1 "3“ 127.0.0.1:6379&gt;rpop list:1 "6“ 其他命令 123456789101112131415# 获取列表中元素的个数LLEN key# 删除列表中指定个数的值# - 当count&gt;0时， LREM会从列表左边开始删除。# - 当count&lt;0时， LREM会从列表后边开始删除。# - 当count=0时， LREM删除所有值为value的元素LREM key count value# 获取指定索引的元素值LINDEX key index# 只保留列表指定片段,指定范围和lrange一致LTRIM key start stop# 向列表中插入元素LINSERT key BEFORE|AFTER pivot value# 将元素从一个列表转移到另一个列表中RPOPLPUSH source destination 使用场景 各种列表：关注列表、粉丝列表、评论 消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出执行 利用LRANGE可以很方便的实现list内容分页的功能 取最新N个数据的操作 集合（Set）Set是字符串的无序集合，其中的数据是不重复且没有顺序，集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型的Redis内部是使用值为空的散列表实现，所有这些操作的时间复杂度都为 0(1)，Redis 还提供了多个集合之间的交集、并集、差集的运算 命令sadd/srem 添加/删除元素 12SADD key member [member ...]SREM key member [member ...] 123456127.0.0.1:6379&gt; sadd set a b c (integer) 3 127.0.0.1:6379&gt; sadd set a (integer) 0 127.0.0.1:6379&gt; srem set c d (integer) 1 smembers 获取所有元素 1SMEMBERS key 123127.0.0.1:6379&gt; smembers set 1) "b" 2) "a” sismember 判断元素是否在集合中 12# 判断元素是否在集合中, 返回1为在，0为不在SISMEMBER key member 1234127.0.0.1:6379&gt;sismember set a (integer) 1 127.0.0.1:6379&gt;sismember set h (integer) 0 sdiff/sinter/sunion 差集/交集/并集运算命令 SDIFF - 集合的差集运算 A-B：属于A并且不属于B的元素构成的集合 1SDIFF key [key ...] 12345678127.0.0.1:6379&gt; sadd setA 1 2 3(integer) 3127.0.0.1:6379&gt; sadd setB 2 3 4(integer) 3127.0.0.1:6379&gt; sdiff setA setB1) "1"127.0.0.1:6379&gt; sdiff setB setA1) "4" SINTER - 集合的交集运算 A ∩ B：属于A且属于B的元素构成的集合 1SINTER key [key ...] 123127.0.0.1:6379&gt; sinter setA setB1) "2"2) "3" SUNION - 集合的并集运算 A ∪ B：属于A或者属于B的元素构成的集合 1SUNION key [key ...] 12345127.0.0.1:6379&gt; sunion setA setB1) "1"2) "2"3) "3"4) "4" 其它命令 1234# 获得集合中元素的个数SCARD key# 从集合中随机弹出一个元素SPOP key 使用场景 需要去重的列表 提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能 有序集合（Sorted Set，zset）有序集合（Sorted Set，zset）在Set集合类型的基础上，有序集合类型为集合中的每个元素都关联一个分数(score) ，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作 SortedSet和List的区别相似点 二者都是有序的，List是按数据插入顺序，SortedSet是根据score自然排序 二者都可以获得某一范围的元素 区别 列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢 有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快 列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现） 有序集合要比列表类型更耗内存 命令zadd/zrem 添加/删除元素 12ZADD key score member [score member ...]ZREM key member [member ...] 123456127.0.0.1:6379&gt; zadd scoreboard 80 zhangsan 89 lisi 94 wangwu(integer) 3127.0.0.1:6379&gt; zadd scoreboard 97 lisi(integer) 0127.0.0.1:6379&gt; zrem scoreboard lisi(integer) 1 zrange/zrevrange 获取范围元素列表 获得排名在某个范围的元素列表。 ZRANGE：按照元素分数从小到大的顺序返回索引从start到stop之间的所有元素（包含两端的元素） ZREVRANGE：按照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素） 123# 如果需要获得元素的分数的可以在命令尾部加上 WITHSCORES 参数ZRANGE key start stop [WITHSCORES] ZREVRANGE key start stop [WITHSCORES] 12345678127.0.0.1:6379&gt; zrange scoreboard 0 21) "zhangsan"2) "wangwu"3) "lisi“127.0.0.1:6379&gt; zrevrange scoreboard 0 21) "lisi"2) "wangwu"3) "zhangsan“ zscore 获取元素的分数 1ZSCORE key member 12127.0.0.1:6379&gt; zscore scoreboard lisi"97" 其它命令 1234567891011121314151617# 获得指定分数范围的元素ZRANGEBYSCORE key min max [WITHSCORES] # 增加某个元素的分数ZINCRBY key increment member# 获得集合中元素的数量ZCARD key# 获得指定分数范围内的元素个数ZCOUNT key min max# 按照排名范围删除元素ZREMRANGEBYRANK key start stop# 按照分数范围删除元素ZREMRANGEBYSCORE key min max# 获取元素的排名 # - ZRANK：从小到大# - ZREVRANK：从大到小ZRANK key memberZREVRANK key member 使用场景 存放一个有序的并且不重复的集合列表 排行榜相关，取TOP N操作 通用命令keys 返回满足规则键值 12# 返回满足规则的key-valueKEYS pattern 12345127.0.0.1:6379&gt; keys k*1) "k1"2) "k3"3) "k2"4) "key" del 删除 1DEL key [key ...] 12127.0.0.1:6379&gt; del k1 k2 k3(integer) 3 exists 是否存在 1EXISTS key [key ...] 1234127.0.0.1:6379&gt; exists test(integer) 1127.0.0.1:6379&gt; exists mytest(integer) 0 expires 生存时间设置（重要） Redis在实际的使用过程中，更多的是作为缓存，而缓存的数据一般都是要设置生存时间的，到期后数据自动销毁 123456789# 设置过期时间（单位：秒）EXPIRES key seconds # 设置过期时间（单位：毫秒）PEXPIRES key milliseconds # 查看key剩余的生存时间TTL keyPTTL key# 清除生存时间PERSIST key 12345678127.0.0.1:6379&gt; expire test 5(integer) 1127.0.0.1:6379&gt; ttl test(integer) 2127.0.0.1:6379&gt; ttl test(integer) -2127.0.0.1:6379&gt; get test(nil) rename 重命名 1RENAME key newkey 123456127.0.0.1:6379&gt; keys *1) "counter"127.0.0.1:6379&gt; rename counter coounter_newOK127.0.0.1:6379&gt; keys *1) "coounter_new" type 查看数据类型 1TYPE key 123456redis 127.0.0.1:6379&gt; type addrstringredis 127.0.0.1:6379&gt; type myzset2zsetredis 127.0.0.1:6379&gt; type mylistlist]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式-一步步组装复杂的对象]]></title>
    <url>%2Fblog%2Fdesign-pattern-builder%2F</url>
    <content type="text"><![CDATA[介绍定义建造者模式是一种创建型模式，它的定义如下 建造者模式(Builder Pattern) - 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。又可以称为生成器模式 适用场景 隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果 多个部件都可以装配到一个对象中，但产生的运行结果不相同 产品类非常复杂或者产品类因为调用顺序不同而产生不同作用 初始化一个对象时，参数过多，或者很多参数具有默认值 Builder模式不适合创建差异性很大的产品类。产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本 需要生成的产品对象有复杂的内部结构，这些产品对象具备共性 建造者模式角色及类图建造者模式角色以及职责 产品类(Product)：具体产品 抽象建造者(Builder)：为创建一个Product产品对象的各个部件指定的抽象接口 具体建造者(ConcreteBuilder)：具体建造者、实现Builder接口，构建和装配各个部件 指挥者(Director)：构建一个使用Builder接口的对象 UML类图 工厂模式和建造者模式的区别构建者模式和工厂模式很类似，区别在于构建者模式是一种个性化产品的创建，通过组装零配件而创建一个新产品。而工厂模式是一种标准化的产品创建，不关心产品的构建过程，只关心什么产品是由什么工厂产生的 实例简单实例以一个点餐的过程为例，我们去到快餐店，每个人都可以根据自己的喜好自由搭配食物和饮料，最后生成的订单也不尽相同，如下 产品类 123456789101112131415161718192021222324252627282930public class Meal &#123; private List&lt;String&gt; foods; private List&lt;String&gt; drinks; public Meal() &#123; this.foods = new ArrayList&lt;&gt;(); this.drinks = new ArrayList&lt;&gt;(); &#125; public List&lt;String&gt; getFoods() &#123; return foods; &#125; public void setFoods(List&lt;String&gt; foods) &#123; this.foods = foods; &#125; public List&lt;String&gt; getDrinks() &#123; return drinks; &#125; public void setDrinks(List&lt;String&gt; drinks) &#123; this.drinks = drinks; &#125; @Override public String toString() &#123; return "Meal&#123;" + "foods=" + foods + ", drinks=" + drinks + '&#125;'; &#125;&#125; 具体建造类 MealBuilder.java123456789101112131415161718192021public class MealBuilder &#123; private Meal meal; public MealBuilder() &#123; meal = new Meal(); &#125; public MealBuilder addFood(String foodName) &#123; meal.getFoods().add(foodName); return this; &#125; public MealBuilder addDrink(String drinkName) &#123; meal.getDrinks().add(drinkName); return this; &#125; public Meal build() &#123; return meal; &#125;&#125; 指挥者/测试 123456789public class MealDirector &#123; @Test public void test()&#123; MealBuilder mealBuilder = new MealBuilder(); // 组装一个产品 Meal meal = mealBuilder.addFood("汉堡").addFood("鸡肉卷").addDrink("可乐").build(); System.out.println(meal); &#125;&#125; 测试 1Meal&#123;foods=[汉堡, 鸡肉卷], drinks=[可乐]&#125; 模板方法模式扩展上面的例子，在构建实例的时候要我们按照需求动态的组装零配件，例如用餐的搭配组合。另外，我们也可以使用模板方法模式对建造者模式进行扩展，把零配件的组装屏蔽封装，例如我们在点餐的时候会有一些套餐，这些套餐就是模板，已经帮我们搭配好零配件 抽象建造者 AbstractMealBuilder.java123456789101112131415public abstract class AbstractMealBuilder &#123; protected Meal meal; public AbstractMealBuilder() &#123; meal = new Meal(); &#125; public abstract void buildFood(); public abstract void buildDrink(); public Meal build() &#123; return meal; &#125;&#125; 具体建造者：A套餐 ConcreteMealBuilderA.java123456789101112public class ConcreteMealBuilderA extends AbstractMealBuilder&#123; @Override public void buildFood() &#123; meal.getFoods().add("辣鸡堡"); meal.getFoods().add("鸡肉卷"); &#125; @Override public void buildDrink() &#123; meal.getDrinks().add("可乐"); &#125;&#125; 具体建造者：B套餐 ConcreteMealBuilderB.java123456789101112public class ConcreteMealBuilderB extends AbstractMealBuilder&#123; @Override public void buildFood() &#123; meal.getFoods().add("牛肉堡"); meal.getFoods().add("薯条"); &#125; @Override public void buildDrink() &#123; meal.getDrinks().add("橙汁"); &#125;&#125; 指挥者 12345678910111213public class Director &#123; private AbstractMealBuilder mealBuilder; public Director(AbstractMealBuilder mealBuilder) &#123; this.mealBuilder = mealBuilder; &#125; public Meal construct() &#123; mealBuilder.buildFood(); mealBuilder.buildDrink(); return mealBuilder.build(); &#125;&#125; 测试 123456789101112public class DirectorDemo &#123; @Test public void test() &#123; AbstractMealBuilder mealBuilderA = new ConcreteMealBuilderA(); Director directorA = new Director(mealBuilderA); System.out.println("A套餐：" + directorA.construct()); AbstractMealBuilder mealBuilderB = new ConcreteMealBuilderB(); Director directorB = new Director(mealBuilderB); System.out.println("B套餐：" + directorB.construct()); &#125;&#125; 测试结果 12A套餐：Meal&#123;foods=[辣鸡堡, 鸡肉卷], drinks=[可乐]&#125;B套餐：Meal&#123;foods=[牛肉堡, 薯条], drinks=[橙汁]&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式-通过克隆创建对象]]></title>
    <url>%2Fblog%2Fdesign-pattern-prototype%2F</url>
    <content type="text"><![CDATA[介绍 原型模式(Prototype Pattern)** - 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象 原型模式(Prototype Pattern)是一个比较简单的创建型设计模式，它的重点在于克隆，也就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象 原型模式结构原型方法模式的角色及职责 客户(Client)：提出创建对象的请求，使用复制对象的方法创建新实例 抽象原型(Abstract Prototype)：定义所有的具体原型类所需的复制方法，接口或抽象类 具体原型(Concrete Prototype)：被克隆、复制的对象，此角色需要实现抽象的原型角色所要求的接口 原型模式通用类图 原型模式实现在Java中实现原型模式特别简单，只要两步即可 实现Cloneable接口 重写clone()方法 123456public class PrototypeClass implements Cloneable&#123; @Override protected PrototypeClass clone() throws CloneNotSupportedException &#123; return (PrototypeClass)super.clone(); &#125;&#125; 原型模式已经与Java融为一体，Object类提供了一个clone()方法，且是native方法（本地原生方法，C/C++实现），所以所有类都可以通过重写Object的clone()方法或者调用clone()方法来实现对对象的克隆 不过要实现克隆的类还必须实现Cloneable接口，Cloneable是一个标识接口，表明该对象可以复制，如果没有实现该接口却调用Object的clone()方法，会抛出CloneNotSupportedException异常 我们再为上面的类添加一些成员变量，看一下再执行克隆方法的情况 12345678910111213141516171819202122232425262728293031public class PrototypeClass implements Cloneable&#123; private String name; private List&lt;String&gt; list = new ArrayList&lt;&gt;(); @Override protected PrototypeClass clone() throws CloneNotSupportedException &#123; return (PrototypeClass)super.clone(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;String&gt; getList() &#123; return list; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; @Override public String toString() &#123; return "[name: " + name + ", list: " + list.toString() + "]"; &#125;&#125; 测试 12345678910111213@Testpublic void test() throws CloneNotSupportedException &#123; PrototypeClass p1 = new PrototypeClass(); p1.setName("zhangsan"); p1.getList().add("zhangsan"); System.out.println("p1 " + p1.toString()); PrototypeClass p2 = p1.clone(); p2.setName("lisi"); p2.getList().add("lisi"); System.out.println("p2 " + p2.toString()); System.out.println("p1 " + p1.toString());&#125; 测试结果 123p1 [name: zhangsan, list: [zhangsan]]p2 [name: lisi, list: [zhangsan, lisi]]p1 [name: zhangsan, list: [zhangsan, lisi]] 从上面的结果我们可以发现，当我们对克隆对象p2的引用类型的成员变量进行修改时，p1的list变量也改变了，这说明原始对象和克隆对象的list变量指向的是同一个对象。为什么会这样呢？ 原来clone()方法只是复制成员变量的值，也就是说如果成员变量是值类型（基本数据类型和String），会复制值，而如果是引用类型，则只会复制引用但不会复制引用所指向的对象，这种复制叫做浅复制。两个对象会共享一个私有的变量，大家都能修改，这是不安全的，那是不是还有更深入的复制呢？ 浅复制和深复制 浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的 深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底 我们通过直接调用Object的clone()便可以实现浅复制，但是引用地址只是复制了它的引用，那么我们想复制它指向的对象，是不是可以对成员变量也调用clone()方法复制一遍 123456789101112131415161718192021222324252627282930313233public class PrototypeClass implements Cloneable &#123; private String name; private ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); @Override protected PrototypeClass clone() throws CloneNotSupportedException &#123; PrototypeClass newPrototypeClass = (PrototypeClass) super.clone(); newPrototypeClass.list = (ArrayList&lt;String&gt;) this.list.clone(); return newPrototypeClass; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public ArrayList&lt;String&gt; getList() &#123; return list; &#125; public void setList(ArrayList&lt;String&gt; list) &#123; this.list = list; &#125; @Override public String toString() &#123; return "[name: " + name + ", list: " + list.toString() + "]"; &#125;&#125; 测试 12345678910111213@Testpublic void test() throws CloneNotSupportedException &#123; PrototypeClass p1 = new PrototypeClass(); p1.setName("zhangsan"); p1.getList().add("zhangsan"); System.out.println("p1 " + p1.toString()); PrototypeClass p2 = p1.clone(); p2.setName("lisi"); p2.getList().add("lisi"); System.out.println("p2 " + p2.toString()); System.out.println("p1 " + p1.toString());&#125; 测试结果 123p1 [name: zhangsan, list: [zhangsan]]p2 [name: lisi, list: [zhangsan, lisi]]p1 [name: zhangsan, list: [zhangsan]] 使用序列化实现深复制使用序列化实现深复制，采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象 12345678910111213141516171819202122232425262728293031323334353637383940public class PrototypeClassSerialize implements Serializable &#123; private String name; private ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); /** * 深复制 需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象 */ public Object deepClone() throws IOException, ClassNotFoundException &#123; // 将对象序列化到二进制流 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); // 从二进制流中读出产生的新对象 ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public ArrayList&lt;String&gt; getList() &#123; return list; &#125; public void setList(ArrayList&lt;String&gt; list) &#123; this.list = list; &#125; @Override public String toString() &#123; return "[name: " + name + ", list: " + list.toString() + "]"; &#125;&#125; 测试 12345678910111213@Testpublic void test() throws IOException, ClassNotFoundException &#123; PrototypeClassSerialize p1 = new PrototypeClassSerialize(); p1.setName("zhangsan"); p1.getList().add("zhangsan"); System.out.println("p1 " + p1.toString()); PrototypeClassSerialize p2 = (PrototypeClassSerialize) p1.deepClone(); p2.setName("lisi"); p2.getList().add("lisi"); System.out.println("p2 " + p2.toString()); System.out.println("p1 " + p1.toString());&#125; 测试结果 123p1 [name: zhangsan, list: [zhangsan]]p2 [name: lisi, list: [zhangsan, lisi]]p1 [name: zhangsan, list: [zhangsan]]]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式-简单工厂模式、工厂方法模式、抽象工厂模式]]></title>
    <url>%2Fblog%2Fdesign-pattern-factory%2F</url>
    <content type="text"><![CDATA[工厂模式工厂模式是一种比较常见的创建型设计模式，分为简单工厂模式、工厂方法模式、抽象工厂模式 工厂模式旨在把对象的创建和使用分离开来，把创建对象的职责交给工厂类，这样会有哪些好处？ 解耦：对象的创建和使用分离 减少代码重复、创建蔓延，降低维护成本：对于创建较为复杂的对象，可以减少代码重复、降低维护成本 简单工厂模式介绍 简单工厂模式-又叫做静态工厂方法，工厂类提供创建对象的方法（如create），接收一个参数，通过不同的参数实例化不同的产品类 简单工厂方法并不属于23种常见设计模式之一，适用于相对简单的场景，创建较少的对象。最重要的一点是它违背了开闭原则（对扩展开发，对修改关闭）(可以通过反射机制避免)，因为在扩展产品类的时候需要添加条件分支（如if-else、switch-case），需要修改工厂类方法 简单工厂类图简单工厂模式角色分配 工厂(Factory)：负责实现创建所有实例的内部逻辑，工厂类可以被外界直接调用，创建所需的产品对象 抽象产品(Product)：负责描述所有实例的公共接口 具体产品(ConcreteProduct)：简单工厂模式的创建目标 代码实例创建一个可以展示不同图表的工具，可以展示柱状图、饼图、折线图，每个图表对象都有方法display()展示图表。 简单工厂 ChartFactory.java123456789101112131415161718public class ChartFactory &#123; /** * 创建图表 负担太重、不符合开闭原则 */ public static IChart create(String type) &#123; switch (type) &#123; case "bar": return new BarChart(); case "pie": return new PieChart(); case "line": return new LineChart(); default: return null; &#125; &#125;&#125; 静态方法工厂 ChartFactory2.java1234567891011121314public class ChartFactory2 &#123; public static BarChart createBarChart() &#123; return new BarChart(); &#125; public static PieChart createPieChart() &#123; return new PieChart(); &#125; public static LineChart createLineChart() &#123; return new LineChart(); &#125;&#125; 反射机制改良简单工厂使用简单工厂模式，当我们需要扩展的时候，是不符合开闭原则的，如上面的例子需要多一种图表展示，那么工厂类的创建方法就需要多处理一个条件分支。那如何可以让我们对扩展开放、对修改关闭呢？使用反射机制是可以做到的 ChartFactory3.java12345678910111213141516171819202122public class ChartFactory3 &#123; public static IChart create(Class&lt;? extends IChart&gt; clazz) &#123; IChart chart = null; try &#123; chart = clazz.newInstance(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; return chart; &#125; public static IChart create(String className) &#123; IChart chart = null; try &#123; chart = (IChart) Class.forName(className).newInstance(); &#125; catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return chart; &#125;&#125; Spring 的Ioc容器是通过配置文件和反射机制解决了简单工厂中的缺点 工厂方法模式介绍工厂方法的使用频率很高，经常可以在一些项目中看见 工厂方法(Factory Method) - 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类 工厂方法针对每一种产品提供一个工厂类，通过不同的工厂实例来创建不同的产品实例，相比于简单工厂来说，不再提供一个统一的工厂创建所有的对象 优点 工厂方法模式很好的减轻了工厂类的负担，把一种类交由一个工厂创建 同时增加产品类并不需要修改工厂类，只需要添加创建该产品的工厂即可，使得工厂类符合开放-封闭原则 缺点 对于某些可以形成产品族（一组产品）的情况处理比较复杂 工厂方法类图工厂方法模式角色分配 抽象工厂(Factory)：创建对象的工厂类的接口或父类 具体工厂(ConcreteFactory)：实现抽象工厂接口的具体工厂类 抽象产品(Product)：工厂类所创建对象的超类型，也就是具体产品对象的共同父类或接口 具体产品(ConcreteProduct)：具体产品由专门的具体工厂创建 代码示例对上面简单工厂模式的例子修改，增加一个工厂接口和实现接口的具体工厂类 工厂接口 IChartFactory.java123public interface IChartFactory &#123; IChart getChart();&#125; 工厂实现-柱状图工厂类 BarChartFactory.java123456public class BarChartFactory implements IChartFactory&#123; @Override public IChart getChart() &#123; return new BarChart(); &#125;&#125; 抽象工厂模式介绍抽象工厂模式是比较难理解的工厂模式了，它的定义如下 抽象工厂模式(Abstract Factory) - 为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类 抽象工厂是应对产品族概念的 工厂方法模式是一种极端情况的抽象工厂模式（即只生产一种产品的抽象工厂模式），而抽象工厂模式可以看成是工厂方法模式的一种推广 最大的缺点就是产品族扩展非常困难，增加一个产品，工厂类就需要增加一个创建该产品对象的方法 抽象工厂类图抽象工厂模式角色分配 抽象工厂(AbstractFactory)：创建对象的工厂类的接口或父类，包含所有产品创建的抽象方法 具体工厂(ConcreteFactory)：实现抽象工厂接口的具体工厂类 抽象产品(AbstractProduct)：具体产品对象的共同父类或接口（有多个，一个产品族） 具体产品(ConcreteProduct)：具体产品由专门的具体工厂创建 如上类图，ProductA和ProductB是一个产品族的两个抽象产品，两个抽象产品都各自有可能有多个实现，ConcreteProductA1、ConcreteProductA2、ConcreteProductB1、ConcreteProductB2都是这些抽象产品的具体实现。AbstractFactory是工厂类的抽象接口，包含所有产品创建的抽象方法，工厂类不止是去创建一个产品对象，而是负责创建一个产品族的对象 代码示例有组装过台式电脑的人可能知道一台电脑有很多配件组成，有CPU、主板、显卡、内存、硬盘、外设等，这些配件就可以看成是一个产品族的产品，而各个配件有不同的生产厂家和型号，有的可以混合搭配、有的需要指定型号。这里为了简单，假设只需要CPU和主板，CPU的生产厂家主要是Intel和AMD、对应的主板型号也不尽相同 抽象工厂 IFactory.java123456public interface IFactory &#123; ICpu createCpu(); IMainboard createMainboard();&#125; 抽象产品 ICpu.java123public interface ICpu &#123; void installCpu();&#125; IMainboard.java123public interface IMainboard &#123; void installMainboard();&#125; 总结工厂模式区别 简单工厂：使用一个工厂对象用来生产同一等级结构中的任意产品。（不支持拓展增加产品） 工厂方法：使用多个工厂对象用来生产同一等级结构中对应的固定产品。（支持拓展增加产品） 抽象工厂：使用多个工厂对象用来生产不同产品族的全部产品。（不支持拓展增加产品族；支持增加产品）]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
        <tag>简单工厂</tag>
        <tag>工厂方法</tag>
        <tag>抽象工厂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式-只有一个实例]]></title>
    <url>%2Fblog%2Fdesign-pattern-singleton%2F</url>
    <content type="text"><![CDATA[介绍单例模式（Singleton Pattern）是一个比较简单的设计模式，属于创建型模式。其定义为 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例 在系统中，单例模式要求一个单例对象只能有一个实例，这类对象如果有多个实例就可能会产生一些问题，如：资源消耗过多，处理结果不一致等，一般单例会有以下使用场景 生成唯一 序列号 整个项目的共享访问点或共享数据，如Web页面计数器 创建一个对象实例需要消耗过多资源，如I/O和数据库连接等 在Java中，一个单例对象在一个JVM中，只会有一个实例存在。以下是单例模式结构图 有一个该单例对象的静态成员变量 私有的构造函数，只能被自身实例化 提供一个静态公共方法实例化对象，并访问该对象实例 单例模式实现单例模式有两种实现方式： 饿汉式 懒汉式(延迟加载) 饿汉式12345678910111213/** * 饿汉式单例 */public class Singleton1 &#123; // 静态成员变量，在静态初始化时便实例化对象 private static final Singleton1 singleton = new Singleton1(); // 构造私有 private Singleton1()&#123; &#125; public static Singleton1 getSingletonInstance()&#123; return singleton; &#125;&#125; 饿汉式指的是，在类加载的时候便实例化了该单例对象，不管有没有使用，先创建了再说。这种方式是可以保证线程安全的，但是如果该对象一直没有被使用，就浪费了空间资源。 但是对于一些空间占用较大、或是只在某些特定场景才使用的单例，我们会想要在第一次使用的时候才去实例化，这时，就需要懒汉式的延迟加载 懒汉式1234567891011121314/** * 懒汉式单例（非线程安全） */public class Singleton2 &#123; private static Singleton2 singleton; private Singleton2()&#123;&#125; // 获取实例 public static Singleton2 getSingletonInstance()&#123; if(singleton == null)&#123; singleton = new Singleton2(); &#125; return singleton; &#125;&#125; 从上面代码可以看出，懒汉式与饿汉式在于单例对象的创建时机。饿汉式是在类加载时便实例化对象，调用时无须判断直接返回即可；而懒汉式是在第一次调用时实例化，并且每次调用都需要判断是否已经实例化 但是上面的这种方式在多线程下是不安全的，多个线程同时访问getSingletonInstance()时，可能会创建多个实例，便不再是单例了。那怎么解决线程安全的问题呢？首先我们可能会想到对getSingletonInstance()方法加上synchronized关键字 1234567891011121314/** * 懒汉式单例（synchronized关键字线程安全） */public class Singleton3 &#123; private static Singleton3 singleton; private Singleton3()&#123;&#125; // 获取实例 public static synchronized Singleton3 getSingletonInstance()&#123; if(singleton == null)&#123; singleton = new Singleton3(); &#125; return singleton; &#125;&#125; getSingletonInstance()方法加上了同步锁，增加了获取实例的时间消耗，且在多线程下可能会发生阻塞。但其实我们并不想每次获取实例的时候都去加上锁，只是想在第一次调用创建对象时保证线程安全即可 双重校验锁（DCL）对getSingletonInstance()方法加上锁，确实能保证线程安全，却存在性能的问题。是不是要必要对整个方法加锁？还是当我检查到实例还没有创建，才去同步 双重校验锁（double-checked locking，DCL）是能解决这个问题的 1234567891011121314151617181920212223/** * 双重校验锁（double-checked locking，DCL） */public class Singleton4 &#123; /** * 成员变量这里会加上关键字 volatile，目的是为了防止指令重排序 */ private static volatile Singleton4 singleton; private Singleton4()&#123;&#125; // 获取实例 public static Singleton4 getSingletonInstance()&#123; // 第一次校验，没有实例化才进入同步代码块 if(singleton == null)&#123; synchronized (Singleton4.class)&#123; // 进入同步代码块后，再判断，如果为空才创建实例 if(singleton == null)&#123; singleton = new Singleton4(); &#125; &#125; &#125; return singleton; &#125;&#125; 不对方法加上锁，只对创建实例的代码加锁即可。方法中会有两次判空的操作，第一次是为了不必要的同步，为null才进入同步代码块，第二次是进入同步代码块后判断为null才创建实例 注意：这里的成员变量加上了volatile关键字 使用volatile可以保证数据的可见性，不过synchronized也是能保证同步数据的可见性的，这里使用volatile更多的目的是为了禁止Java指令重排序 静态内部类123456789101112131415161718/** * 静态内部类 */public class Singleton5 &#123; private Singleton5()&#123;&#125; // 获取实例 public static Singleton5 getSingletonInstance()&#123; return SingletonHolder.SINGLETON; &#125; /** * 内部类，JVM在类加载的时候，是互斥的，可以保证线程安全 */ private static class SingletonHolder&#123; private static final Singleton5 SINGLETON = new Singleton5(); &#125;&#125; JVM在类加载的时候是会保证数据同步的，我们可以通过内部类来创建单例对象。第一次加载Singleton5时并不会加载内部类，不去使用内部类的时候，该内部类就不会加载。只有第一次调用getSingletonInstance()方法，会去加载内部类并实例化单例对象，这样就可以做到延迟加载和线程安全了 枚举方式使用枚举方式来实现单例是非常简洁的，支持序列化机制，绝对防止多次实例化 1234567891011121314/** * 枚举方式 */public enum Singleton6 &#123; /** * 枚举方式实现单例 */ SINGLETON; public void handle() &#123; // to do something &#125;&#125; 该单例的使用方法 123456789public class SingletonDemo &#123; @Test public void test()&#123; // 枚举方式 Singleton6 singleton = Singleton6.SINGLETON; singleton.handle(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swagger使用和注释介绍]]></title>
    <url>%2Fblog%2Fswagger-usage-annotation%2F</url>
    <content type="text"><![CDATA[介绍什么是SwaggerSwagger是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。 作用 接口文档在线自动生成 功能测试 Swagger是一组开源项目，其中主要要项目如下： Swagger-tools:提供各种与Swagger进行集成和交互的工具。例如模式检验、Swagger 1.2文档转换成Swagger 2.0文档等功能。 Swagger-core: 用于Java/Scala的的Swagger实现。与JAX-RS(Jersey、Resteasy、CXF…)、Servlets和Play框架进行集成。 Swagger-js: 用于JavaScript的Swagger实现。 Swagger-node-express: Swagger模块，用于node.js的Express web应用框架。 Swagger-ui：一个无依赖的HTML、JS和CSS集合，可以为Swagger兼容API动态生成优雅文档。 Swagger-codegen：一个模板驱动引擎，通过分析用户Swagger资源声明以各种语言生成客户端代码。 在Spring使用Swagger在Spring中集成Swagger会使用到springfox-swagger，它对Spring和Swagger的使用进行了整合 12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;$&#123;springfox.swagger.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;springfox.swagger.version&#125;&lt;/version&gt;&lt;/dependency&gt; 使用Spring中配置Swagger1234567891011121314151617181920212223242526272829303132333435363738394041/** * Swagger2配置类 * 在与spring boot集成时，放在与Application.java同级的目录下。 * 或者通过 @Import 导入配置 */@Configuration@EnableSwagger2public class Swagger2 &#123; /** * 创建API应用 * apiInfo() 增加API相关信息 * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现， * 本例采用指定扫描的包路径来定义指定要建立API的目录。 * @return */ @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.turbo.demo.controller")) .paths(PathSelectors.any()) .build(); &#125; /** * 创建该API的基本信息（这些基本信息会展现在文档页面中） * 访问地址：http://项目实际地址/swagger-ui.html * @return */ private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("Spring Boot中使用Swagger2构建RESTful APIs") .description("") .termsOfServiceUrl("") .contact("zou", "", "zouxq412@foxmail.com") .version("1.0") .build(); &#125;&#125; API注解@Api用在类上，该注解将一个Controller（Class）标注为一个swagger资源（API）。在默认情况下，Swagger-Core只会扫描解析具有@Api注解的类，而会自动忽略其他类别资源（JAX-RS endpoints，Servlets等等）的注解。该注解包含以下几个重要属性 tagsAPI分组标签。具有相同标签的API将会被归并在一组内展示。 value如果tags没有定义，value将作为Api的tags使用 descriptionAPI的详细描述，在1.5.X版本之后不再使用，但实际发现在2.0.0版本中仍然可以使用 @ApiOperation在指定的（路由）路径上，对一个操作或HTTP方法进行描述。具有相同路径的不同操作会被归组为同一个操作对象。不同的HTTP请求方法及路径组合构成一个唯一操作。此注解的属性有： value对操作的简单说明，长度为120个字母，60个汉字。 notes对操作的详细说明。 httpMethodHTTP请求的动作名，可选值有：”GET”, “HEAD”, “POST”, “PUT”, “DELETE”, “OPTIONS” and “PATCH”。 code默认为200，有效值必须符合标准的HTTP Status Code Definitions。 @ApiImplicitParams用在方法上，注解ApiImplicitParam的容器类，以数组方式存储。 @ApiImplicitParam对API的单一参数进行注解。虽然注解@ApiParam同JAX-RS参数相绑定，但这个@ApiImplicitParam注解可以以统一的方式定义参数列表，也是在Servelet及非JAX-RS环境下，唯一的方式参数定义方式。注意这个注解@ApiImplicitParam必须被包含在注解@ApiImplicitParams之内。可以设置以下重要参数属性： name参数名称 value参数的简短描述 required是否为必传参数 dataType参数类型，可以为类名，也可以为基本类型（String，int、boolean等） paramType参数的传入（请求）类型，可选的值有path, query, body, header or form。 @ApiParam增加对参数的元信息说明。这个注解只能被使用在JAX-RS 1.x/2.x的综合环境下。其主要的属性有 required是否为必传参数，默认为false value参数简短说明 @ApiResponses注解@ApiResponse的包装类，数组结构。即使需要使用一个@ApiResponse注解，也需要将@ApiResponse注解包含在注解@ApiResponses内。 @ApiResponse描述一个操作可能的返回结果。当REST API请求发生时，这个注解可用于描述所有可能的成功与错误码。可以用，也可以不用这个注解去描述操作的返回类型，但成功操作的返回类型必须在@ApiOperation中定义。如果API具有不同的返回类型，那么需要分别定义返回值，并将返回类型进行关联。但Swagger不支持同一返回码，多种返回类型的注解。注意：这个注解必须被包含在@ApiResponses注解中。 codeHTTP请求返回码。有效值必须符合标准的HTTP Status Code Definitions。 message更加易于理解的文本消息 response返回类型信息，必须使用完全限定类名，比如“com.xyz.cc.Person.class”。 responseContainer如果返回类型为容器类型，可以设置相应的值。有效值为 “List”, “Set” or “Map”，其他任何无效的值都会被忽略。 Model注解对于Model的注解，Swagger提供了两个：@ApiModel及@ApiModelProperty，分别用以描述Model及Model内的属性。 @ApiModel描述一个Model的信息（一般用在请求参数无法使用@ApiImplicitParam注解进行描述的时候） 提供对Swagger model额外信息的描述。在标注@ApiOperation注解的操作内，所有的类将自动被内省（introspected），但利用这个注解可以做一些更加详细的model结构说明。主要属性有： valuemodel的别名，默认为类名 descriptionmodel的详细描述 @ApiModelProperty描述一个model的属性 对model属性的注解，主要的属性值有： value属性简短描述 example属性的示例值 required是否为必须值 注解示例Api 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@AllArgsConstructor@RestController@RequestMapping("/api/category")@Api(value = "/category", tags = "组件分类")public class BizCategoryController &#123; private IBizCategoryService bizCategoryService; @GetMapping("/list") @ApiOperation(value = "列表", notes = "分页列表") public R&lt;PageModel&lt;BizCategory&gt;&gt; list(PageQuery pageQuery, @RequestParam @ApiParam("组件分类名称") String name) &#123; IPage&lt;BizCategory&gt; page = bizCategoryService.page(pageQuery.loadPage(), new LambdaQueryWrapper&lt;BizCategory&gt;().like(BizCategory::getName, name)); return R.success(page); &#125; @GetMapping("/list/all") @ApiOperation(value = "查询所有", notes = "分页列表") public R&lt;List&lt;BizCategory&gt;&gt; listAll() &#123; List&lt;BizCategory&gt; categories = bizCategoryService.list(); return R.success(categories); &#125; @GetMapping("/&#123;categoryId&#125;") @ApiOperation(value = "详情", notes = "组件分类详情") public R&lt;BizCategory&gt; detail(@PathVariable @ApiParam("分类Id") Long categoryId) &#123; BizCategory category = bizCategoryService.getById(categoryId); return R.success(category); &#125; @PostMapping("/save") @ApiOperation(value = "保存", notes = "新增或修改") @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = "form", name = "categoryId", value = "组件id（修改时为必填）"), @ApiImplicitParam(paramType = "form", name = "name", value = "组件分类名称", required = true) &#125;) public R&lt;BizCategory&gt; save(Long categoryId, String name) &#123; BizCategory category = new BizCategory(); category.setId(categoryId); category.setName(name); bizCategoryService.saveOrUpdate(category); return R.success(category); &#125; @DeleteMapping("/&#123;categoryId&#125;") @ApiOperation(value = "删除", notes = "删除") public R delete(@PathVariable @ApiParam("分类Id") Long categoryId) &#123; bizCategoryService.delete(categoryId); return R.success(); &#125;&#125; ApiModel 示例 12345678910111213141516171819202122232425262728293031@Data@EqualsAndHashCode(callSuper = false)@Accessors(chain = true)@ApiModel(value="BizComponent对象", description="组件")public class BizComponent implements Serializable &#123; private static final long serialVersionUID = 1L; @TableId(value = "id", type = IdType.AUTO) private Long id; @ApiModelProperty(value = "分类") private Long categoryId; @ApiModelProperty(value = "组件名称") private String name; @ApiModelProperty(value = "组件描述") private String description; @ApiModelProperty(value = "日期字段") private LocalDateTime componentTime; @ApiModelProperty(value = "创建时间") @TableField(fill = FieldFill.INSERT) private LocalDateTime createTime; @ApiModelProperty(value = "修改时间") @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime modifiedTime;&#125; swagger-ui界面swagger生成的api文档信息接口为/v2/api-docs，不过我们可以使用ui界面更加清晰的查看文档说明，并且还能够在线调试 springfox-swagger-ui12345&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;springfox.swagger.version&#125;&lt;/version&gt;&lt;/dependency&gt; 如果是使用springfox-swagger-ui，启动项目后的api文档访问路径是 /swagger-ui.html swagger-bootstrap-uiswagger-bootstrap-ui是springfox-swagger的增强UI实现，我个人更推荐使用这个ui，api文档结构更加清晰，在线调试也很方便 12345&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;swagger.bootstrap.ui.version&#125;&lt;/version&gt;&lt;/dependency&gt; 访问的url为 /doc.html Swagger分组Swagger的分组接口是通过后端配置不同的扫描包，将后端的接口，按配置的扫描包基础属性响应给前端 后端java的配置如下，指定分组名和各自要扫描的包 1234567891011121314151617181920@Bean(value = "defaultApi")public Docket defaultApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .groupName("默认接口") .select() .apis(RequestHandlerSelectors.basePackage("com.example.demo.controller")) .paths(PathSelectors.any()) .build();&#125;@Bean(value = "groupApi")public Docket groupRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(groupApiInfo()) .groupName("分组接口") .select() .apis(RequestHandlerSelectors.basePackage("com.example.demo.group")) .paths(PathSelectors.any()) .build();&#125; 分组信息的接口为 /swagger-resources 12345678910111213[ &#123; "name": "分组接口", "url": "/v2/api-docs?group=分组接口", "swaggerVersion": "2.0", "location": "/v2/api-docs?group=分组接口" &#125;,&#123; "name": "默认接口", "url": "/v2/api-docs?group=默认接口", "swaggerVersion": "2.0", "location": "/v2/api-docs?group=默认接口" &#125;] 在swagger-ui中也可以通过分组来查看api文档]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-面向对象设计原则]]></title>
    <url>%2Fblog%2Fdesign-pattern-philosophy%2F</url>
    <content type="text"><![CDATA[设计模式（Design Pattern）是前辈们在代码实践中所总结的经验，是解决某些特定问题的套路。在使用一些优秀的框架时，可能会接触到它里面所运用到的一些设计模式，又或许你在编码去设计一些模块时，为了提高代码可复用性、扩展性、可读性等，运用到的一些设计理念也会与某些设计模式思想相吻合。 系统的了解和学习设计模式是很有必要的，能帮助提升面对对象设计的能力，了解各种设计模式的特点和运用场景 在学习设计模式前，先了解下面对对象的设计原则 面对对象设计原则对于一个好的面对对象软件系统的设计来说，可维护性和可复用性是很重要的，如何同时提高一个系统的可维护性和可复用性是面对对象设计需要解决的核心问题之一。 在面对对象设计中，面对对象设计原则是为了去支持可维护性和可复用性的，这些原则会体现在很多的设计模式中，也就是说这些设计原则实际上就是从这些设计方案中总结提取出来的指导性原则。 最常见的7种面向对象设计原则 设计原则名称 定义 开闭原则(Open-Closed Principle, OCP) 软件实体应对扩展开放，而对修改关闭 单一职责原则(Single Responsibility Principle, SRP) 一个类只负责一个功能领域中的相应职责 里氏代换原则(Liskov Substitution Principle, LSP) 所有引用基类对象的地方能够透明地使用其子类的对象 依赖倒转原则(Dependence Inversion Principle, DIP) 抽象不应该依赖于细节，细节应该依赖于抽象 接口隔离原则(Interface Segregation Principle, ISP) 使用多个专门的接口，而不使用单一的总接口 合成复用原则(Composite Reuse Principle,CRP) 尽量使用对象组合，而不是继承来达到复用的目的 迪米特法则(Law of Demeter, LoD) 一个软件实体应当尽可能少地与其他实体发生相互作用 设计原则开闭原则 开闭原则（开放-封闭原则）有两个特征，对扩展是开放的（Open for extension），对修改是封闭的（Open for modification）。也就是说一个软件实体（模块、类、函数等等）要实现变化，应该是通过扩展而不是修改已有的代码 任何的软件在其生命周期内需求都可能会发生变化，既然变化是必然的，我们就应该在设计时尽量适应这些变化，以提高项目的稳定性和灵活性。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。设计模块时，对最可能发生变化的地方，通过构造抽象来隔离这些变化。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求 这里举一个简单的例子，某个系统中某个功能可以来显示各种类型的图表，比如饼图和柱状图。开始的设计方案如下： ChartDisplay中的display方法如下 1234567if (type.equals("pie")) &#123; PieChart chart = new PieChart(); chart.display();&#125;else if (type.equals("bar")) &#123; BarChart chart = new BarChart(); chart.display();&#125; 在这个例子中，假如我需要添加新的图表对象（折线图LineChart），那么我需要在ChartDisplay中的display方法中去添加新的判断逻辑，这是不符合开闭原则。ChartDisplay类是用来做图表的显示工作，但具体的图表是变化的，需要将这些变化隔离出来 抽象化的方法： 增加一个抽象类AbstractChart，作为其他具体图表类的父类 ChartDisplay的display方法只针对抽象父类AbstractChart，而具体的图表类交由客户端去选择 重构后的结构如下 如上，ChartDisplay只针对抽象类AbstractChart编程，通过setChart来获得具体的图表对象，dispalay方法中直接执行 chart.display()，当我们要新增新的图表，那么直接创建图表子类继承AbstractChart，并实现自己的display方法就好，并不需要修改已有的代码。 单一职责原则 单一职责原则(Single Responsibility Principle, SRP)：一个类应该只有一个职责，对外只提供一种功能，应该有且仅有一个原因引起类的变化 能力越大，责任越大？我们不能创建一个“超级类”，能解决所有的事情，相反，一个类（大到模块，小到方法）所承担的责任越多，那么他被复用的可能性就越小。而且一个类承担的职责过多，这些职责耦合度会很高，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中 单一职责原则，用于控制类的粒度大小，实现高内聚、低耦合，它是最简单但又最难运用的原则，如何发现类的不同职责并将其分离，需要具有较强的分析设计能力和相关实践经验。如果你能够想到多于一个动机去改变一个类，那么这个类就有多于一个的职责，就要考虑类的职责分离 记得在刚入门Java接触到 JDBC的时候，为了实现查询学生列表，一口气从数据库的连接到数据查询再到数据展示，简直“一气呵成”，但这种面向过程式的编程却没有很好的扩展性，当我想要再实现其他功能时，将会有大量重复的代码，而重复的地方需要修改，那就更麻烦了。后来稍微改进了，建立了只负责数据库连接资源的类DBUtil，再到后来使用持久层的框架。职责划分后，开发时便只需关注业务的处理 单一职责适用于接口、类，同时也适用于方法，一个方法尽可能做一件事情，比如一个方法修改用户密码，不要把这个方法放到“修改用户信息”方法中，这个方法的颗粒度很粗 上面的方法就职责不清晰，不单一，下面替换成具体的修改动作，通过命名我们就能知晓方法的大概处理逻辑 里式替换原则 里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象 里氏代换原则告诉我们，在软件中,只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象 里式替换才使得开发-封闭成为可能，子类的可替代性才使得使用父类类型的地方可以在无需修改的情况下就可以扩展。里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一 依赖倒转原则如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现 依赖倒转原则(Dependency Inversion Principle, DIP)：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象 上面的定义有些别扭，引入《设计模式之禅》的话来说明依赖倒转 高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块。那什么是抽象？什么又是细节呢？在Java语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化，也就是可以加上一个关键字new产生一个对象。 依赖倒置原则在Java语言中的表现就是： 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的； 接口或抽象类不依赖于实现类； 实现类依赖接口或抽象类 更精简的定义就是要面向接口编程(Object-Oriented Design)，而不是针对实现编程 看到依赖倒转和它的定义，是否会想起Spring的依赖注入(Dependency Injection, DI)和控制反转(Inversion of Control,IOC)，通常我们使用Spring的IoC容器时，会声明依赖的接口，在程序运行时确定具体的实现类并注入。这样便降低了类间的耦合性、提高了系统的稳定性 接口分离原则 接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口 根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同： (1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。 (2) 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的： 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建 合成复用原则合成复用原则又称为组合/聚合复用原则(Composition/Aggregate Reuse Principle, CARP) 合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承 在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用 继承复用的主要问题在于继承复用会破坏系统的封装性： 因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用 子类与父类的耦合度高，如果父类发生改变，那么子类的实现也不得不发生改变，这不利于类的扩展与维护 从父类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性 而且继承只能在有限的环境中使用（如类没有声明为不能被继承） 组合或聚合关系可以将已有的对象到新对象中，使之成为新对象的一部分 新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用 相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作 合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象 一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。 迪米特原则迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP） 迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用 如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。 迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括以下几类： 当前对象本身(this)； 以参数形式传入到当前对象方法中的对象； 当前对象的成员对象； 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； 当前对象所创建的对象。 任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。 迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 在将迪米特法则运用到系统设计中时，要注意下面的几点： 在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及 在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限 在类的设计上，只要有可能，一个类型应当设计成不变类 在对其他类的引用上，一个对象对其他对象的引用应当降到最低 总结这 7 种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。 开闭原则是总纲，它告诉我们要【对扩展开放，对修改关闭】 里氏替换原则告诉我们【不要破坏继承体系】 依赖倒置原则告诉我们要【面向接口编程】 单一职责原则告诉我们实现类要【职责单一】 接口隔离原则告诉我们在设计接口的时候要【精简单一】 迪米特法则告诉我们要【降低耦合度】 合成复用原则告诉我们要【优先使用组合或者聚合关系复用，少用继承关系复用】 23种设计模式总体来说，设计模式按照功能分为三类23种： 创建型（5种） ： 工厂模式、抽象工厂模式、单例模式、原型模式、建造者模式 结构型（7种）： 适配器模式、装饰模式、代理模式 、外观模式、桥接模式、组合模式、享元模式 行为型（11种）： 模板方法模式、策略模式 、观察者模式、中介者模式、状态模式、责任链模式、命令模式、迭代器模式、访问者模式、解释器模式、备忘录模式 参考：《大话设计模式》、《设计模式之禅》、网上相关设计模式文章]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>设计原则</tag>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Data JPA 使用]]></title>
    <url>%2Fblog%2Fspring-cloud-jpa%2F</url>
    <content type="text"><![CDATA[Java 持久层框架访问数据库的方式大致分为两种。一种以 SQL 中心，封装一定程度的 JDBC 操作，比如 MyBatis。另一种是以 Java Entity 为中心，将实体的关系对应到数据库表之间的关系，如 ORM (Object Relational Mapping) 工具。 JAP (Java Persistence API) 就是用来整合第三方 ORM 框架的，即建立一套标准的方式。通过注解或 XML 描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中 Spring Data JPA 介绍什么是 Spring Data JPASpring 提供的一个用于简化 JPA 开发的框架。可以极大的简化 JPA 的写法，可以在几乎不用写实现的情况下，实现对数据的访问和操作。除了CRUD外，还包括如分页、排序等一些常用的功能。 Spring Data JPA 是 Spring Data 中的一个子模块 JPA 是一套标准接口，而 Hibernate 是 JPA 的实现，而 Spring Data JPA 底层默认实现是使用Hibernate Spring Data JPA 的首个接口就是 Repository，它是一个标记接口。只要我们的接口实现这个接口，那么我们就相当于在使用 Spring Data JPA 了。 就是说，只要我们实现了这个接口，我们就可以使用“按照方法命名规则”来进行查询。 JPA、Hibernate 与 Spring Data JPAJPA 是一套 ORM 规范——即只提供接口，显然接口不能直接拿来使用。Hibernate实现了 JPA 规范，在 Hibernate 中有自己的独立 ORM 操作数据库方式，也有 JPA 规范实现的操作数据库方式。 虽然 ORM 框架都实现了 JPA 规范，但是在不同 ORM 框架之间切换是需要编写的代码有一些差异，而通过使用 Spring Data Jpa 能够方便大家在不同的 ORM 框架中间进行切换而不要更改代码。并且 Spring Data Jpa 对 Repository 层封装的很好，可以省去不少的麻烦。 Spring Data JPA 可以理解为 JPA 规范的再次封装抽象，底层还是使用了 Hibernate 的 JPA 技术实现。 JPA 实体相关注解@Entity标注位置：实体类声明语句之前； 主要作用：标注该Java类为实体类，且将其映射到指定的数据库表。 @Table标注位置：实体类声明语句之前，与@Entity注释并列使用； 主要作用：标注当前实体类映射到数据库中的数据表名，当实体类与数据表名不同时使用。 @Id标注位置：实体类的属性声明语句之前，或属性的getter()方法之前； 主要作用：指定该实体类的当前属性映射到数据表的主键列。 @GeneratedValue标注位置：与@Id注释配合使用； 主要作用：通过其strategy属性指定数据表主键的生成策略。默认情况下，JPA自动选择最适合底层数据库的主键生成策略，即SqlServer对应identity，而MySQL对应auto increment。 @Column标注位置：实体类的属性声明语句之前，或属性的getter()方法之前； 主要作用：标注实体类的当前属性映射到数据库表的字段名，当属性名与数据表字段名不一致时使用。 @Transient标注位置：实体类的属性声明语句之前，或属性的getter()方法之前； 主要作用：标注实体类的当前属性不进行数据表字段的映射，ORM框架将忽略此映射，如实体类的getInfo()方法通常不需要映射到数据表的字段上。 @Temporal标注位置：实体类的属性声明语句之前，或属性的getter()方法之前； 主要作用：标注实体类中Date类型（Java核心API中未定义Date类型的精度）的属性映射到数据表字段的具体精度（数据库中Date类型的数据有DATE、TIME和TIMESTAMP三种精度）。 基本CRUD操作Repository接口仅仅是一个标识，表明任何继承它的均为仓库接口类，方便Spring自动扫描识别。 CRUDRespository接口继承Repository，实现了一组CRUD相关的方法。 命名参数，索引参数 索引参数如下所示，索引值从1开始，查询中 ”?X” 个数需要与方法定义的参数个数相一致，并且顺序也要一致 @Modifying @Query(“update User u set u.firstname = ?1 where u.lastname = ?2”) int setFixedFirstnameFor(String firstname, String lastname); 命名参数（推荐使用这种方式）可以定义好参数名，赋值时采用@Param(“参数名”)，而不用管顺序。如下所示： public interface UserRepository extends JpaRepository&lt;User, Long&gt; { @Query(“select u from User u where u.firstname = :firstname or u.lastname = :lastname”) User findByLastnameOrFirstname(@Param(“lastname”) String lastname, ​ @Param(“firstname”) String firstname); } PagingAndSortRespository接口查询该接口继承了CrudRepository接口，提供了两个方法，实现了分页和排序的功能了 JpaRepository接口该接口继承了PagingAndSortingRepository接口。同时也继承QueryByExampleExecutor接口，这是个用“实例”进行查询的接口 事务在spring data jpa中的使用，@Modifying @Transactional的综合使用@Modifying表示是更新执行 @Transactional带事务 JpaSpecificationExecutor接口该接口提供了对JPA Criteria查询（动态查询）的支持。 spring data jpa 通过创建方法名来做查询，只能做简单的查询，那如果我们要做复杂一些的查询呢，多条件分页怎么办，这里，spring data jpa为我们提供了JpaSpecificationExecutor接口，只要简单实现toPredicate方法就可以实现复杂的查询 1.首先让我们的接口继承于JpaSpecificationExecutor 2.JpaSpecificationExecutor提供了以下接口 其中Specification就是需要我们传进去的参数，它是一个接口]]></content>
      <categories>
        <category>Spring Data</category>
      </categories>
      <tags>
        <tag>Spring Data JPA</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Zuul 过滤器]]></title>
    <url>%2Fblog%2Fspring-cloud-zuul-filters%2F</url>
    <content type="text"><![CDATA[Spring Cloud Zuul 除了可以实现请求的路由功能，还有一个重要的功能就是过滤器。Zuul 的路由功能让所有的微服务提供的接口有统一的网关入口，但并不是所有的接口都是对外完全开发的，它们的访问权限一般都有一定的限制。那我们可以在每个服务都加上对应的校验和权限鉴定，那这些通常都是用过滤器或拦截器实现的，而且一个系统的各个服务的校验也大都是相似，这些相似的校验逻辑打码在每个服务都会有一份，不仅冗余且维护麻烦。更好的办法就是在请求的最前端统一去做这样的事情，而统一的 API 服务网关入口就是合适的选择 Zuul 可以通过定义过滤器来实现请求的拦截和过滤，而它本身的大部分功能也是通过过滤器实现的 过滤器在 Zuul 中自定义过滤器需要继承抽象类 ZuulFilter，需要实现以下4个方法： 1234567String filterType()； // 过滤器类型int filterOrder()； // 执行顺序，数值越小优先级越高 boolean shouldFilter()； // 执行过滤器的条件Object run() throws ZuulException； // 具体的过滤操作 从名字我们也能知道各个方法的作用，下面来了解下过滤器类型和过滤器的生命周期，以及自定义过滤器的使用 过滤器类型和生命周期Zuul 定义了4种不同的过滤器类型，对应着请求的典型生命周期 PRE: 在请求被路由之前执行。可以用于请求身份验证、选择源服务器和记录调试信息 ROURING: 该过滤器将请求路由到服务。用于构建和发送给微服务的请求（使用 Apache HttpClient 或 Netflix Ribbon 请求服务） POST: 在请求被路由到服务之后执行。可以用于向响应添加标准的 HTTP Header、收集统计数据和指标，以及将响应从源服务发送到客户端 ERROR: 该过滤器在其他阶段发生错误时执行 除了默认的过滤器流，Zuul 还允许我们创建自定义过滤器类型并显式地执行它们。例如，我们可以自定义一个 STATIC 类型的过滤器，它在Zuul 中生成响应，而不是将请求转发到后端的服务 下面是 Zuul 的生命周期图，描述着各种类型的过滤器的执行顺序（图片来源于 Zuul Wiki） Spring Cloud Zuul 的过滤器Spring Cloud Zuul 作为服务网关的大部分功能都是通过过滤器实现的，它在请求的各个阶段实现了一系列的过滤器，在 Spring Cloud Zuul 网关服务启动时自动加载和启用。实现的这些过滤器是在 spring-cloud-netflix-zuul 模块中的 org.springframework.cloud.netflix.zuul.filters 包下面 下面介绍部分过滤器的功能 Pre filters filter order 说明 ServletDetectionFilter -3 检测请求是否通过 Spring 调度程序，即判断请求是交由 Spring DispatcherServlet 处理，还是 ZuulServlet 处理(主要是用于大文件上传) Servlet30WrapperFilter -2 把原始 HttpServletRequest 包装成 Servlet30RequestWrapper 对象 FormBodyWrapperFilter -1 解析表单数据并为下游服务重新编码 DebugFilter 1 如果设置 debug 请求参数，则此过滤器将RequestContext.setDebugRouting() 和 RequestContext.setDebugRequest() 设置为true PreDecorationFilter 5 根据提供的 RouteLocator 确定路由的位置和方式，它还为下游请求设置各种与代理相关的头文件 Route filters filter order 说明 RibbonRoutingFilter 10 使用 Ribbon、Hystrix 和 可插拔 HTTP客户机发送请求。只对 RequestContext 存在 serviceId 参数的请求进行处理，即只对通过 serviceId配置路由规则的请求路由。可以使用不同的 HTTP 客户端：HttpClient、OkHttpClient、Netflix Ribbon HTTP client SimpleHostRoutingFilter 100 通过 Apache HttpClient 发送请求到预定的 url，这些 url 可以在 RequestContext.getRouteHost() 中找到，即只对通过 url 配置路由规则的请求路由 SendForwardFilter 500 通过使用 Servlet RequestDispatcher 转发请求。用于转发请求到当前应用的端点 Post filters filter order 说明 LocationRewriteFilter 900 负责将 Location header 重写为 Zuul URL SendResponseFilter 1000 将代理请求的响应写入当前响应 Error filters filter order 说明 SendErrorFilter 0 利用请求上下文中的错误信息来组织成一个 forward 到 /error 错误端点的请求来产生错误响应 禁用过滤器 默认情况下，这些过滤器在代理和服务器模式下都是启用的。如果在某些场景下，禁用某个过滤器，可以设置 zuul.&lt;SimpleClassName&gt;.&lt;filterType&gt;.disable=true。例如，要禁用org.springframework.cloud.netflix.zuul.filter.post.sendresponsefilter，设置 zuul.SendResponseFilter.post.disable=true 自定义过滤器创建一个 Spring Boot 项目 zuul-filters，Zuul 的服务网关路由配置可以见 Spring Cloud Zuul 构建微服务网关 application.yml12345678910111213141516171819202122spring: application: name: zuul-filtersserver: port: 8090eureka: client: service-url: defaultZone: http://localhost:8761/eureka/zuul: ignoredServices: '*' routes: product: path: /product/** serviceId: product-servicemanagement: endpoints: web: exposure: include: '*' 自定义一个过滤器 AccessFilter，对请求中没有 accessToken 参数的请求，返回 401拒绝访问 AccessFilter.java123456789101112131415161718192021222324252627282930313233343536373839404142@Log4j2public class AccessFilter extends ZuulFilter &#123; @Override public int filterOrder() &#123; // run before PreDecoration return FilterConstants.PRE_DECORATION_FILTER_ORDER - 1; &#125; @Override public String filterType() &#123; return FilterConstants.PRE_TYPE; &#125; @Override public boolean shouldFilter() &#123; RequestContext ctx = RequestContext.getCurrentContext(); // a filter has already forwarded // a filter has already determined serviceId return !ctx.containsKey(FilterConstants.FORWARD_TO_KEY) &amp;&amp; !ctx.containsKey(FilterConstants.SERVICE_ID_KEY); &#125; @Override public Object run() &#123; RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info("send &#123;&#125; request to &#123;&#125;", request.getMethod(), request.getRequestURL().toString()); String token = request.getParameter("accessToken"); if(StringUtils.isBlank(token)) &#123; log.warn("access token is empty"); // 过滤该请求，不对其进行路由 ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); return null; &#125; log.info("access token ok"); return null; &#125;&#125; 实现自定义过滤器后，把它添加到 Spring 的 Beans 中 ZuulFiltersApplication.java12345678910111213@SpringBootApplication@EnableZuulProxypublic class ZuulFiltersApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulFiltersApplication.class, args); &#125; @Bean public AccessFilter accessFilter() &#123; return new AccessFilter(); &#125;&#125; 下面我们来测试下结果，启动项目 eureka-server、product-serivce(作为代理的服务)、zuul-filters 访问 http://localhost:8090/product/product/1 返回 401访问 http://localhost:8090/product/product/1?accessToken=111 会正常路由到 product-service 的 /product/1 参考代码见：demo 过滤器管理端点 @EnableZuulProxy 注解配合 Spring Boot Actuator，Zuul 会暴露额外的两个管理端点：Routes 和 Filters。分别是关于路由和过滤器的端点（服务路由的端点在这里介绍 Spring Cloud Zuul 构建微服务网关） spring-cloud-starter-netflix-zuul 已经依赖了 spring-boot-starter-actuator，所以上面的工程已经包含了路由管理的功能。关于过滤器的管理端点的路径为 /filters 访问路径 http://localhost:8090/actuator/filters 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&#123; "error": [ &#123; "class": "org.springframework.cloud.netflix.zuul.filters.post.SendErrorFilter", "order": 0, "disabled": false, "static": true &#125; ], "post": [ &#123; "class": "org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter", "order": 1000, "disabled": false, "static": true &#125; ], "pre": [ &#123; "class": "org.springframework.cloud.netflix.zuul.filters.pre.DebugFilter", "order": 1, "disabled": false, "static": true &#125;, &#123; "class": "org.springframework.cloud.netflix.zuul.filters.pre.FormBodyWrapperFilter", "order": -1, "disabled": false, "static": true &#125;, &#123; "class": "com.turbosnail.zuul.filter.AccessFilter", "order": 4, "disabled": false, "static": true &#125;, &#123; "class": "org.springframework.cloud.netflix.zuul.filters.pre.Servlet30WrapperFilter", "order": -2, "disabled": false, "static": true &#125;, &#123; "class": "org.springframework.cloud.netflix.zuul.filters.pre.ServletDetectionFilter", "order": -3, "disabled": false, "static": true &#125;, &#123; "class": "org.springframework.cloud.netflix.zuul.filters.pre.PreDecorationFilter", "order": 5, "disabled": false, "static": true &#125; ], "route": [ &#123; "class": "org.springframework.cloud.netflix.zuul.filters.route.SimpleHostRoutingFilter", "order": 100, "disabled": false, "static": true &#125;, &#123; "class": "org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter", "order": 10, "disabled": false, "static": true &#125;, &#123; "class": "org.springframework.cloud.netflix.zuul.filters.route.SendForwardFilter", "order": 500, "disabled": false, "static": true &#125; ]&#125; 访问404是因为没有暴露端点，可以设置 management.endpoints.web.exposure.include: ‘*’]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Zuul</tag>
        <tag>微服务</tag>
        <tag>服务网关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Zuul 构建微服务网关]]></title>
    <url>%2Fblog%2Fspring-cloud-zuul%2F</url>
    <content type="text"><![CDATA[为什么要有服务网关？在使用微服务架构时，一个客户端的业务需求可能会调用多个服务的接口，例如一次购物，需要调用商品服务，下单的时候要调用订单服务（服务划分更细的话还要调用更多的微服务）。客户端直接跟各个服务通信会有一些问题或者说弊端，客户端的调用会复杂，更重要的是会有跨域请求问题和复杂的权限控制认证 为了对外服务的安全性，不得不在原有的服务接口上做有关权限控制的校验逻辑，而这些权限相关的逻辑应该要把它从各个服务中抽离出来，作为外部调用和各个服务之间的负载均衡器。服务网关就是这样一个角色，对外统一 Rest API 接口，对内服务路由、负载均衡，同时还提供身份认证安全和监控功能 ZuulZuul 是 Netflix 开源的服务网关，它的核心就是一系类的过滤器，通过一系列的过滤器在请求的各个阶段进行处理，具体的路由器功能见 Spring Cloud Zuul 过滤器 准备这里使用 Eureka Server 作为服务注册中心 eureka-server/.../application.yml12345678910111213spring: application: name: eureka-serverserver: port: 8761eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 另外准备一个服务 product-service product-service/.../application.yml123456789spring: application: name: product-serviceserver: port: 8071eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 构建 Zuul 微服务网关创建 Spring Boot 工程命名为 zuul-gateway 作为服务网关，添加如下依赖 pom.xml12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 在主类上添加注解 @EnableZuulProxy 开启 Zuul 代理，这个代理会使用 Ribbon 获取注册服务的实例，同时还整合了 Hystrix 实现容错，所有请求都会在 Hystrix 命令中执行。 GatewayZuulApplication.java12345678@SpringBootApplication@EnableZuulProxypublic class GatewayZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayZuulApplication.class, args); &#125;&#125; EnableZuulProxy.java123456@EnableCircuitBreaker@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Import(ZuulProxyMarkerConfiguration.class)public @interface EnableZuulProxy &#123;&#125; 配置信息，添加 eureka 注册中心的地址 application.yml123456789spring: application: name: gateway-zuulserver: port: 8090eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 到这里一个简单的服务网关就完成了，只是简单吧把网关服务注册到 Eureka，Spring Cloud Zuul 整合了 Eureka，会提供默认的服务路由功能，默认情况下，Zuul 会代理所有注册到 Eureka Server 上的微服务 gateway-zuul 的请求 /{serviceId}/** 会转发到对应注册在 Eureka Server 上对应 serviceId 的服务 /** 上启动 eureka-server、product-service、zuul-gateway，然后访问 http://localhost:8090/product-service/product/1 ，该请求会被转发到 product-service 的 /product/1 另外想要跳过一些服务可以设置 zuul.ignoredServices，要获得对路由的更细粒度控制，可以单独指定路径和 serviceId application.yml123456zuul: ignoredServices: '*' routes: product: path: /product/** serviceId: product-service 上面设置的是除 product 服务之外的服务都忽略，而访问 product-service 服务的路径为 /product/** 参考代码见：demo Zuul 路由端点 @EnableZuulProxy 注解配合 Spring Boot Actuator，Zuul 会暴露额外的两个管理端点：Routes 和 Filters。分别是关于路由和过滤器的端点（过滤器的端点在这里介绍 Spring Cloud Zuul 过滤器） spring-cloud-starter-netflix-zuul 已经依赖了 spring-boot-starter-actuator，所以上面的工程已经包含了路由管理的功能。关于路由端点的路径为 /routes 和 /routes/details 访问路径 http://localhost:8090/actuator/routes 123&#123; "/product/**": "product-service"&#125; 访问路径 http://localhost:8090/actuator/routes/details，可以查看路由的详细信息 123456789101112&#123; "/product/**": &#123; "id": "product", "fullPath": "/product/**", "location": "product-service", "path": "/**", "prefix": "/product", "retryable": false, "customSensitiveHeaders": false, "prefixStripped": true &#125;&#125; 访问404是因为没有暴露端点，可以设置 management.endpoints.web.exposure.include: ‘*’ 路由配置默认情况下，Zuul 网关会代理所有注册到 Eureka Server 上的服务，但我们可以通过配置来让其只代理其中一部分的服务或者是自己控制 URL。Zuul 的路由配置非常的灵活 自定义访问路径。zuul.routes.{serviceId}={costomUrl} 123zuul: routes: product-service: /product/** 忽略指定服务，多个用逗号隔开，忽略全部用 * 12zuul: ignored-services: product-service1,product-service2 12345zuul: ignored-services: '*' routes: product-service: /product/**# 忽略所有服务，只路由 product-service 同时指定微服务的 serviceId 和对应路径 123456zuul: ignoredServices: '*' routes: product: # 只是一个路由名称 service-id: product-service path: /product/** 同时指定地址和访问路径 123456zuul: ignoredServices: '*' routes: product: url: http://localhost:8081/ path: /product/** 添加路由前缀 123456zuul: perfix: /api strip-perfix: false routes: product-service: /product/**# /api/product/** -&gt; /api/** 12345zuul: routes: product-service: /product/** strip-perfix: false# /product/** -&gt; /product/** 忽略某些路径 1234zuul: ignoredPatterns: /**/admin/** #忽略所有包含 /admin/ 的路径 routes: product-service: /product/** Zuul 的容错和回退在 Spring Cloud 中，Zuul 已经默认整合了 Hystrix，关于 Hystrix 介绍和监控面板可以见 Spring Cloud 断路器 Hystrix。我们使用上面的例子 启动 eureka-server、product-service、zuul-gateway 然后访问 http://localhost:8090/product/product/1 访问 http://localhost:8090/actuator/hystrix.stream，可以获得 Hystrix 监控数据 在 hystrix-dashboard 面板中输入地址 http://localhost:8090/actuator/hystrix.stream，可以看到如下信息 由上图可以看出，Zuul 的 Hystrix 监控粒度为服务，而不是接口。 接下来我们可以关闭服务 product-service，然后再访问接口 http://localhost:8090/product/product/1 为 Zuul 添加回退 为 Zuul 添加回退，需要实现 FallbackProvider 接口，需要指定回退用于的路由ID，并提供一个 ClientHttpResponse 作为回退返回 ProductFallbackProvider.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ProductFallbackProvider implements FallbackProvider &#123; @Override public String getRoute() &#123; return "product-service"; &#125; @Override public ClientHttpResponse fallbackResponse(String route, final Throwable cause) &#123; if (cause instanceof HystrixTimeoutException) &#123; return response(HttpStatus.GATEWAY_TIMEOUT); &#125; else &#123; return response(HttpStatus.INTERNAL_SERVER_ERROR); &#125; &#125; private ClientHttpResponse response(final HttpStatus status) &#123; return new ClientHttpResponse() &#123; @Override public HttpStatus getStatusCode() throws IOException &#123; return status; &#125; @Override public int getRawStatusCode() throws IOException &#123; return status.value(); &#125; @Override public String getStatusText() throws IOException &#123; return status.getReasonPhrase(); &#125; @Override public void close() &#123; &#125; @Override public InputStream getBody() throws IOException &#123; return new ByteArrayInputStream("fallback".getBytes()); &#125; @Override public HttpHeaders getHeaders() &#123; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); return headers; &#125; &#125;; &#125;&#125; 如果您想为所有路由提供默认的回退，您可以创建一个类型为 FallbackProvider 的bean，并让 getRoute 方法返回 * 或 null 重启服务网关，访问接口 http://localhost:8090/product/product/1]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Zuul</tag>
        <tag>微服务</tag>
        <tag>服务网关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud 断路器 Hystrix]]></title>
    <url>%2Fblog%2Fspring-cloud-hystrix%2F</url>
    <content type="text"><![CDATA[在微服务架构中，通常存在多个服务调用层。微服务之间通过网络进行通信，从而支撑起整个应用，为了保证高可用，单个服务通常也会集群部署。但由于网络原因或者自身原因，每个服务并不能保证100% 可用。而服务间的依赖关系，会导致故障传播，即服务提供者的不可用会导致消费者不可用，并把不可用逐渐放大，这就是雪崩效应。 这里就引入了请求超时机制和断路器模式 Hystrix 简介Hystrix 是 Netflix 的开源组件，是一个用于实现超时机制和断路器模式的工具类库。在微服务架构中，通常存在多个服务调用层。较低级别的服务中的服务故障可能导致级联故障，一直到达用户。当对特定服务的调用超过一个阈值（默认是 10秒/20个请求/故障百分比 &gt; 50％），断路器将打开并且不会进行调用。在出现错误和开路的情况下，开发人员可以提供一个回退 断路打开后可以防止级联故障。回退可以是另一个受 Hystrix 保护的调用、静态数据或合理的空值。 Ribbon 中整合 Hystrix我们在 Spring Cloud 服务消费（Ribbon） 中的例子基础上添加 Hystrix 准备工作 eureka-server 作为服务注册中心 product-service 作为服务提供者 复制工程 order-service-ribbon 为 order-service-ribbon-hystrix 来整合 Hystrix 代码参考：https://github.com/morgan412/spring-cloud-demo/tree/master/netflix 添加 Hystrix 依赖 pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 主类上添加注解 @EnableCircuitBreaker ，开启断路器功能 OrderServiceRibbonHystrixApplication.java123456789101112131415@SpringBootApplication@EnableDiscoveryClient@EnableCircuitBreakerpublic class OrderServiceRibbonHystrixApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderServiceRibbonHystrixApplication.class, args); &#125; @LoadBalanced @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 在需要容错的方法上添加注解 @HystrixCommand，并指定回调(回退)方法 ProductService.java1234567891011121314151617@Servicepublic class ProductService &#123; @Autowired private RestTemplate restTemplate; @HystrixCommand(fallbackMethod = "getProductFallBack") public Product getProduct(Long id) &#123; return restTemplate.getForObject("http://product-service/product/" + id, Product.class); &#125; public Product getProductFallBack(Long id) &#123; Product product = new Product(); product.setId(-1L); product.setName("默认商品"); return product; &#125;&#125; @HystrixCommand 的配置可以比较灵活，可以使用 commandProperties 属性列出 @HystrixProperty注释，例如 123456789&gt; @HystrixCommand(fallbackMethod = "getProductFallBack",&gt; commandProperties = &#123;&gt; @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "5000"),&gt; @HystrixProperty(name = "metrics.rollingStats.timeInMilliseconds", value = "10000")&#125;,&gt; threadPoolProperties = &#123;&gt; @HystrixProperty(name = "coreSize", value = "1"),&gt; @HystrixProperty(name = "maxQueueSize", value = "10")&gt; &#125;)&gt; ProductController.java123456789101112@RestController@Log4j2public class ProductController &#123; @Autowired private ProductService productService; @GetMapping("/product/&#123;id&#125;") public Product getProduct(@PathVariable Long id) &#123; return productService.getProduct(id); &#125;&#125; 验证结果 启动项目 eureka-server、product-service、order-service-ribbon-hystrix 访问 http://localhost:8081/product/1 ，得到正常结果 关闭 product-service 服务，再访问 http://localhost:8081/product/1 ，得到结果 {&quot;id&quot;:-1,&quot;name&quot;:&quot;默认商品&quot;,&quot;description&quot;:null,&quot;price&quot;:null,&quot;count&quot;:null}。说明当调用的服务不可用时，执行了回退方法 Feign 使用 HystrixFeign 使用声明式的接口，没有方法体，所以通过注解的方式显然不适合 Feign。Spring Cloud 已经默认为 Feign 整合了 Hystrix。我们在 Spring Cloud 服务消费（Feign） 中的例子基础上使用 Hystrix 准备工作 eureka-server 作为服务注册中心 product-service 作为服务提供者 复制工程 order-service-feign 为 order-service-feign-hystrix 来使用 Hystrix 为 Feign 添加回退Spring Cloud 已经默认为 Feign 整合了 Hystrix，所以我们不需要添加依赖。配置文件中需要把 feign.hystrix.enabled 属性设置为 true application.yml123feign: hystrix: enabled: true 改写 Feign 客户端接口，在 @FeignClient 注解中通过 fallback 属性指定回调类 ProductFeignClient.java123456@FeignClient(value = "product-service", fallback = ProductFeignClientFallback.class)public interface ProductFeignClient &#123; @GetMapping("/product/&#123;id&#125;") Product getProduct(@PathVariable Long id);&#125; 创建回调类，这个类需要实现 @FeignClient 的接口，其中实现的方法就是对应接口的回退方法 ProductFeignClientFallback.java12345678910@Componentpublic class ProductFeignClientFallback implements ProductFeignClient &#123; @Override public Product getProduct(Long id) &#123; Product product = new Product(); product.setId(-1L); product.setName("默认商品"); return product; &#125;&#125; ProductController.java123456789101112@RestController@Log4j2public class ProductController &#123; @Autowired private ProductFeignClient productFeignClient; @GetMapping("/product/&#123;id&#125;") public Product getProduct(@PathVariable Long id) &#123; return productFeignClient.getProduct(id); &#125;&#125; 验证结果 启动项目 eureka-server、product-service、order-service-feign-hystrix 访问 http://localhost:8081/product/1 ，得到正常结果 关闭 product-service 服务，再访问 http://localhost:8081/product/1 ，得到结果 {&quot;id&quot;:-1,&quot;name&quot;:&quot;默认商品&quot;,&quot;description&quot;:null,&quot;price&quot;:null,&quot;count&quot;:null}。说明当调用的服务不可用时，执行了回退方法 通过 fallbackFactory 检查回退原因如果需要查看回退原因，可以使用注解 @FeignClient 中的 fallbackFactory 属性 ProductFeignClient.java123456@FeignClient(value = "product-service", fallbackFactory = ProductClientFallbackFactoty.class)public interface ProductFeignClient &#123; @GetMapping("/product/&#123;id&#125;") Product getProduct(@PathVariable Long id);&#125; 同时创建 ProductClientFallbackFactoty 类，实现 FallbackFactory 接口，create 方法有个 Throwable 参数记录回退原因 ProductClientFallbackFactoty.java12345678910111213141516171819@Component@Log4j2public class ProductClientFallbackFactoty implements FallbackFactory&lt;ProductFeignClient&gt; &#123; @Override public ProductFeignClient create(Throwable throwable) &#123; return new ProductFeignClient() &#123; @Override public Product getProduct(Long id) &#123; // 日志最好放在各个 fallback 方法中，而不要直接放在 create 方法中 // 否则在引用启动时会打印该日志 log.info("fallback, caused by:", throwable); Product product = new Product(); product.setId(-1L); product.setName("默认商品"); return product; &#125; &#125;; &#125;&#125; 测试一下结果，当调用的服务不可用时，会进入回调方法中，并打印如下日志 122019-05-06 14:21:20.384 INFO 8056 --- [ HystrixTimer-1] c.t.o.c.ProductClientFallbackFactoty : fallback, caused by:com.netflix.hystrix.exception.HystrixTimeoutException: null Hystrix 监控Hystrix 还提供了一些监控，当 HystrixCommand 和 HystrixObservableCommand 在执行时会产生会产生执行的结果和运行指标。可以配合 spring-boot-starter-actuator 模块同时设置 management.endpoints.web.exposure.include: hystrix.stream，通过 /actuator/hystrix.stream 端点来获取指标信息 pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; application.yml12345management: endpoints: web: exposure: include: hystrix.stream 当有 HystrixCommand 方法被执行，访问 /actuator/hystrix.stream 可以重复看到一些信息 Feign 项目需要添加依赖 spring-cloud-starter-netflix-hystrix，并在主类上加上注解 @EnableCircuitBreaker，才能使用 /actuator/hystrix.stream 端点 Hystrix Dashboard 监控面板使用 Hystrix Dashboard 可以让上面的监控数据可视化，新建一个 Spring Boot 工程 hystrix-dashboard，添加依赖 spring-cloud-starter-netflix-hystrix-dashboard hystrix-dashboard/pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; 然后在主类上添加注解 @EnableHystrixDashboard HystrixDashboardApplication.java12345678@SpringBootApplication@EnableHystrixDashboardpublic class HystrixDashboardApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HystrixDashboardApplication.class, args); &#125;&#125; 设置服务端口 server.port=8000，启动 hystrix-dashboard，访问 http://localhost:8000/hystrix 可以看到以下界面 从上面的界面我们可以看到，Hystrix Dashboard 面板监控支持三种方式：默认的集群监控、自定义的集群监控、单个应用的监控。其中前两个集群的方式是需要结合 Turbine 实现，后面去用到。另外 Delay 是轮询监控信息的延迟时间，Title 是监控界面标题，默认是监控实例的 URL 默认的集群监控:http://turbine-hostname:port/turbine.stream 自定义的集群监控: http://turbine-hostname:port/turbine.stream?cluster=[clusterName] 单个应用监控: http://hystrix-app:port/actuator/hystrix.stream 那我们把上面例子的 order-service-ribbon-hystrix 服务添加 hystrix 监控相关的端点，pom.xml 添加依赖 spring-boot-starter-actuator，设置配置属性 management.endpoints.web.exposure.include=hystrix.stream，同时确保在主类上已经使用注解@EnableCircuitBreaker 或 @EnableHystrix 完成配置后，启动项目，把地址 http://localhost:8081/actuator/hystrix.stream 添加到面板页面，可以看到以下界面 上面展示了 getProduct 这个 HystrixCommand 的各项指标，各指标含义可以看下图 Turbine 聚合监控数据Turbine 是聚合 Hystrix 监控数据的工具，上面的 Dashboard 面板可以可视化一个 /actuator/hystrix.stream 端点的数据，但是对于多个服务和并且每个服务有多个实例，来回的切换想要监控实例的地址就会很不方便。我们需要一个把所有服务的 /actuator/hystrix.stream 端点数据整合起来的工具，这个工具就是 Turbine 创建一个 Spring Boot 项目命名为 hystrix-turbine，部分的依赖入如下，该依赖默认包含了 Eureka Client pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-turbine&lt;/artifactId&gt;&lt;/dependency&gt; 主类上添加注解 @EnableTurbine，该注解的配置中已经配置了服务注册的功能，即相当于包含了 @EnableDiscoveryClient 的功能 HystrixTurbineApplication.java12345678@SpringBootApplication@EnableTurbinepublic class HystrixTurbineApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HystrixTurbineApplication.class, args); &#125;&#125; 配置信息如下 application.yml1234567891011121314server: port: 8001spring: application: name: hystrix-turbineeureka: client: service-url: defaultZone: http://localhost:8761/eureka/ turbine: app-config: order-service-ribbon-hystrix,order-service-feign-hystrix cluster-name-expression: "'default'" combine-host-port: true turbine.app-config 配置用于查找实例的服务名turbine.cluster-name-expression 指定集群名称，服务数量很的多时候，可以启动多个 Turbine 服务聚合不同的集群数据，而该参数可以用来区分不同的聚合turbine.combine-host-port 通过主机名与端口号的组合来进行区分服务 我们分别启动项目 eureka-server:8761、product-service:8071、order-service-ribbon-hystrix:8089、order-service-feign-hystrix:8081 我们可以先测试下 http://localhost:8081/actuator/hystrix.stream 和 http://localhost:8089/actuator/hystrix.stream 的端口有无问题，没有问题我们启动 hystrix-dashboard，在页面输入 http://localhost:8001/turbine.stream 得到的界面如下]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>Feign</tag>
        <tag>Ribbon</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud 服务消费（Feign）]]></title>
    <url>%2Fblog%2Fspring-cloud-consumer-feign%2F</url>
    <content type="text"><![CDATA[在使用 RestTemplate 实现 Rest API 调用的时候，是通过拼接字符串的方式构造 URL，向具体服务实例发起 Http 请求。在定义 RestTemplate 的时候，还可以增加 @LoadBalanced 注解，在调用服务接口的时候，原来 host 部分是通过手动拼接ip和端口的，现在直接用 服务名 来写请求路径。在真正调用的时候，Spring Cloud 会将请求拦截下来，然后通过负载均衡器（如 Ribbon）选出节点，并替换服务名部分为具体的ip和端口，从而实现基于服务名的负载均衡调用，相关见 Spring Cloud 服务消费（Ribbon） 以上的方式可以实现负载均衡调用，但是由于每个调用都要拼接 URL，传递的参数也需要放在 URL 中，这样的开发体验是很不好的，比较低效且难以维护。可以使用 Feign 实现声明式 REST 调用 Feign 简介Feign 是 Netflix 的一套的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它即可。它具备可插拔的注解支持，包括Feign注解和JAX-RS注解。支持可插拔编码器和解码器。Spring Cloud 对 Feign 进行了增强，扩展了对Spring MVC 注解的支持，并整合了 Ribbon 和 Eureka 来提供均衡负载的 HTTP 客户端实现。 使用 Feign我们利用之前的例子（见 Spring Cloud 服务消费（Ribbon）），eureka-server 作为服务注册中心、product-service 作为服务提供者，order-service-ribbon 是服务消费者。复制 order-service-ribbon 为 order-service-feign，在 order-service-feign 上去做一些更改 添加 Feign 的依赖 pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 修改启动类，添加 @EnableFeignClients 注解 OrderServiceFeignApplication.java123456789@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class OrderServiceFeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderServiceFeignApplication.class, args); &#125;&#125; 创建 Feign 接口，添加 @FeignClient 注解 ProductFeignClient123456@FeignClient("product-service")public interface ProductFeignClient &#123; @GetMapping("/product/&#123;id&#125;") Product getProduct(@PathVariable Long id);&#125; 调用 Feign 接口 ProductController.java123456789101112@RestController@Log4j2public class ProductController &#123; @Autowired private ProductFeignClient productFeignClient; @GetMapping("/product/&#123;id&#125;") public Product getProduct(@PathVariable Long id) &#123; return productFeignClient.getProduct(id); &#125;&#125; 启动 eureka-server、product-service:8071、product-service:8072、order-service-feign，访问 http://localhost:8081/product/1 可以查看结果 示例代码：demo]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>Eureka</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud 服务消费（Ribbon）]]></title>
    <url>%2Fblog%2Fspring-cloud-consumer-ribbon%2F</url>
    <content type="text"><![CDATA[之前介绍了使用 Eureka 作为服务发现组件，构建了 Eureka Server 作为服务注册中心，使用 Eureka Client 去注册服务 Spring Cloud 服务注册与发现、高可用（Eureka），那服务间又是怎样相互调用的呢？这里介绍使用 Ribbon 实现负载均衡 准备构建一个 Eureka Server 服务注册中心 eureka-server 和两个注册服务 product-service (用来提供服务) 和 order-service-ribbon (消费服务者) 参考，这里我们启动两个 product-service 实例 这里分别给出配置信息 eureka-server/.../application.yml12345678910111213spring: application: name: eureka-serverserver: port: 8761eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 我们启动两个 product-service 服务实例，在 idea 中的 Edit Configurations 中复制一个 product-service 改变端口为 8072 product-service/.../application.yml123456789spring: application: name: product-serviceserver: port: 8071eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ order-service-ribbon 需要添加 Ribbon 的依赖，如下： order-service-ribbon/.../application.yml123456789spring: application: name: order-service-ribbonserver: port: 8081eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ order-service-ribbon/pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 启动服务注册中心 eureka-server 和两个注册服务，打开 http://localhost:8761/eureka/ 查看服务注册情况 Ribbon 实现负载均衡实际生产中，基本上每个服务都会部署多个实例，那么服务消费者的请求该怎么分配到多个服务提供者实例上呢？ Ribbon 简介Ribbon 是 Netflix 发布的负载均衡器，是在客户端实现负载均衡，对客户端的HTTP和TCP行为有很好的控制。它可以在客户端为其配置服务提供者地址列表 ribbonServerList，然后基于某种负载均衡算法（轮询、随机等），自动帮助客户端去请求 当 Eureka 与 Ribbon 结合使用时，ribbonServerList 将被扩展为DiscoveryEnabledNIWSServerList，扩展为 Eureka 的服务器注册实例列表。同时还会用 NIWSDiscoveryPing 替换 IPing 接口，让 Eureka 来确定服务端是否启动 RestTemplate 作为负载均衡客户端RestTemplate 可以自动配置为使用 ribbon，要创建一个负载均衡的 RestTemplate，需要加上注解 @LoadBalanced OrderServiceRibbonApplication.java1234567891011121314@SpringBootApplication@EnableDiscoveryClientpublic class OrderServiceRibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderServiceRibbonApplication.class, args); &#125; @LoadBalanced @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 创建一个 Controller 来测试请求 ProductController.java1234567891011@RestControllerpublic class ProductController &#123; @Autowired private RestTemplate restTemplate; @GetMapping("/product/&#123;id&#125;") public Product getProduct(@PathVariable Long id)&#123; return restTemplate.getForObject("http://product-service/product/" + id, Product.class); &#125;&#125; 重新启动服务，访问路径 http://localhost:8081/product/1 得到如下结果 1&#123;"id":1,"name":"秋裤","descriptionl":"花秋裤","price":9.9,"count":99&#125; 有上面的代码我们可以看到请求的地址为 http://product-service/product/1，其中的 product-service 就是我们要请求的服务的虚拟主机名，Ribbon 会自动把这个虚拟主机名映射成要请求的服务网络地址 LoadBalancerClientLoadBalancerClient 是 Spring Cloud Commons 中提供的一个抽象接口，可以使用它来调用 Ribbon API ProductController.java12345678910111213141516171819202122@RestController@Log4j2public class ProductController &#123; @Autowired private RestTemplate restTemplate; @Autowired private LoadBalancerClient loadBalancerClient; @GetMapping("/product/&#123;id&#125;") public Product getProduct(@PathVariable Long id)&#123; return restTemplate.getForObject("http://product-service/product/" + id, Product.class); &#125; @GetMapping("/product/log/&#123;id&#125;") public void logProduct(@PathVariable Long id)&#123; ServiceInstance serviceInstance = loadBalancerClient.choose("product-service"); // URI storesUri = URI.create(String.format("https://%s:%s/"+ id, serviceInstance.getHost(), serviceInstance.getPort())); log.info("&#123;&#125;:&#123;&#125;:&#123;&#125;", serviceInstance.getHost(), serviceInstance.getPort()); &#125;&#125; 现在我们重新启动服务，访问 http://localhost:8081/product/log/1 ，上面代码可以看到我们会打印查询日志，会记录下请求服务的实例id、主机名、端口，多次访问上面的地址 1234562019-04-30 09:19:01.437 INFO 22024 --- [nio-8081-exec-3] c.t.order.controller.ProductController : DESKTOP-G11TC44.mshome.net:80712019-04-30 09:19:01.687 INFO 22024 --- [nio-8081-exec-4] c.t.order.controller.ProductController : DESKTOP-G11TC44.mshome.net:80722019-04-30 09:19:01.843 INFO 22024 --- [nio-8081-exec-5] c.t.order.controller.ProductController : DESKTOP-G11TC44.mshome.net:80712019-04-30 09:19:01.984 INFO 22024 --- [nio-8081-exec-6] c.t.order.controller.ProductController : DESKTOP-G11TC44.mshome.net:80722019-04-30 09:19:02.140 INFO 22024 --- [nio-8081-exec-7] c.t.order.controller.ProductController : DESKTOP-G11TC44.mshome.net:80712019-04-30 09:19:02.297 INFO 22024 --- [nio-8081-exec-8] c.t.order.controller.ProductController : DESKTOP-G11TC44.mshome.net:8072 可以看到请求的各个服务节点依次交替，说明已经实现负载均衡 restTemplate.getForObject() 不能和 loadBalancerClient.choose() 同时使用，因为注释了 @LoadBalanced 的 restTemplate 实际上就是一个 Ribbon 客户端，包含了 choose 的功能 自定义 Ribbon 客户端在某些场景下，可能会需要自定义 Ribbon 的配置，如修改 Ribbon 的负载均衡规则。可以使用 @RibbonClient 声明自定义的配置，或者使用 &lt;clientName&gt;.Ribbon.* 中的外部属性配置 Ribbon 客户端 代码自定义 Ribbon 客户端默认情况下，Ribbon 客户端已经实现了以下的 bean （BeanType beanName：ClassName） IClientConfig ribbonClientConfig: DefaultClientConfigImpl IRule ribbonRule: ZoneAvoidanceRule IPing ribbonPing: DummyPing ServerList&lt;Server&gt; ribbonServerList: ConfigurationBasedServerList ServerListFilter&lt;Server&gt; ribbonServerListFilter: ZonePreferenceServerListFilter ILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer ServerListUpdater ribbonServerListUpdater: PollingServerListUpdater 可通过自定义配置覆盖默认配置 RibbonConfiguration.java1234567891011121314@Configurationpublic class RibbonConfiguration &#123; @Bean public IPing ribbonPing() &#123; return new PingUrl(); &#125; @Bean public IRule ribbonRule() &#123; // 负载均衡规则：随机 return new RandomRule(); &#125;&#125; TestConfiguration.java1234@Configuration@RibbonClient(name = "product-service", configuration = RibbonConfiguration.class)public class TestConfiguration &#123;&#125; 这种配置是细粒度的，不同的 Ribbon 客户端可以使用不同的配置，使用 @RibbonClient 的 configuration 属性，就可以自定义 指定名称的 Ribbon 客户端的配置 这里的 RibbonConfiguration 类不能包含在主应用程序的上下文中的 @ComponentScan 中，否则该类的配置会被所有的 @RibbonClient 共享。因此只想自定义某一个 Ribbon 客户端的配置，必须防止 @Configuration 的注解的类所在包和 @ComponentScan 扫描的包重合，或显示指定 @ComponentScan 不扫描 @Configuration 类所在包 为所有Ribbon客户端自定义默认值通过使用 @RibbonClients 注释并注册一个默认配置，可以为所有 Ribbon 客户端提供一个默认配置 RibbonClientDefaultConfigurationTestsConfig.java12345678910111213141516171819202122232425262728293031323334353637@RibbonClients(defaultConfiguration = DefaultRibbonConfig.class)public class RibbonClientDefaultConfigurationTestsConfig &#123; public static class BazServiceList extends ConfigurationBasedServerList &#123; public BazServiceList(IClientConfig config) &#123; super.initWithNiwsConfig(config); &#125; &#125;&#125;@Configurationclass DefaultRibbonConfig &#123; @Bean public IRule ribbonRule() &#123; return new BestAvailableRule(); &#125; @Bean public IPing ribbonPing() &#123; return new PingUrl(); &#125; @Bean public ServerList&lt;Server&gt; ribbonServerList(IClientConfig config) &#123; return new RibbonClientDefaultConfigurationTestsConfig.BazServiceList(config); &#125; @Bean public ServerListSubsetFilter serverListFilter() &#123; ServerListSubsetFilter filter = new ServerListSubsetFilter(); return filter; &#125;&#125; 属性自定义 Ribbon 客户端使用属性自定义 Ribbon 客户端会比代码自定义更加方便。属性配置的前缀为 &lt;clientName&gt;.Ribbon.* NFLoadBalancerClassName: 实现 ILoadBalancer NFLoadBalancerRuleClassName: 实现 IRule NFLoadBalancerPingClassName: 实现 IPing NIWSServerListClassName: 实现 ServerList NIWSServerListFilterClassName: 实现 ServerListFilter 这些属性中定义的类优先于使用 @RibbonClient(configuration=MyRibbonConfig.class) 定义的 bean 和Spring Cloud Netflix 提供的默认值定义的 bean。 application.yml1234product-service: ribbon: NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule 参考代码：demo]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>Eureka</tag>
        <tag>Ribbon</tag>
        <tag>RestTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Config 统一配置中心]]></title>
    <url>%2Fblog%2Fspring-cloud-config%2F</url>
    <content type="text"><![CDATA[Spring Cloud Config 统一配置中心 统一配置中心统一管理配置通常，我们会使用配置文件来管理应用的配置。如一个 Spring Boot 的应用，可以将配置信息放在 application.yml 文件中，如果需要多环境配置，可以设置多个 application-{profile}.yml，再通过 spring.profiles.active={profile} 来实现多环境的切换。这样的管理对于单体应用或者说划分的服务不多的情况下没什么问题，但如果是一个微服务架构的应用系统有着很多个微服务，集中管理配置就非常必要了 对于这样的配置管理，我们会希望它有以下 集中化管理配置 多环境多配置 可动态调整并自动更新 Spring Cloud Config 配置中心Spring Cloud Config 为分布式系统外部化配置提供了服务器端和客户端的支持，分为 Config Server 和 Config Client Config Server 是用来集中管理应用程序的各个环境下的配置，默认是使用 Git 来存储配置内容的，可以很方便的对配置实现版本管理（也支持 Subversion 和本地化文件系统存储）Config Client 即用来获取 Config Server 中存储的配置内容 使用创建 Config Server创建一个 Spring Boot 工程，maven 添加 spring-cloud-config-server pom.xm12345678910111213141516171819202122232425262728293031&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在程序启动类上添加注解 @EnableConfigServer ，开启配置服务器的功能 12345678@SpringBootApplication@EnableConfigServerpublic class ConfigServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigServerApplication.class, args); &#125;&#125; Config Server 默认是使用 Git 来存储配置内容的，下面来配置下 git 仓库的相关信息 application.yml123456789101112131415161718server: port: 8888spring: application: name: config-server cloud: config: server: git: # git 仓库地址 uri: https://github.com/Morgan412/weixin-order # 仓库下的搜索路径 search-paths: conf # git仓库账号 username: # git仓库密码 password: 如果是公开仓库可以不用账号和密码，在仓库的 conf/ 目录下建立如下的配置文件 product.yml product-dev.yml product-pro.yml 每个文件中分别填入如下配置内容 profile: default profile: dev profile: pro Config Server 的端点 使用 Config Server 的端点可以获取配置文件的内容，请求地址与配置文件的映射如下： /{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties 上面的地址都可以映射到 {application}-{profile}.properties/yml 配置文件，{label} 表示对应 Git 仓库的分支，默认是 master 启动上面的 config-server 项目，通过 url 访问远程 Git 仓库 master 分支下 conf 目录下的 product-dev.yml 配置文件内容。通过 http://localhost:8888/product/dev 访问，可以获得应用名称、profile、git label、git version、配置文件URL、配置内容等信息 1234567891011121314151617181920212223&#123; "name": "product", "profiles": [ "dev" ], "label": null, "version": "052661b72043aad390e6774666b5594d6e0ba116", "state": null, "propertySources": [ &#123; "name": "https://github.com/Morgan412/weixin-order/conf/product-dev.yml", "source": &#123; "profile": "dev" &#125; &#125;, &#123; "name": "https://github.com/Morgan412/weixin-order/conf/product.yml", "source": &#123; "profile": "default" &#125; &#125; ]&#125; 而 http://localhost:8888/product-dev.yml 和 http://localhost:8888/product-dev.properties 只会获取到配置文件中的属性，包括 {application}.yml/properties 中的属性 配置 Config Client上面创建了一个 Config Server 来集中管理配置，那下面来配置 Config Client 让微服务获取配置信息。同样是创建一个 Spring Boot 工程，添加 Config Client 的依赖，这里省略了其他依赖 pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt; 相关配置如下 bootstrap.yml1234567891011121314server: port: 8082spring: application: # 对应 config server 所获取的配置文件 &#123;application&#125; name: product cloud: config: # 指定 config server 的地址，默认是 http://localhost:8888 uri: http://localhost:8888 # 对应配置文件的 &#123;profile&#125; profile: dev # 分支 label: master 上面的配置可以从 /{application}/{profile}/{label} 获取对应 Config Server 中的配置文件中的属性，其中 application 对应 ${spring.application.name} profile 对应 ${spring.profiles.active} (实际就是 Environment.getActiveProfiles()) label 是存储仓库的分支，默认是 master 另外这些都可以通过设置 spring.cloud.config.* (* 为 name、profile、label) 来覆盖。如果这时就启动该服务，就可能会出现一些问题，因为上面关于 Config Client 的配置需要放到 bootstrap.yml 而不是 application.yml。 这里我们来想一个问题，我们交给 Config Server 集中管理的配置内容原本是应该放在 application.yml 中在程序启动的时候被加载的，而现在我们把去获取配置内容的 Config Client 的相关配置放在了 application.yml 中，这样是不是就有点不对了？因为这里会出现一个先后顺序的问题，关于 Config Client 的配置应该先于其他被管理的配置内容先被加载才对 如果我们把配置放在了 application.yml 中，那么它会先去加载 bootstrap.yml 的配置属性(如果没有，会加载默认配置)，假如我们在 application.yml 中配置的 uri 端口是 8080，那么它将不会被应用，还是默认的 8888 端口 Spring Cloud 有一个 引导上下文 的概念，它是主应用程序的父上下文，这个引导上下文负责从外部源（配置服务器，如 Config Server）加载配置属性，及解密外部配置文件中的属性。 主应用程序加载的是 application.*(properties/yml) 中的属性，引导上下文加载 bootstrap.*(properties/yml) 中的属性。这两个上下文共享一个Environment，但配置在 boostrap.* 中的属性有更高的优先级，因此默认情况下不能被本地配置覆盖。 设置 spring.cloud.bootstrap.enabled=false 可以禁用引导过程 在 bootstrap.yml 配置好 Config Client 后，可以来写个 Controller 来测试一下获取配置 ConfigClientController.java1234567891011@RestControllerclass ConfigClientController &#123; @Value("$&#123;profile&#125;") private String profile; @RequestMapping("/profile") public String getProfile() &#123; return this.profile; &#125;&#125;]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>Spring Cloud Config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud 服务注册与发现、高可用（Eureka）]]></title>
    <url>%2Fblog%2Fspring-cloud-eureka%2F</url>
    <content type="text"><![CDATA[Spring Cloud 服务注册与发现、高可用（Eureka） 服务注册发现服务发现在微服务架构中，服务发现组件是很关键的一个组件，服务发现组件就是去管理各服务的网络地址等信息 服务提供者、服务消费者、服务发现组件的关系 服务启动时，会将自己的网络地址等信息注册到服务发现组件中，让服务发现组件去存储管理这些信息 服务消费者从服务发现组件这里查询服务提供者的网路地址信息，并使用该地址去调用服务提供者的接口 各服务和服务发现组件通过一定的机制通信（心跳） Spring Cloud 支持多种服务发现组件，如 Eureka、Consul 和 Zookeeper 等，这里主要介绍 Spring Cloud Eureka 的使用 Eureka 简介Eureka 是 Netflix 开源的服务治理模块，本身是一个基于 Rest 的服务。Spring Cloud 中将 Eureka 集成在 Spring Cloud Netflix 项目中，另外 Spring Cloud Netflix 还提供了自配置的Netflix OSS整合。提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等 Eureka 架构图 Eureka 是包含两个组件的： Eureka Server 和 Eureka Client Eureka Server 提供服务发现的功能，服务启动后，向 Eureka Server 注册自己的地址信息（IP、端口、服务名） Eureka Client 是一个客户端，用于与 Eureka 的交互 服务启动后，与 Eureka Server 通过 心跳 机制通信，默认周期为 30 秒 当 Eureka Server 在一定时间内接收不到某个服务实例的心跳，将会注销该实例，默认时间为 90 秒 默认情况下 Eureka Server 同时也是 Eureka Client。多个 Eureka Server 实例通过复制的方式来实现服务注册 Eureka Client 有 缓存机制，会缓存服务注册表中的信息。服务不需要每次请求都查询 Eureka Server，这样既降低了 Server 的压力，同时即便 Eureka Server 的节点都宕机了，也可以使用缓存查询到服务提供者的信息完成调用 服务注册中心 Eureka Server创建一个 Spring Boot 项目，依赖项 dependencies 添加 Eureka Server , pom.xml 文件部分内容如下： eureka-server/pom.xml12345678910111213141516171819202122232425262728293031323334&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;groupId&gt;com.cindy&lt;/groupId&gt;&lt;artifactId&gt;eureka-server&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;name&gt;eureka-server&lt;/name&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR1&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 要启动一个服务注册中心，我们要使用注解 @EnableEurekaServer EurekaServerApplication.java12345678@SpringBootApplication@EnableEurekaServerpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 这个时候如果我们直接启动，会发现有个连接异常，那是因为默认设置下，服务注册中心也会把自己当做客户端来注册自己，也就是说 Eureka Server 同时也是一个 Eureka Client，需要指定一个 Server。而通常我们只需要它作为注册中心，可以使用 eureka.client.registerWithEureka=false 和 eureka.client.fetchRegistry：false 来禁用客户端注册行为 application.yml12345678910111213spring: application: name: eureka-serverserver: port: 8761eureka: client: # 是否将自己注册到 Eureka Server registerWithEureka: false # 是否从 Eureka Server 获取注册信息 fetchRegistry: false eureka server 有一个UI的主页，并且 /eureka/* 下有正常 Eureka 功能的HTTP API端点。 启动工程，访问 http://localhost:8761可以看到以下页面，由于还没有注册服务，所以没有被发现的服务 注册服务上面创建了服务注册中心，接下来我们来创建服务客户端，也就是我们要去注册的服务 还是去创建一个 Spring Boot 工程，要添加的依赖为 Eureka Discovery 和 Web product-service/pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;groupId&gt;com.cindy&lt;/groupId&gt;&lt;artifactId&gt;product-service&lt;/artifactId&gt;&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR1&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 同样的，要使用服务注册需要主类上添加注解，注解为 @EnableDiscoveryClient ProductApplication.java12345678@SpringBootApplication@EnableDiscoveryClientpublic class ProductApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProductApplication.class, args); &#125;&#125; 上面的注解也可使用 @EnableEurekaClient，而 @EnableDiscoveryClient 是 spring-cloud-commons 项目的注解，是一个高度的抽象，对各种服务发现组件都提供了支持，如 Zookeeper 和 Consul 也支持 这时需要在客户端这边配置服务注册中心的一些信息，defaultZone 是与 Eureka Server 交互地址，用于查询服务和注册服务 （默认端口是 8761），如果要向多个服务中心注册用逗号隔开 application.yml1234567891011spring: application: name: productserver: port: 8081eureka: client: serviceUrl: # 这里默认是 http://localhost:8761/eureka/ defaultZone: http://localhost:8761/eureka/ 如果想要 IP 地址注册，而不是主机名。可以设置 eureka.instance.preferIpAddress=true 先启动 Eureka Server，再启动该工程，我们打开 Eureka Server 的 UI 界面，可以看到我们的 product 服务已经注册成功了 Eureka 的高可用尽管 Eureka 的客户端具有缓存机制，即使 Eureka Server 宕机，服务之间也可以通过缓存调用，但是在 Eureka Server 宕机的时候，一些微服务也可能出现不可用的问题，而这些情况会没有被更新到缓存中，就可能会影响到某些微服务的调用 生产中通常会部署一个高可用的 Eureka Server 集群，由上面的 Eureka 架构图也可以看出可以通过运行多个 Eureka Server 实例并让他们相互注册来实现高可用部署。 我们来改一下上面的 eureka-server ，同时启动两个实例，来构建双节点的服务注册中心。这里我们要让 Eureka Server 相互注册，所以 registerWithEureka 和 fetchRegistry 就不设置 false 了，而 serviceUrl.defaultZone 则需要填入其他 Eureka Server 的服务地址 123456789101112131415161718192021spring: application: name: eureka-server--- server: port: 8761eureka: client: serviceUrl: defaultZone: http://127.0.0.1:8762/eureka/ ---server: port: 8762eureka: client: serviceUrl: defaultZone: http://127.0.0.1:8761/eureka/ 这里我们起两台服务器，端口号分别为 8761 和 8762 启动之后我们再启动注册服务 端口号为 8762 的 server也能获取端口号为 8761 server 的服务注册信息，尽管我们的注册服务只写了 http://127.0.0.1:8761/eureka/, 这里我们要注册的服务最好把所有的 Eureka Server 地址都添加上，避免在某些情况下服务重启会注册不到 1234eureka: client: service-url: defaultZone: http://localhost:8761/eureka/,http://localhost:8761/eureka/ 如果要构建多个节点的集群，其实也是很简单的，只要它们至少一个边缘彼此连接，也就是两两相互注册就可以了，同时服务同时向他们进行注册 上面直接通过不同 IP 地址和端口号来配置多个服务器会有些麻烦，可以使用 eureka.instance.hostname 定义不同的主机名配合 spring.profiles.active 激活不同的 application-{profile}.yml 配置文件来构建集群 application-peer1.yml123456789server: port: 8761eureka: instance: hostname: peer1 client: service-url: defaulZone: http://peer2:8762/eureka/,http://peer3:8763/eureka/ application-peer2.yml123456789server: port: 8762eureka: instance: hostname: peer2 client: service-url: defaulZone: http://peer1:8761/eureka/,http://peer3:8763/eureka/ application.peer3.yml123456789server: port: 8763eureka: instance: hostname: peer3 client: service-url: defaulZone: http://peer1:8761/eureka/,http://peer2:8762/eureka/ 如上，我们定义了三个不同的 profile，同时命名了三个 Eureka Server 主机名，分别为 peer1、peer2 和 peer3，这样当我们以 peer1 这个 profile 启动项目，它会去注册到 http://peer2:8762/eureka/ 和 http://peer3:8763/eureka/; 同样当 spring.profiles.active 为 peer2 或者 peer3 时，他们会向其他两个地址注册服务，这样便做到了两两相互注册 当我们打包好项目，可以通过以下命令来分别启动这三个 Eureka Server 节点 123java -jar eureka-server.jar --spring.profiles.active=peer1java -jar eureka-server.jar --spring.profiles.active=peer2java -jar eureka-server.jar --spring.profiles.active=peer3 当我们把服务再注册到这个 Eureka Server 集群的时候，配置多个 Eureka Server 地址就可以了 eureka-client/.../application.yml1234eureka: client: service-url: defaultZone: http://peer1:8761/eureka/,http://peer2:8762/eureka/,http://peer3:8763/eureka/ 如果这里的主机名直接可以设置成域名，就可以直接配置像 http://peer1/eureka/ 这样的地址了 如果不是，就需要通过操作注册服务的服务器系统 /etc/hosts 来解析主机名，如127.0.0.1 peer1 peer2 peer3 代码参考：demo]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>Eureka</tag>
        <tag>服务注册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 详细介绍和使用]]></title>
    <url>%2Fblog%2Fgit-introduction-usage%2F</url>
    <content type="text"><![CDATA[git /gɪt/ 是一个开源的分布式版本控制系统 最初是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件 介绍版本控制版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。可以对任何类型的文件进行版本控制，便于不同的开发者协同工作 集中式版本控制 集中化的版本控制系统是为了让不同系统上的开发者协同工作。例如 SVN，它会有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人通过客户端连接到这台服务器，拉取最新的文件或者是提交更新 在这个系统中，每个人可以看到项目中其他人的工作，管理员也能很好的掌握和分配每个开发者的权限。但由于版本库是集中在服务器上的，如果出现了中央服务器的单点故障，在这个时间内，谁都无法提交更新，而且整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险 分布式版本控制 分布式的版本控制解决了集中化版本控制的一些问题，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份 更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的 Git 介绍直接记录快照，而非差异比较 Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照 Git 把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，它会对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个快照流 近乎所有操作都是本地执行 在 Git 中的绝大多数操作都只需要访问本地文件和资源，因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成， Git 保证完整性 Git 中所有数据在存储前都计算校验和，然后以校验和来引用 Git 一般只添加数据 执行的 Git 操作，几乎只往 Git 数据库中增加数据 Git安装Linux 上安装 Linux 上使用 yum 安装，yum install git 1$ sudo yum install git Windows 上安装 官网上下载安装包安装即可 https://git-scm.com/downloads 配置用户信息 安装完后需要设置用户名称和邮件地址，这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改 12$ git config --global user.name "zou"$ git config --global user.email zouxq412@foxmail.com 配置完后可以使用 git config --list 查看配置信息 使用了 –global 选项，表示全局配置，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置 Git 工作区、暂存区和版本库在了解 Git 的基本操作之前，我们先来了解 Git 工作区、暂存区和版本库的概念 在 Git 中的文件有三种状态：已提交(committed)： 表示数据已经安全的保存在本地数据库中；已修改(modified)： 表示修改了文件，但还没保存到数据库中；已暂存(staged)： 表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此也引入了 Git 项目的三个工作区域的概念： 工作区： 就是项目文件所在的目录 暂存区： stage 或 index。一般存放在 .git/index 文件中，所以我们把暂存区有时也叫作索引 版本库： 工作区下隐藏目录 .git，这里记录着仓库的版本信息和历史记录 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： 下面我们通过创建仓库和基本操作来了解这三个工作区域的关系 Git 仓库创建及基本操作创建 Git 仓库仓库也叫版本库（repository），可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以还原 创建并初始化仓库git init 是用来初始化一个 Git 仓库的 1git init 该命令会在当前目录下创建一个 .git 的目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件。这个时候只是对仓库做了初始化的操作，假如该目录下原本就有文件，需要对这些文件进行版本控制，可以通过 git add &lt;file&gt; 跟踪这些文件并提交 git commit -m &lt;message&gt; 12git add .git commit -m 'initial project version' 上面是把目录下的所有文件提交到了仓库中 克隆现有的仓库如果想获取现有 Git 仓库的拷贝，需要用 git clone &lt;repo&gt; 或 git clone &lt;repo&gt; &lt;directory&gt; repo 是仓库地址，directory 是本地仓库的名称，即目录名称 如下面我要克隆 github 上的一个仓库，并制定本地仓库的名称为 mylibname 1git clone https://github.com/xxxx/xxxx mylibname 基本操作工作目录下的每一个文件有这两种状态： 已跟踪 已经纳入了版本控制的文件，在上一次快照中有它们的记录，它们的状态可能处于 未修改，已修改 或 已放入暂存区。 未跟踪 即还没有加入到版本控制的文件 新增的未跟踪文件(untracked)，和编辑过被 Git 记为已修改的文件(modified)。 通过 git add 放入暂存区(staged)，然后 git commit 提交所有暂存了的修改，提交后的文件即为未修改文件(unmodified)，如此反复 操作命令： git status 查看文件状态 git add 添加文件到暂存区，包括未跟踪和修改的文件 git diff 查看修改内容 git commit 提交更新，添加暂存区的内容到本地仓库 git reset HEAD 取消暂存 git rm 移除文件 git mv 移动文件 这里我新建一个 demo 目录作为仓库，并初始化这个仓库 接下来我们使用上面新建的仓库 demo，并对里面的文件做一些操作 先创建一个新的文件 touch readme.txt 查看当前文件状态要查看仓库目录下哪些文件处于状态状态，使用 git status 命令 Untracked files 未被跟踪的文件 Changes not staged for commit 修改的文件 Changes to be committed 暂存状态文件 可以看到新建的文件 readme.txt 的文件状态为 untracked，并提示我们要通过 git add &lt;file&gt; 命令去跟踪我们需要提交的文件 如果使用 git status -s 命令或 git status --short 命令，将得到一种更为紧凑的格式输出 跟踪新文件/ 暂存已修改的文件使用命令 git add &lt;file&gt; 开始跟踪一个文件或暂存修改的文件，会把文件添加到暂存区 1git add readme.txt 再次使用 git status 命令查看，会看到 readme.txt 文件已经被跟踪，并处于暂存状态。Changes to be committed 下的文件就是处于暂存状态 git add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件 该命令还用来暂存已修改的文件，就是 Changes not staged for commit下的文件 查看已暂存和未暂存的修改这个时候假如我们对暂存的文件进行了修改 1echo 'My Project' &gt; readme.txt 使用 git status 命令查看，我们可以看到多出了一个未被暂存，被修改状态的文件，而使用 git status 命令并不能看到具体修改的地方，这时可以用 git diff 来查看未暂存的文件更新的部分 输入 git diff 来查看未暂存的文件更新的部分 该命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff --cached 命令 git diff 尚未暂存的改动 git diff --cached 查看已暂存的改动 提交更新当暂存区的文件已经准备妥当可以提交了，可以通过命令 git commit 来提交，或者直接加入说明 git commit -m &lt;message&gt; 1git commit 这种方式会启动文本编辑器以便输入本次提交的说明（这里的编辑器是 vim） 使用 git commit -m &lt;message&gt; 请记住，提交时记录的是放在暂存区域的快照。 任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较 跳过使用暂存区域 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤 取消暂存git reset HEAD &lt;file&gt;... 用来取消已暂存的内容 我们修改下 readme.txt ，并 git add 到暂存区 12echo 'modify content' &gt; readme.txtgit add readme.txt 通过 git status 可以看到 readme.txt 已经添加到暂存区了 假如这时不想把它提交更新并加入到下一次的快照当中，就可以通过git reset HEAD &lt;file&gt; 去取消已暂存的内容 1git reset HEAD readme.txt 撤消对文件的修改 如果你想撤销对文件的修改，也就是还原到未修改前的状态，可以使用 git checkout -- [file] 命令。该命令会取消你对该文件做的修改内容。 移除文件假如我们现在去删除 readme.txt 这个文件，再通过 git status 查看状态 它是会记录我们的删除操作，标记为未暂存的文件 然后再运行 git rm &lt;file&gt; 记录此次移除文件的操作 下次提交更新 git commit 之后，该文件就不再纳入版本控制管理中了 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f，即git rm -f &lt;file&gt; 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可 移动文件git mv 命令用于移动或重命名一个文件、目录、软连接。 我们先撤销对 readme.txt 文件的删除 12git reset HEAD readme.txtgit checkout -- readme.txt 然后使用 git mv 对其重命名 1git mv readme.txt README.md Git 主要功能远程仓库（github）上面我们有关的命名操作都是本地执行，如果需要分享代码或与其他开发人员协同工作，就需要连接远程仓库了。这个远程仓库是指托管在因特网或其他网络中的你的项目的版本库 这里我们使用 github 作为远程仓库 添加远程仓库运行 git remote add &lt;shortname&gt; &lt;url&gt; 添加一个新的远程 Git 仓库 这里是以 github 做为远程仓库为例，本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，我们需要先配置验证信息 使用以下命令生成 SSH Key 1ssh-keygen -t rsa -C "zouxq412@foxmail.com" 这里的邮箱为你 github 账号绑定的邮箱，生成 SSH Key 后我们去到它保存的路径 ~/.ssh 下打开 id_rsa.pub 复制里面的公钥 然后我们去到 github 的设置中心找到 SSH and GPG keys，点击 New SSH key 设置 SSH 公钥 将复制的 SSH 公钥添加并保存为了验证是否成功，使用命令 ssh -T git@github.com接下来我们在 github上去新建一个仓库 创建成功后，显示以下信息 上面会有一些提示，允许我们创建一个新的本地仓库或把已存在的仓库推到 github仓库上，这里我们直接把直接的 demo 上传到这个 github 仓库中 12git remote add origin https://github.com/Morgan412/demo.gitgit push -u origin master 第一次会让我们输入 github 的账号密码 git push 会把本地仓库的内容推送到远程仓库中，这时可以刷新下 github 的仓库页面，会发现已经有上传的内容了 推送到远程仓库的命令为： git push [remote-name] [branchname] 查看当前的远程仓库查看你已经配置的远程仓库服务器，可以运行 git remote 命令， 它会列出你指定的每一个远程服务器的简写，也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL 如果想要查看某一个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令 从远程仓库中抓取与拉取从远程仓库获取数据的命令 1git fetch [remote-name] 这个命令会访问远程仓库，从中拉取所有你还没有的数据，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库，当它并不会自动合并或修改你当前的工作，这个时候我们可以运行 git merge [alias]/[branch] 来合并分支 现在我们在 github 的远程仓库中修改 README.md 文件，然后运行 git fetch origin 可以看到信息提示远程仓库的 master 有更新，这时再运行 git merge origin/master README.md 文件被合并更新 如果你有一个分支设置为跟踪一个远程分支，可以使用 git pull &lt;remote&gt; &lt;branch&gt; 命令来自动的抓取然后合并远程分支到当前分支。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 远程仓库的移除与重命名git remote rename 去修改一个远程仓库的简写名git remote rm [name] 可以去移除一个远程仓库 标签管理Git 可以给历史中的某一个提交打上标签，可以使用这个功能来标记发布结点（如v1.0），标签也是版本库的一个快照 命令： git tag 查看所有的标签 git tag &lt;name&gt; 创建标签 git tag -v &lt;name&gt; -m &lt;message&gt; 创建附注标签 git push origin [tagname] 推送标签到远程仓库 git tag -d &lt;tagname&gt; 删除本地仓库标签 git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; 更新远程仓库标签 创建标签创建标签命令 git tag &lt;name&gt; git tag -v &lt;name&gt; -m &lt;message&gt; 可以创建一个附注标签 首先我们要切换到需要打标签的分支上，然后使用创建标签命令 git tag &lt;name&gt; 1git tag v1.0.0 git tag 可以查看所有的标签 后期打标签 默认情况下，标签是打在最新提交 commit 上的，假如我想对过去的某个历史快照节点打标签呢？其实也是可以的 git log --pretty=oneline --abbrev-commit 查看历史 commit id，然后打上对应标签即可 1234$ git log --pretty=oneline --abbrev-commit459f6fc (HEAD -&gt; master, origin/master) Update README.mde241626 修改内容a9dec5d first commit 如我要给 “修改内容” 这次 commit 打上标签 1git tag v1.0.1 e241626 标签操作共享标签 默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样，你可以运行 git push origin [tagname] 如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里 删除标签 使用命令 git tag -d &lt;tagname&gt; 可以删除掉本地仓库上的标签 上面的命令并不会从任何远程仓库中移除这个标签，如果要移除远程仓库的标签必须使用 git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; 来更新你的远程仓库 分支管理分支就像是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 在实际工作中，当你需要完成某个需要，而这个需求你可能需要2天才能完成，这时你可以新建一个分支，在分支上的任何改动都是不影响其他分支的，当你完成了需求之后，再合并分支 命令： git branch 列出分支，当前分支前面会标一个*号 git branch &lt;branchname&gt; 创建分支 git checkout &lt;branchname&gt; 切换分支 git checkout -b &lt;branchname&gt; 创建并切换分支 git merge 合并分支 git branch -d &lt;branchname&gt; 删除分支 分支的创建和合并创建分支 12git branch &lt;branchname&gt;git checkout &lt;branchname&gt; 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 -b 参数的 git checkout 命令，等同于上面两个命令 1git checkout -b newb git branch 列出分支，当前分支前面会标一个*号 合并分支 一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支 使用 git merge 命令将任何分支合并到当前分支中去 假如我们现在对新的分支内容有了修改，现在要合并到主分支中 合并冲突 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成 解决冲突就是把 Git 合并失败的文件手动编辑为我们希望的内容，再提交]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 入门实践]]></title>
    <url>%2Fblog%2Fdocker-introduction-usage%2F</url>
    <content type="text"><![CDATA[Docker 是什么Docker 容器标准化的软件单元 Docker 是开发人员或系统管理员使用容器 开发，部署和运行 应用程序的平台。使用Linux容器部署应用程序称为容器化 容器化越来越受欢迎，因为容器是： 灵活：即使是最复杂的应用也可以集装箱化。 轻量级：容器利用并共享主机内核。 可互换：您可以即时部署更新和升级。 便携式：您可以在本地构建，部署到云，并在任何地方运行。 可扩展：您可以增加并自动分发容器副本。 可堆叠：您可以垂直和即时堆叠服务。 容器是一个标准的软件单元，它将代码及其所有依赖关系打包，以便应用程序从一个计算环境快速可靠地运行到另一个计算环境。Docker 容器镜像是一个轻量级，独立的可执行软件包，包含运行应用程序所需的一切：代码，运行时，系统工具，系统库和设置。镜像在运行时成为容器，容器将应用与其环境隔离开来，并确保它可以统一运行 在Docker Engine上运行的Docker容器： 标准： Docker创建了容器的行业标准，因此它们可以随处携带 轻量级： 容器共享机器的操作系统内核，因此不需要每个应用程序的操作系统，从而提高服务器效率并降低服务器和许可成本 安全： 应用程序在容器中更安全，Docker提供业界最强大的默认隔离功能（类似“沙箱“） 镜像和容器通过运行镜像启动容器。一个镜像是一个可执行的包，其中包括运行应用程序所需的所有内容—-代码，运行时，库，环境变量，和配置文件。而容器是镜像的运行时实例，当执行镜像时，即在内存中变成用户进程，可以使用 docker ps 命令查看正在运行的容器列表 镜像和容器的关系有些像 Java 中类和对象实例的关系 容器和虚拟机容器和虚拟机具有类似的资源隔离和分配优势，但功能不同，因为容器虚拟化操作系统而不是硬件。容器更便携，更高效。 一个容器中运行原生 Linux和共享主机与其它容器的内核。它运行一个独立的进程，不占用任何其他可执行文件的内存，使其轻量级。容器是应用层的抽象，它将代码和依赖关系打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。容器占用的空间比VM少（容器映像的大小通常为几十MB），可以处理更多的应用程序，并且需要更少的VM和操作系统 相比之下，虚拟机（VM）运行一个完整的“客户”操作系统，通过虚拟机管理程序对主机资源进行虚拟访问。通常，VM提供的环境比大多数应用程序需要的资源更多。虚拟机（VM）是物理硬件的抽象，将一台服务器转变为多台服务器。管理程序允许多台VM在单台机器上运行。每个VM都包含操作系统的完整副本，应用程序，必要的二进制文件和库 - 占用数十GB。虚拟机也可能很慢启动。 安装mac 和 windows 可以直接安装 Docker Desktop 即可，方便开发 Linux 安装我这里以 Centos 7 为例 安装 Docker CEDocker Community Edition 是社区版，适用于个人开发者和小团队 官方提供了三种方式安装 Docker CE： 设置 Docker 存储库并安装，便于安装和升级（推荐） 使用 rpm 包手动安装，需要手动管理升级 使用便捷脚本安装（不建议生产使用） 这里使用 Docker 存储库安装 设置存储库1）安装需要的包 yum-utils 提供了 yum-config-manager 的功能，devicemapper 存储驱动需要 device-mapper-persistent-data 和 lvm2 123$ sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 2）设置稳定的存储库 123$ sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 安装 Docker安装最新的 Docker CE 和 containerd 1$ sudo yum install docker-ce docker-ce-cli containerd.io 若需安装特定版本的 Docker CE，可以在 repo 中列出可用版本，并选择安装 1$ yum list docker-ce --showduplicates | sort -r 然后在安装命令上加上版本号即可，假如是 docker-ce-18.09.1 $ sudo yum install docker-ce-18.09.1 docker-ce-cli-18.09.1 containerd.io 启动 Docker1$ sudo systemctl start docker 验证运行 hello-world 镜像验证是否正确安装 1$ sudo docker run hello-world 使用 rpm 包安装到地址 https://download.docker.com/linux/centos/7/x86_64/stable/Packages/ 下载对应版本的 rpm 包 安装对应路径下的包 1$ sudo yum install /path/to/package.rpm Docker 系统架构Docker使用客户端 - 服务器架构。Docker 客户端与 Docker 守护进程通信，后者负责构建，运行和分发Docker容器。Docker客户端和守护程序可以在同一系统上运行，也可以将Docker客户端连接到远程Docker守护程序。Docker客户端和守护程序使用REST API，通过UNIX套接字或网络接口进行通信 Client：表示 Docker 客户端，通过 docker build 命令创建 Docker 镜像，docker pull 拉取镜像，docker run 运行镜像，并启动 Docker 容器 DOCKER_HOST：运行 Docker 引擎的宿主机，包括 Docker daemon 后台进程，可通过该进程来创建镜像，并在镜像上启动容器 Registry：Docker 官方镜像注册中心，包含大量的Docker 镜像仓库，可以通过 Docker 引擎拉取所需的 Docker 镜像到宿主机。Docker Hub 是公共注册中心，Docker 配置为默认在Docker Hub 上查找镜像 Images：Docker 镜像是一个只读模板，它包含创建 Docker容器的说明。它和系统安装光盘有点像，使用系统安装光盘可以安装系统，同理，使用Docker镜像可以运行 Docker镜像中的程序 Container：容器是镜像的可运行实例。镜像和容器的关系有点类似于面向对象中，类和对象的关系。可通过 Docker API或者 CLI命令来启停、移动、删除容器 使用 Dockerfile 构建镜像Dockerfile 是一个文本文件，包含了一些指令，这些指令描述了创建镜像的细节 Dockerfile 123456# 设置 nginx 基础镜像 FROM nginx:1.15 # 也可以用 LABEL maintainer="zouxq &lt;zouxq412@foxmial.com&gt;"MAINTAINER zouxq &lt;zouxq412@foxmial.com&gt; # 将 dist 文件中的内容复制到 /usr/share/nginx/html/ 这个目录下面 COPY dist/ /usr/share/nginx/html/ 上面就是简单构建一个静态服务器镜像的 Dockerfile Dockerfile 指令介绍上面例子的 FROM、MAINTAINER、COPY 就是 Dockerfile 指令，指令的一般格式为：指令名称 参数 1）FROM 指定基础镜像 FROM 指令一般要写在其他指令之前，它指定我们要创建新镜像所依赖的基础镜像 FROM &lt;image&gt; FROM &lt;image&gt;:&lt;tag&gt; FROM &lt;image&gt;@&lt;digest&gt; 例如我们需要构建 Java 应用程序的镜像 1FROM java 这里使用了 Docker 官方提供的 Java 镜像，是基于 open Jdk 制作的镜像 2）RUN 设置镜像制作过程中需要执行的命令 RUN &lt;command&gt;（该命令在 shell 中运行，在 Linux 默认 /bin/sh -c，Windows是 cmd /S /C ） RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]（使用 exec 执行） 12RUN /bin/bash -c 'source $HOME/.bashrc; \echo $HOME' 可以使用多行 RUN 指令，但多条指令通过 \ 命令换行符合并成一条，可以减少所构建的镜像的体积，因为在镜像中每执行一条命令，都会形成新的 “镜像层” 1RUN ["/bin/bash", "-c", "echo hello"] exec 表单被解析为JSON数组，所以这种方式要使用双引号而不能使用单引号 3）ADD 设置需要添加到容器中的文件 ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt; ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] 从 src 目录复制文件到容器的 dest, 其中 src 可以是 Dockerfile 所在目录的相对路径，也可以是一个 URL，还可以是个压缩包 4）COPY 复制文件 COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt; COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] COPY 指令和 ADD 指令类似，COPY 不支持 URL 和压缩包 5）CMD 设置容器启动时需要执行的命令 CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]（推荐） CMD [&quot;param1&quot;,&quot;param2&quot;]（作为ENTRYPOINT的默认参数） CMD command param1 param2 （在 shell 中执行） 每个 Dockerfile 只有一个 CMD 命令，多个只有最后被执行 1CMD echo "This is a test." | wc - Dockerfile 指令汇总Dockerfile 指令 Dockerfile 指令 描述 FROM 设置基础镜像 RUN 设置镜像制作过程中需要执行的命令 CMD 设置容器启动时需要执行的命令（可被覆盖） LABEL 添加元数据到镜像（键值对） MAINTAINER (deprecated) 设置维护者信息（被启用，可使用更灵活的LABEL指令） EXPOSE 设置可被暴露的端口号（端口映射） ENV 设置环境变量，可在 RUN 指令中使用 ADD 设置需要添加到容器中的文件（自动解压） COPY 设置需要复制到容器中的文件（无法解压） ENTRYPOINT 设置容器启动时需要运行的命令（无法覆盖） VOLUME 设置可被挂载的数据卷（目录映射） USER 设置运行 RUN 指令的用户 WORKDIR 设置进入容器时的工作目录 ARG ONBUILD 设置在构建时需自动执行的指令 STOPSIGNAL 设置将发送到容器的系统调用信号以退出 HEALTHCHECK 设置容器的健康检查 SHELL 使用 Dockerfile 构建镜像上面介绍了部分的 Dockerfile 指令 接下来我们用 Dockerfile 去创建一个 Spring Boot 应用的镜像 1、准备工作 搭建一个简单的 Spring Boot 应用程序，这里以 Hello World 为例 12345678910111213@SpringBootApplication@RestControllerpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @RequestMapping("/") public String hello()&#123; return "Hello World"; &#125;&#125; 使用 maven 打包项目 mvn clean package 2、创建 Dockerfile 文件 在工程目录下创建一个 Dockerfile 文件，添加以下内容 12345678910# 基于 java8FROM java:8# 将本地文件夹挂载到当前容器VOLUME /tmp# 添加文件到容器ADD target/demo-0.0.1-SNAPSHOT.jar /home/demo.jar# 声明需要暴露的端口EXPOSE 8081# 配置容器启动后执行的命令ENTRYPOINT ["java","-jar","/home/demo.jar"] 3、使用 docker build 命令构建镜像 docker build -t demo-server:0.0.1 . 格式： docker build -t 仓库名称/镜像名称(:标签) Dockerfile的相对位置 -t 表示以“name：tag”格式命名和选择标记 执行命令后，会看到以下信息，可以看到镜像构建的详细过程和结果 我们可以通过 docker image ls 或者 docker images 命令来查看镜像列表 4、启动容器 运行上面创建的镜像启动容器 docker run -d -p 8081:8081 demo-server:0.0.1 -d 表示在后台运行容器并打印容器ID -p 表示将容器的端口发布到主机 后面是镜像名称加上标签版本号 可以使用 docker container ls 或者 docker ps 来查看在运行的容器，如果要查看所有的容器在后面加上 --all]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 使用文件增加虚拟内存 swap]]></title>
    <url>%2Fblog%2Flinux-swap%2F</url>
    <content type="text"><![CDATA[之前买了个云服务器玩，不过是最低配置的1核1G，后来发现这个内存太小了，随便装几个软件就不行了，内存消耗较大的像 redis 运行起来很多问题。 前些时间了解了下 Docker 容器，去尝试了下发现 MySQL 就挂了，而且怎么样也启动不了了，后来发现是内存实在是不够了 后来网上了解，如果服务器的总是报告内存不足，并且时常因为内存不足而引发服务被强制 kill 的话，在不增加物理内存的情况下，启用 swap 交换区作为虚拟内存是一个不错的选择。当然这个选择是在你对访问速度和缓存那些没什么要求的情况下，比如你自己测试玩的 虚拟内存一般设置为物理内存的2倍即可 新增swap分区这里使用文件作为swap分区 ，下面操作需要在root用户下操作 使用 free -h 查看当前内存占用情况，可以看到物理内存所剩无几，下面的 swap 也是使用的文件作为虚拟内存使用的 创建要作为swap分区的文件:增加1GB大小的交换分区，则命令写法如下，其中的count等于想要的块的数量（bs*count=文件大小），如下面是2G # dd if=/dev/zero of=/root/swapfile2 bs=1M count=2048 这里我使用的of为/root/swapfile2 ，可以看到该文件是新创建的，这时候这个文件还不能直接使用为swap文件 修改文件权限，如不修改，在启用swap文件的时候会提示下面信息（不影响使用，建议修改） # chmod 0600 /root/swapfile2 格式化为交换分区文件，建立swap的文件系统，/root/swapfile2需要与上面的of的值一致，这个目录可以自定义 # mkswap /root/swapfile2 启用swap文件: # swapon /root/swapfile2 可以看到未启用时虚拟内存为2G，启用后内存增加了2G 使系统开机时自启用 # vim /etc/fstab 在文件/etc/fstab中添加一行 /root/swapfile2 swap swap defaults 0 0 调整swap空间使用的优先级如果内存够大，应当告诉 linux 不必太多的使用 SWAP 分区， 可以通过修改 swappiness 的数值。 swappiness=0 的时候表示最大限度使用物理内存，然后才是 swap空间，swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面。 各个操作系统的优先级可能都不一样，如果不调整，你会发现添加的虚拟内存几乎没有用到 查看当前swappiness值 # cat /proc/sys/vm/swappiness 修改swappiness值为60（临时修改，重启后即还原为默认值） # sudo sysctl vm.swappiness=60 永久修改swappiness默认值（重启生效） # vim /etc/sysctl.conf 找到vm.swappiness ，如果没有则需要手动添加一行 vm.swappiness = 60 保存即可]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 多环境配置]]></title>
    <url>%2Fblog%2Fspring-boot-profiles%2F</url>
    <content type="text"><![CDATA[Spring Boot 多环境配置 通常，在我们应用开发中，需要多个环境配置，一般是开发、测试、生产，有的还有演示环境。这些环境有不同的配置需求： 服务的端口、ip地址 数据库的信息、连接池等 日志配置、日志级别 第三方系统访问配置 Spring Boot 简化了配置，属性配置都放在了 application.properties 中，除 application.properties 文件外，还可以使用 application-{profile}.properties 命名约定来定义特定于配置文件的属性 这样可以有多个配置文件， 可以在系统部署的时候，使用 spring.profiles.active 属性指定使用哪个配置文件覆盖默认的 application.properties ， 从而完成多环境部署。 如下配置三个不同环境的配置文件 在 application.properties 中设置 1spring.profiles.active=test 启动后可以看到 说明是使用了 application-test.properties 的环境配置 以上在开发中可以很方便切换环境，部署时也可以很简单 1java -jar -Dspring.profiles.active=prod target/myproject-0.0.1-SNAPSHOT.jar 以上配置启动后, Spring Boot 将读取 appIication-prod.properties 配置文件，覆盖默认的application. properties 选项 另外，为了安全考虑，开发环境不应该有线上环境的各种配置信息。可以将配置文件放到特定的目录中，井用 spring.config.location 指定配置文件的目录 1java -jar -Dspring.config.location=file:env/ -Dspring.profiles.active=test target/myproject-0.0.1-SNAPSHOT.jar 配置文件位于当前目录的 env 目录下， profile 是 test，因此会读取的是 env 下的 application-test.properties 配置文件 Spring Boot 如何找到配置文件： Spring Boot 应用默认读取了application.properties 文件，实际上， Spring Boot 会自动搜索classpath:、classpath:/config 、file: 、file:config／ 这些目录下的配置文件，优先级由低到高， file:config／的优先级最高 这是系统属性 spring.config.location 默认的配置。spring .config .name 表示配置文件的名称，默认是application]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 的生产级特性--Actuator监控端点]]></title>
    <url>%2Fblog%2Fspring-boot-actuator%2F</url>
    <content type="text"><![CDATA[Spring Boot 生产级的特性 Spring Boot 有许多开箱即用的模块或者说插件，其中 spring-boot-actuator 提供了大量的生产级的特性。添加 spring-boot-starter-actuator 的 maven 依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 端点Actuator 模块提供一系列的 HTTP 请求，这些请求都是 GET 类型的，不带任何请求参数，可用通过他们获取 Spring Boot 应用程序的相关信息。这些入口就是 端点 (Endpoint) ID 描述 auditevents 公开当前应用程序的审计事件信息 beans 获取 Spring bean 的完整列表 caches 获取可用的缓存 conditions 显示自动配置类的评估和配置条件，以及它们匹配或不匹配的原因。 configprops 显示配置项信息（通过@ConfigurationProperties配置） env 获取 Spring 应用的环境变量信息 ConfigurableEnvironment flyway 显示已应用的Flyway数据库迁移信息 health 显示应用健康检查信息 httptrace 显示HTTP跟踪信息（默认情况下，最新100个HTTP请求） info 显示当前应用信息 integrationgraph 显示 Spring 集成图 loggers 显示和修改应用程序中记录器的配置 liquibase 显示已应用的Liquibase数据库迁移的信息 metrics 显示当前应用程序的“度量”指标信息 mappings 显示所有@RequestMapping的映射路径信息 scheduledtasks 显示应用程序中的任务计划 sessions 允许从Spring Session支持的会话存储中检索和删除用户会话。使用Spring Session对响应式Web应用程序的支持时不可用 shutdown 允许应用程序正常关闭（默认情况下不开启这个端点） threaddump 执行线程转储 访问这些端点需要 前缀 /actuator/ + 加上端点ID（spring boot 2.0之后需要加上 /actuator/），如 health 端点映射路径为 /actuator/health 端点启用和关闭默认情况下，除 shutdown 的所有端点都是开启的，我们可以根据实际情况自由的控制哪些端点启用，哪些关闭，甚至还可以修改默认的端点名称。 配置端点的启用 management.endpoint.&lt;id&gt;.enabled，如启用 shutdown 端点 1management.endpoint.shutdown.enabled=true 如果想要端点启用是选择加入而不是选择退出，将management.endpoints.enabled-by-default属性设置 为false，并使用各个端点 enabled 属性重新加入。以下示例启用info端点并禁用所有其他端点 12management.endpoints.enabled-by-default=falsemanagement.endpoint.info.enabled=true 暴露端点暴露端点我们启动了 spring boot 之后，在浏览器地址栏中分别输入： http://localhost:8080/actuator/health http://localhost:8080/actuator/beans 前面说默认情况下大部分端点都是开启的，那为何端点 health 是可以访问到的，而端点 beans 确不行呢？ 原因是这些端点往往显示的都是项目的敏感信息，默认情况下，在 Web 下，Spring Boot 只会暴露 info h和 health 这两个端点，其余的都不暴露 想要改变暴露的端点，要使用 include和 exclude 属性 属性 默认 management.endpoints.jmx.exposure.exclude management.endpoints.jmx.exposure.include * management.endpoints.web.exposure.exclude management.endpoints.web.exposure.include info, health 为了让 Actuator 暴露端点，可以配置 1management.endpoints.web.exposure.include=health,info,beans 这样就可以访问 beans 端点了（http://localhost:8080/actuator/beans） 暴露端点的安全性问题在默认情况下，Actuator 对敏感信息是除了health 和 info 端点， 其余端点都是不暴露的。虽然可以通过配置 application.properties 这样的方式可以进行访问，但是这样的方式从安全的角度来说是非常不利的 可以使用 Spring Security 配置用户和角色，来解决这些敏感信息的访问权限问题，引入spring-boot-starter-security ， 然后配置用户和角色 123456789101112@Configurationpublic class ActuatorSecurity extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests() .anyRequest().hasRole("ENDPOINT_ADMIN") .and() .httpBasic(); &#125;&#125; 上面的示例用于 EndpointRequest.toAnyEndpoint() 将请求与任何端点进行匹配，然后确保所有端点都具有该ENDPOINT_ADMIN角色。其他几种匹配方法也可用EndpointRequest 这个时候可以配置application.properties： 1management.endpoints.web.exposure.include=* 通过这样的配置就可以把所有的端点都暴露出来，只是在Spring Security 中，对应保护的端点需要拥有对应的权限才可以进行访问]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 注解]]></title>
    <url>%2Fblog%2Fjava-annotation%2F</url>
    <content type="text"><![CDATA[Java 注解其实大家不陌生，使用 spring、mybatis 这样的框架时，会有许多的注解，那注解到底是什么？ java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用 注解 (annotation) 是在实际的源代码级别保存所有的信息，而不是某种注释性的文字 (comment) 常见注解Java 注解是从 Java 5 引入的，也称作 元数据，即描述数据的数据 Java SE5 内置了三种标准注解： @Override，表示当前的方法定义将覆盖超类中的方法。拼写错误或方法签名对不上覆盖的方法，编译器会错误提示 @Deprecated，表示过时的方法，表示被弃用的代码，使用了注解为它的元素编译器将发出警告 @SuppressWarnings，关闭不当编译器警告信息。 基本语法要学习注解，我们就必须要能定义自己的注解，并使用注解，在定义自己的注解之前，我们就必须要了解Java为我们提供的元注解和相关定义注解的语法。 定义注解格式： public @interface 注解名 {定义体} 定义注解 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Test&#123;&#125; 注解的定义看起来很像接口的定义，事实上，注解也会被编译成 class 文件 定义注解时，会需要一些 元注解（meta-annotation）,如 @Target 和 @Retention。在注解中，一般会有一些元素（参数）以表示某些值，分析处理注解时，可以去利用这些值。没有元素的注解为 标记注解（marker annotation） 使用注解 123456public class TestExample&#123; @Test void test()&#123; ... &#125;&#125; 被注解的方法和其他方法没有区别，如上，注解@Test 可以和修饰符共同作用于方法，从语法角度，注解的使用方式与修饰符一样 元注解元注解是用来注解其他的注解，也就是我们自定义注解需要元注解 @Target描述该注解的使用范围，可能的ElementType参数有： CONSTRUCTOR：构造器的声明 FIELD：域声明（包括enum实例） LOCAL_VARIABLE：局部变量声明 METHOD：方法声明 PACKAGE：包声明 PARAMETER：参数声明 TYPE：类、接口（包括注解类型）或enum声明 | @Retention表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数包括： SOURCE：注解将被编译器丢弃 CLASS：注解在class文件中可用，但会被VM丢弃 RUNTIME：VM将在运行期间保留注解，因此可以通过反射机制读取注解的信息 | @Documented将注解包含在Javadoc中 @Inherited允许子类继承父类中的注解 | 注解元素使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。 注解中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。 注解类型里面的元素该怎么设定: 只能用 public 或默认(default)这两个访问权修饰 只能用基本类型（byte,short,char,int,long,float,double,boolean）八种基本数据类型和 String, Enum, Class, Annotation 等数据类型,以及这些类型的数组 如果只有一个参数成员,最好把参数名称设为 value（注解在只有一个元素且该元素的名称是value的情况下，在使用注解的时候可以省略“value=”，直接写需要的值） 默认值限制 注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可为null 12345@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface FruitName &#123; String value() default "";&#125; 12345678@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface FruitColor &#123; public enum Color&#123; BULE,RED,GREEN&#125;; Color fruitColor() default Color.GREEN;&#125; 12345678910public class Apple &#123; @FruitName("Apple") private String appleName; @FruitColor(fruitColor=Color.RED) private String appleColor; ...&#125; 注解处理器注解的本质其实是一个继承了 java.lang.annotation.Annotation 接口的接口 The common interface extended by all annotation types 如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建和使用注解处理器。Java5扩展了反射机制的API，以帮助程序员快速的构造自定义注解处理器。 注解处理器类库(java.lang.reflect.AnnotatedElement)： Java使用Annotation接口来代表程序元素前面的注解，该接口是所有Annotation类型的父接口。除此之外，Java在java.lang.reflect 包下新增了AnnotatedElement接口，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类： Class：类定义 Constructor：构造器定义 Field：累的成员变量定义 Method：类的方法定义 Package：类的包定义 当一个Annotation类型被定义为运行时的Annotation后，该注解才能是运行时可见，可以使用反射获取Annotation 信息。AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息： 方法1： T getAnnotation(Class annotationClass):返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。 方法2：Annotation[] getAnnotations():返回该程序元素上存在的所有注解。 方法3：boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false. 方法4：Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注解。（如果没有注解直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。 12345678910111213141516public class FruitInfoUtil &#123; public static void getFruitInfo(Class&lt;?&gt; clazz)&#123; Field[] fields = clazz.getDeclaredFields(); for(Field field :fields)&#123; if(field.isAnnotationPresent(FruitName.class)) &#123; FruitName fruitName = (FruitName) field.getAnnotation(FruitName.class); System.out.println(fruitName.value()); &#125; else if(field.isAnnotationPresent(FruitColor.class)) &#123; FruitColor fruitColor= (FruitColor)field.getAnnotation(FruitColor.class); System.out.println(fruitColor.fruitColor().toString()); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Mvc 异常处理机制和统一异常处理]]></title>
    <url>%2Fblog%2Fspring-mvc-exceptions-handling%2F</url>
    <content type="text"><![CDATA[异常处理机制Spring MVC 是通过 HandlerExceptionResolver 处理程序的异常，包括请求映射、数据绑定以及处理器执行时发生的异常 HandlerExceptionResolver 接口HandlerExceptionResolver 只有一个接口方法 1234public interface HandlerExceptionResolver &#123; ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex);&#125; resolveException 方法尝试解决在处理程序执行期间引发的异常，处理之后返回 ModelAndView，转到对应的视图作为异常报告反馈给用户 下面是可用的 HandlerExceptionResolver 实现： HandlerExceptionResolver 描述 SimpleMappingExceptionResolver 异常类名称和错误视图名称之间的映射，用于在浏览器应用程序中呈现错误页面 DefaultHandlerExceptionResolver 解决Spring MVC引发的异常，并将它们映射到HTTP状态代码 ResponseStatusExceptionResolver 使用@ResponseStatus注解解析异常，并根据注解中的值将它们映射到 HTTP 状态代码 ExceptionHandlerExceptionResolver 通过调用或类中的 @ExceptionHandler 方法来解决异常 Spring MVC 默认注册了这些内置异常解析器，用于支持 @ResponseStatus 注释异常和@ExceptionHandler方法 异常解析链spring mvc 异常处理类结构图 上图我们可以看到 AbstractHandlerExceptionResolver 实现了 Ordered 接口，这样形成了一个异常处理链，DispatcherServlet 把异常委托给 HandlerExceptionResolver 解析链以解决异常并提供替代处理。这个与视图解析器是相似的。 可以通过HandlerExceptionResolver 在Spring配置中声明多个bean并根据需要设置 order 属性来形成异常解析链。order 的值越高，异常解析器定位的越晚。 HandlerExceptionResolver 有三种返回情况： 处理后返回 ModelAndView 指向错误视图 如果异常在解析器中已经处理完，则返回空的 ModelAndView 返回 null，表明异常仍未解决，则由后续解析器继续处理，如果异常最后还在，则允许冒泡到Servlet容器 异常处理 直接实现 HandlerExceptionResolver 使用@ExceptionHandler注解 @ControllerAdvice+@ExceptionHandler 使用@ExceptionHandler注解@ExceptionHandler 方法是在 @Controller 和 @ControllerAdvice 类中定义的，用来处理来自控制器方法的异常 如果 @ExceptionHandler 方法是在控制器内部定义的，那么它会接收并处理由控制器（或其任何子类）中的 @RequestMapping 方法抛出的异常；如果是定义在 @ControllerAdvice 类中，那么它会处理相关控制器中抛出的异常 12345678910@Controllerpublic class SimpleController &#123; // ... @ExceptionHandler public ResponseEntity&lt;String&gt; handle(IOException ex) &#123; // ... &#125;&#125; @ExceptionHandler方法的方法参数和返回值可以很灵活。比如，在Servlet环境下方法可以接收HttpServletRequest参数。返回值可以是String类型（会被解析为视图名）、可以是ModelAndView类型的对象，也可以是ResponseEntity。 12345678910111213141516171819@Controllerpublic class SimpleController &#123; @ExceptionHandler(RuntimeException.class) public ModelAndView error(RuntimeException error, HttpServletRequest request) &#123; ModelAndView mav = new ModelAndView(); mav.setViewName("error"); mav.addObject("param", "Runtime error"); return mav; &#125; @ExceptionHandler() public ModelAndView error(Exception error, HttpServletRequest request, HttpServletResponse response) &#123; ModelAndView mav = new ModelAndView(); mav.setViewName("error"); mav.addObject("param", "Exception error"); return mav; &#125;&#125; @ExceptionHandler 只能处理同一个 Controller 里的异常，想要设置全局的异常处理，可把 @ExceptionHandler 方法写在一个 BaseController 里面，让其他 Controller 继承它。另外还可以使用 @ControllerAdvice+@ExceptionHandler @ControllerAdvice+@ExceptionHandler这里我们使用 @RestControllerAdvice ，相当于 @ControllerAdvice 和 @ResponseBody 同时处理 web 和 ajax 异常 1234567891011121314151617@RestControllerAdvicepublic class ExceptionHandle &#123; @ExceptionHandler public Object handle(HttpServletRequest request, HttpServletResponse response,Exception e)&#123; if(request.getHeader("X-Requested-With")!=null &amp;&amp;"XMLHttpRequest".equals(request.getHeader("X-Requested-With").toString()))&#123; return JSONResult.error(e.getMessage()); &#125;else&#123; ModelAndView mv = new ModelAndView(); mv.addObject("exception",e); mv.addObject("url",request.getRequestURL()); mv.setViewName("/error"); return mv; &#125; &#125;&#125; 容器错误页面如果异常最后未被任何 HandlerExceptionResolver 解决，并且因此将其传播或者如果响应状态设置为错误状态（即4xx，5xx），则Servlet容器可以在HTML中呈现默认错误页面。可以在 web.xml 中声明错误页面映射 web.xml123&lt;error-page&gt; &lt;location&gt;/error&lt;/location&gt;&lt;/error-page&gt; 12345678&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/resources/error/404.html&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/resources/error/500.html&lt;/location&gt;&lt;/error-page&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Mvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Mvc 视图解析]]></title>
    <url>%2Fblog%2Fspring-mvc-view-resolution%2F</url>
    <content type="text"><![CDATA[在 Spring Mvc 中，我们自己编写的控制器方法 (Controller) 并没有直接去渲染结果，使用 response 去输出到浏览器。方法返回的是 ModelAndView，甚至只是一个 String 类型的视图名，那 Spring Mvc 是怎么把模型数据填充到视图的呢？如果控制器能通过逻辑视图名来了解视图的话，那 Spring Mvc 如何确定使用哪一个视图实现来渲染模型呢? 了解视图解析解析过程 DispatcherServlet HandlerMapping HandlerAdapter ViewResolver View 对于控制器的方法，无论其返回值是 String、View、ModelMap 或是 ModelAndView，Spring MVC 都会在内部HandlerAdapter 将它们封装为一个 ModelAndView 对象再进行返回 123456public interface HandlerAdapter &#123; ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; ...&#125; 然后 Spring MVC 会借助视图解析器 ViewResolver 得到最终的视图对象 View 1234public interface ViewResolver &#123; //通过 viewname 解析 view View resolveViewName(String viewName, Locale locale) throws Exception;&#125; View 接口表示一个响应给用户的视图如 jsp 文件，pdf 文件，html 文件。getContentType 方法会返回视图的内容类型，render 方法接收模型以及 Servlet 的 request 和 response 对象，并将输出结果渲染到 response 中 123456789public interface View &#123; ... default String getContentType() &#123; return null; &#125; void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception;&#125; ViewResolver 实现下面是 Spring 中 ViewResolver 的一些实现 视图解析器 描述 AbstractCachingViewResolver 一个抽象的视图解析器类，提供了缓存视图的功能。通常视图在能够被使用之前需要经过准备。继承这个基类的视图解析器即可以获得缓存视图的能力 XmlViewResolver 接受使用与 Spring 的 XML bean工厂相同的 DTD 编写的 XML 配置文件。默认配置文件是 /WEB-INF/views.xml ResourceBundleViewResolver 将视图解析为资源bundle（一般为属性文件） UrlBasedViewResolver 直接根据视图的名称解析视图，视图的名称会匹配一个物理视图的定义 InternalResourceViewResolver UrlBasedViewResolver 的子类，将视图解析为 Web 应用的内部资源（一般为JSP） FreeMarkerViewResolver UrlBasedViewResolver 的子类，将视图解析为 FreeMarker 模板 ContentNegotiatingViewResolver 根据请求文件名或 Accept 标头解析视图，通过考虑客户端需要的内容类型来解析视图，委托给另外一个能够产生对应内容类型的视图解析器 视图解析重定向和转发 redirect: forward: 视图名称中使用前缀 redirect: 执行重定向，UrlBasedViewResolver(及其子类) 会认为这是一条需要重定向的指令，视图名称的其余部分是重定向URL。如果是转发的话，使用前缀 forward: 1234@RequestMapping("/index")public String index()&#123; return "redirect:index.jsp";&#125; 我们可以看一下 UrlBasedViewResolver 中的代码 1234567891011121314151617181920212223242526272829303132public class UrlBasedViewResolver extends AbstractCachingViewResolver implements Ordered &#123; ... @Override protected View createView(String viewName, Locale locale) throws Exception &#123; if (!canHandle(viewName, locale)) &#123; return null; &#125; // Check for special "redirect:" prefix. if (viewName.startsWith(REDIRECT_URL_PREFIX)) &#123; String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length()); RedirectView view = new RedirectView(redirectUrl, isRedirectContextRelative(), isRedirectHttp10Compatible()); String[] hosts = getRedirectHosts(); if (hosts != null) &#123; view.setHosts(hosts); &#125; return applyLifecycleMethods(REDIRECT_URL_PREFIX, view); &#125; // Check for special "forward:" prefix. if (viewName.startsWith(FORWARD_URL_PREFIX)) &#123; String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length()); InternalResourceView view = new InternalResourceView(forwardUrl); return applyLifecycleMethods(FORWARD_URL_PREFIX, view); &#125; // Else fall back to superclass implementation: calling loadView. return super.createView(viewName, locale); &#125; ...&#125; 使用 JSP 视图有一些视图解析器（如 ResourceBundleViewResolver）会直接将逻辑视图名映射为特定的 View 接口实现，而InternalResourceViewResolver 所采取的方式并不那么直接。它遵循一种约定，会在视图名上添加前缀和后缀，进而确定一个 Web 应用中视图资源的物理路径 123&lt;bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" p:prefix="/WEB-INF/jsp/" p:suffix=".jsp" /&gt; InternalResourceViewResolver 配置就绪之后，它就会将逻辑视图名解析为 JSP 文件路径。&quot;index&quot; 会被解析成 &quot;/WEB-INF/jsp/index.jsp&quot;，&quot;blog/index&quot; 会被解析成 &quot;/WEB-INF/jsp/blog/index.jsp&quot; 如果这些 JSP 使用 JSTL 标签来处理格式化和信息的话，那么我们会希望 InternalResourceViewResolver 将视图解析为 JstlView 1234&lt;bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" p:prefix="/WEB-INF/jsp/" p:suffix=".jsp" p:viewClass="org.springframework.web.servlet.view.JstlView" /&gt; 如下面的例子 &quot;index&quot; 会被解析成 &quot;/WEB-INF/jsp/index.jsp&quot;12345@RequestMapping("/index")public String index(String name,Model model)&#123; model.addAttribute("name",name); return "index";&#125; Freemarker 模板视图解析添加 maven 依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.28&lt;/version&gt;&lt;/dependency&gt; FreeMarker 配置和解析器配置 12345678910111213141516171819202122232425&lt;!-- FreeMarker 配置 --&gt;&lt;bean id="freeMarkerConfigurer" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;property name="templateLoaderPath" value="/" /&gt; &lt;property name="defaultEncoding" value="UTF-8" /&gt; &lt;property name="freemarkerSettings"&gt; &lt;props&gt; &lt;prop key="template_update_delay"&gt;10&lt;/prop&gt; &lt;prop key="locale"&gt;zh_CN&lt;/prop&gt; &lt;prop key="datetime_format"&gt;yyyy-MM-dd HH:mm:ss&lt;/prop&gt; &lt;prop key="date_format"&gt;yyyy-MM-dd&lt;/prop&gt; &lt;prop key="number_format"&gt;#.##&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- FreeMarker视图解析 --&gt;&lt;bean id="freeMarkerViewResolver" class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.freemarker.FreeMarkerView" /&gt; &lt;property name="contentType" value="text/html;charset=UTF-8" /&gt; &lt;property name="prefix" value="/ftl/" /&gt; &lt;property name="suffix" value=".ftl" /&gt; &lt;property name="exposeRequestAttributes" value="true" /&gt; &lt;property name="exposeSessionAttributes" value="true" /&gt; &lt;property name="exposeSpringMacroHelpers" value="true" /&gt;&lt;/bean&gt; Thymeleaf 模板视图解析 ThymeleafViewResolver：将逻辑视图名称解析为 Thymeleaf 模板视图 SpringTemplateEngine：处理模板并渲染结果 TemplateResolver：加载Thymeleaf模板 添加 maven 依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt; &lt;version&gt;3.0.11.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.11.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置 Thymeleaf12345678910111213141516&lt;bean id="templateResolver" class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver"&gt; &lt;property name="prefix" value="/templates/" /&gt; &lt;property name="suffix" value=".html" /&gt; &lt;property name="templateMode" value="HTML5" /&gt; &lt;property name="cacheable" value="false" /&gt; &lt;property name="characterEncoding" value="UTF-8"/&gt;&lt;/bean&gt;&lt;bean id="templateEngine" class="org.thymeleaf.spring5.SpringTemplateEngine"&gt; &lt;property name="templateResolver" ref="templateResolver" /&gt;&lt;/bean&gt;&lt;bean class="org.thymeleaf.spring5.view.ThymeleafViewResolver"&gt; &lt;property name="templateEngine" ref="templateEngine" /&gt; &lt;property name="characterEncoding" value="UTF-8" /&gt;&lt;/bean&gt; ThymeleafViewResolver 是 Spring MVC 中 ViewResolver 的实现类。它把接收的逻辑视图名称解析一个 Thymeleaf 模板视图 ThymeleafViewResolver bean 中注入了一个对 SpringTemplateEngine bean 的引用。SpringTemplateEngine 会在 Spring 中启用 Thymeleaf 引擎，用来解析模板，并基于这些模板渲染结果。 多视图解析处理当我们同时使用多种视图解析的时候，该如何解析呢？ 这里要分情况讨论了 多视图解析处理可以声明多个解析器，并在必要时通过设置 order 属性指定排序。order 属性值越高，视图解析器在链中的位置越晚。 一个 ViewResolver 是可以返回 null 的，表示无法找到该视图。如果一个视图解析器不能返回一个视图，那么 Spring 会继续检查上下文中其他的视图解析器。此时如果存在其他的解析器，Spring 会继续调用它们，直到产生一个视图返回为止。 但是 InternalResourceViewResolver 会执行调度 RequestDispatcher 来确定 jsp 是否存在。因此，必须把 InternalResourceViewResolver 在视图解析器链中的顺序设置为最后一个 12345678910111213141516171819202122232425262728293031323334&lt;!--jsp 视图解析--&gt;&lt;!-- 这里jsp的 order 要设置比freemarker的大，不然都会解析成 jsp --&gt;&lt;bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" p:prefix="/jsp/" p:suffix=".jsp" p:viewClass="org.springframework.web.servlet.view.JstlView" p:order="1" /&gt;&lt;!-- FreeMarker 配置 --&gt;&lt;bean id="freeMarkerConfigurer" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;property name="templateLoaderPath" value="/" /&gt; &lt;property name="defaultEncoding" value="UTF-8" /&gt; &lt;property name="freemarkerSettings"&gt; &lt;props&gt; &lt;prop key="template_update_delay"&gt;10&lt;/prop&gt; &lt;prop key="locale"&gt;zh_CN&lt;/prop&gt; &lt;prop key="datetime_format"&gt;yyyy-MM-dd HH:mm:ss&lt;/prop&gt; &lt;prop key="date_format"&gt;yyyy-MM-dd&lt;/prop&gt; &lt;prop key="number_format"&gt;#.##&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- FreeMarker视图解析 --&gt;&lt;bean id="freeMarkerViewResolver" class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.freemarker.FreeMarkerView" /&gt; &lt;property name="contentType" value="text/html;charset=UTF-8" /&gt; &lt;property name="prefix" value="/ftl/" /&gt; &lt;property name="suffix" value=".ftl" /&gt; &lt;property name="exposeRequestAttributes" value="true" /&gt; &lt;property name="exposeSessionAttributes" value="true" /&gt; &lt;property name="exposeSpringMacroHelpers" value="true" /&gt; &lt;property name="order" value="0"/&gt;&lt;/bean&gt; 这里jsp的 order 要设置比freemarker的大，不然都会解析成 jsp 以上的配置，假如逻辑视图名称为 test，它会先在 /ftl/ 下找 test.ftl 模板，找到就解析成 freemarker，没有就使用 jsp 解析器去找 jsp 文件 另外可以配置 viewNames 属性，对视图名称加以区分。（如 同时配置了 thymeleaf 和 jsp ） 配置 viewNames 属性，值可以使用通配符匹配，如&lt;property name=&quot;viewNames&quot; value=&quot;*.html,*.xhtml&quot; /&gt;&lt;property name=&quot;viewNames&quot; value=&quot;thymeleaf/*&quot; /&gt;&lt;property name=&quot;viewNames&quot; value=&quot;*.jsp&quot; /&gt; 内容协商ContentNegotiatingViewResolver 能根据请求文件名或Accept标头解析视图，通过考虑客户端需要的内容类型来解析视图，委托给另外一个能够产生对应内容类型的视图解析器 比如请求只是 accept-type 不同，如 /aa， HTTP Request Header 中的 Accept 分别是 text/jsp, text/pdf, text/xml,text/json, 无 Accept 请求头 ContentNegotiatingViewResolver 可以一个 @RequestMapping，返回多个不同的 View 123456789101112131415161718&lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt; &lt;property name="favorParameter" value="true"/&gt; &lt;property name="favorPathExtension" value="true"/&gt; &lt;property name="mediaTypes"&gt; &lt;map&gt; &lt;entry key="xml" value="application/xml"/&gt; &lt;entry key="json" value="application/json"/&gt; &lt;entry key="xls" value="application/vnd.ms-excel"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="viewResolvers"&gt; &lt;list&gt; &lt;ref bean="jaxb2MarshallingXmlViewResolver"&gt;&lt;/ref&gt; &lt;ref bean="jsonViewResolver"&gt;&lt;/ref&gt; &lt;ref bean="excelViewResolver"&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 自定义多视图解析器另外，还可以自定义多视图解析器，根据返回视图名称的后缀不同或是参数值不同分别委托给其他的视图解析器。这里就不介绍了 MVC 配置视图解析器MVC 配置简化了视图解析器的注册，需要使用 mvc 命名模式 以下示例使用 JSP 和 Jackson 来配置内容协商视图解析12345678910&lt;mvc:annotation-driven/&gt;&lt;mvc:view-resolvers&gt; &lt;mvc:content-negotiation&gt; &lt;mvc:default-views&gt; &lt;bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/&gt; &lt;/mvc:default-views&gt; &lt;/mvc:content-negotiation&gt; &lt;mvc:jsp/&gt;&lt;/mvc:view-resolvers&gt; 以下是 FreeMarker 的示例1234567891011121314&lt;mvc:annotation-driven/&gt;&lt;mvc:view-resolvers&gt; &lt;mvc:content-negotiation&gt; &lt;mvc:default-views&gt; &lt;bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/&gt; &lt;/mvc:default-views&gt; &lt;/mvc:content-negotiation&gt; &lt;mvc:freemarker cache="false"/&gt;&lt;/mvc:view-resolvers&gt;&lt;mvc:freemarker-configurer&gt; &lt;mvc:template-loader-path location="/freemarker"/&gt;&lt;/mvc:freemarker-configurer&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Mvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 快速入门]]></title>
    <url>%2Fblog%2Fspring-boot-quickstart%2F</url>
    <content type="text"><![CDATA[Spring Boot 简化了 Spring 应用的配置和开发，它管理着 Spring 容器和第三方插件，并提供很多默认系统级的服务，这样我们只要少量的配置和代码就能完成大部分 Spring 应用。 Spring Boot 的特性 可以创建独立的 Spring 应用，即可运行的 jar 包 提供嵌入式的 Web Server，不需要在部署 war 包 没有代码生成，也不需要XML配置 自动化配置，许多的配置都有习惯性的默认值 提供一系列生产级特性（例如嵌入式服务器，安全性，度量标准，运行状况检查和外部化配置） 开箱即用的 Spring 插件，“核心 + 插件” 的架构体系 快速入门完成一个简单的 web 应用，实现一个简单的 Http 请求处理，通过这个例子对 Spring Boot 有一个初步的了解，并体验其结构简单、开发快速的特性 创建 Maven 工程使用 IDE 创建一个简单 Maven 工程，然后在 pom 文件中添加 Spring Boot 的依赖。 要使用 Spring Boot，仅需 pom 文件继承自 spring-boot-starter-parent 项目，并添加一个或多个 “Starters” 的依赖(这里是web应用，添加 spring-boot-starter-web 依赖)1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo01&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 我们引入的依赖配置，只要 groupId 和 artifactId 即可，因为 version 已经在父 pom （spring-boot-starter-parent）中定义了 准备好 pom 之后，创建一个有 main 方法的类，并在类上添加注释123456@SpringBootApplication public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 快速创建 Spring Boot 项目另外创建 Spring Boot 项目还有更加便捷的方法 1、通过 Spring Initializr 工具产生基础项目 2、访问 https://start.spring.io/ 选择构建工具(Maven/Gradle)、Spring Boot版本以及一些工程基本信息 3、Generate Project 之后下载压缩包 4、解压压缩包，并使用 IDE 工具导入工程 如果是使用 IntelliJ IDEA 工具，可以直接新建 Spring Boot 工程 （eclipse 可以下载 spring tools 插件） 1、File &gt; New &gt; Project 中选择 Spring Initializr 2、创建的时候也可以直接选择需要的依赖项 3、创建的项目结构如下 pom 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 编写 Controller 服务创建 HelloController 类12345678@RestControllerpublic class HelloController &#123; @RequestMapping("/hello") public String hello()&#123; return "Hello World"; &#125;&#125; 此时，我们就可以启动 DemoApplication 程序了，直接运行，我们可以看到控制台信息 打开浏览器访问 http://localhost:8080/hello 可以看到输出 创建一个可执行的Jar要创建可执行jar，我们需要添加 spring-boot-maven-plugin 到我们的 pom.xml12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 可执行jar（有时称为“fat jar”）是包含已编译类以及代码需要运行的所有jar依赖项的归档]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Mvc 使用]]></title>
    <url>%2Fblog%2Fspring-mvc-flow-usage%2F</url>
    <content type="text"><![CDATA[Spring Mvc 是基于 Servlet API 构建的 Web 框架，围绕一个 DispatcherServlet 设计的，这个 Servlet 将请求分发给各个处理器，支持可配置的处理器映射、视图渲染、地区、时区和主题解析，以及对文件上传。默认处理程序基于 @Controller 和 @RequestMapping 注释，Spring 为处理器方法提供了极其多样灵活的配置。Spring 3.0以后提供了 @Controller 注解机制、@PathVariable 注解以及一些其他的特性，你可以使用它们来进行 RESTful web 站点和应用的开发。 Spring Mvc 的处理流程spring mvc 流程图 流程说明 用户发送请求至 前端控制器 DispatcherServlet DispatcherServlet 收到请求后调用处理器映射 HandlerMapping HandlerMapping 根据请求的 url 找到具体的处理器，生成处理器对象 Handler 及处理器拦截器HandlerIntercepter（如果有则生成）一并返回给前端控制器 DispatcherServlet DispatcherServlet 通过处理器适配器 HandlerAdapter 调用具体的处理器 Controller 处理器 Controller 执行完后返回模型和视图 ModelAnView DispatcherServlet 将 ModelAnView 传给视图解析器 ViewResolver，ViewResolver 解析后返回具体的视图 View 前端控制器 DispatcherServlet 对视图View进行渲染视图（将模型数据填充至视图中）并响应用户 DispatcherServletDispatcherServlet 要使用 Java 配置或在 web.xml 根据 Servlet 规范进行声明和映射。然后 DispatcherServlet 使用 Spring 配置来发现它需要的用于请求映射、视图解析、异常处理等的组件。12345678910111213141516171819202122232425262728&lt;web-app&gt; &lt;!-- 在启动Web容器时，自动装配spring的配置信息 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 需要加载的上下文配置文件路径 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:conf/spring/applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring-mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:conf/spring/applicationContext-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring-mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 在这里存在两个 contextConfigLocation，一个是给 ContextLoadrListener，一个是给 DispatcherServlet 都是用于加载上下文，一个是 Spring 的，一个是 SpringMVC 的，其中 ContextLoadrListener 先加载，然后才是DispatcherServlet。 DispatcherServlet 一般会加载 MVC 相关的 bean 配置管理(如: ViewResolver, Controller, MultipartResolver, ExceptionHandler) ContextLoaderListener 一般会加载整个 Spring 容器相关的 bean 配置管理(如: Log, Service, Dao, PropertiesLoader) 也就是如果我把 @Controller 的注解声明放到 ContextLoadrListener 中的配置文件去加载是不可以的，DispatcherServlet 到时对这个 controller 会无感知 DispatcherServlet 的上下文仅仅是 Spring MVC 的上下文，而 ContextLoaderListener 的上下文则对整个Spring都有效. 也就是 DispatcherServlet 可以使用 spring 的上下文，但是 Spring 不能使用 DispatcherServlet 的上下文，一般 Spring web 项目中同时会使用这两种上下文 url-pattern 路径匹配问题 路径匹配的优先级为 完全匹配（如：/test/test.do） 路径匹配 /* (如：/ 、/app/) 扩展名匹配 *.（如：.jsp 不能直接用 ``） 另外还有一个 / / 与 /* 的区别 /* 是路径匹配，像是模糊匹配，会匹配到该路径下所有的 URL 请求，包括带扩展名的文件如 *.jsp、*.css、*.js 等等 而 / 的优先级是低于扩展名匹配的，它只能匹配到如 /toIndex 这样的路径 使用注解的控制器Spring MVC 提供基于注释的编程模型，使用 @Controller 和 @RestController 注解标记控制器来表达请求映射，请求输入，异常处理等。带注解的控制器具有灵活的方法签名，不必扩展基类，也不必实现特定的接口 声明要使用 @Controller 和 @RestController 注解，你得要告诉 Spring Mvc 要扫描解析的位置，可以将组件扫描添加到 Java 配置中12345@Configuration@ComponentScan("com.example.web")public class WebConfig &#123; // ...&#125; 或者是在 Spring Mvc 的 bean 配置 xml 文件中声明组件扫描1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="com.example.web"/&gt; &lt;!-- ... --&gt;&lt;/beans&gt; @RestController 是 @Controller 和 @ResponseBody 的组合，相当于在这个控制器的每个方法上都注解了 @ResponseBody 请求映射@RequestMapping使用 @RequestMapping 注解能将请求映射到控制器的方法。可以在类级别使用它来表示共享映射，或者在方法级别使用它来缩小到特定的端点映射 另外还有与 HTTP方法匹配的映射注解： @GetMapping，@PostMapping，@PutMapping，@DeleteMapping，和 @PatchMapping。(@GetMapping 等效@RequestMapping(method=HttpMethod.GET）) 虽然默认情况下，@RequestMapping 与所有 HTTP 方法匹配，但大多数控制器方法应该映射到特定的 HTTP 方法而不是使用 @RequestMapping123456789101112131415@RestController@RequestMapping("/persons")class PersonController &#123; @GetMapping("/&#123;id&#125;") public Person getPerson(@PathVariable Long id) &#123; // ... &#125; @PostMapping @ResponseStatus(HttpStatus.CREATED) public void add(@RequestBody Person person) &#123; // ... &#125;&#125; 路径匹配请求路径还能使用 通配符 ? 匹配一个字符 * 匹配路径段中的零个或多个字符 ** 匹配零个或多个路径段 另外，还可声明 URI变量并通过 @PathVariable 访问它们的值1234@GetMapping("/owners/&#123;owner&#125;/pets/&#123;petId&#125;")public Pet findPet(@PathVariable("owner") Long ownerId, @PathVariable Long petId) &#123; // ...&#125; 其正则表达式的语法为{varName:regex} 处理控制器的方法]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Mvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 MyBatis-Plus 代码生成器]]></title>
    <url>%2Fblog%2Fmybatis-plus-code-generator%2F</url>
    <content type="text"><![CDATA[MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生 MyBatis-Plus 的目的是增强 MyBatis 的功能和操作，内置代码生成器可以为我们减少不少的工作量了，这里主要介绍 MyBatis-Plus 代码生成器的使用 代码生成器也是称作 MyBatis 的逆向工程，主要是用来生成 model、mapper 等层的代码，MyBatis 官方也有一个 MyBatis-Generator 的逆向工程，功能非常强大，但生成的代码比较臃肿，生成的 Example 类用于构造复杂的筛选条件，使用起来不友好。相比起来 MyBatis-Plus 生成的代码简洁优雅，配合 CRUD 接口和条件构造器，使用起来也方便 代码生成器添加依赖代码生成器的依赖12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt; MyBatis-Plus 3.0.3 之后移除了自动模板引擎依赖，需要手动添加对应引擎的依赖坐标1234567891011121314151617181920&lt;!-- velocity 模板引擎, 默认 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt;&lt;!-- freemarker 模板引擎 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt;&lt;!-- beetl 模板引擎 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.ibeetl&lt;/groupId&gt; &lt;artifactId&gt;beetl&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt; 生成代码AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124public class Generator &#123; /** * &lt;p&gt; * 读取控制台内容 * &lt;/p&gt; */ private static String scanner(String tip) &#123; Scanner scanner = new Scanner(System.in); System.out.println("请输入" + tip + "："); if (scanner.hasNext()) &#123; String ipt = scanner.next(); if (StringUtils.isNotEmpty(ipt)) &#123; return ipt; &#125; &#125; throw new MybatisPlusException("请输入正确的" + tip + "！"); &#125; public static void main(String[] args) &#123; // 代码生成器 AutoGenerator mpg = new AutoGenerator(); // 全局策略配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty("user.dir"); gc.setOutputDir(projectPath + "/src/main/java"); // 生成文件的输出目录,默认D根目录 gc.setFileOverride(true); // 是否覆盖已有文件 gc.setAuthor("zou"); gc.setOpen(false); // 是否打开输出目录,默认true gc.setEnableCache(true); // 是否在xml中添加二级缓存配置,默认false gc.setSwagger2(true); // 开启 swagger2 模式,默认false gc.setEntityName("%sModel"); gc.setMapperName("%sMapper"); gc.setXmlName("%sMapper"); gc.setServiceName("I%sService"); gc.setServiceImplName("%sServiceImpl"); gc.setControllerName("%sController"); mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); Properties properties = new Properties(); try &#123; properties.load(new FileInputStream(projectPath + "/src/main/resources/generator.properties")); dsc.setUrl(properties.getProperty("generator.jdbc.url")); // dsc.setSchemaName("public"); dsc.setDriverName(properties.getProperty("generator.jdbc.driver")); dsc.setUsername(properties.getProperty("generator.jdbc.username")); dsc.setPassword(properties.getProperty("generator.jdbc.password")); mpg.setDataSource(dsc); &#125; catch (IOException e) &#123; throw new RuntimeException("数据源配置错误", e); &#125; // 包名配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(scanner("模块名")); pc.setParent("com.shiyu"); pc.setEntity("model"); mpg.setPackageInfo(pc); // 自定义配置 InjectionConfig cfg = new InjectionConfig() &#123; @Override public void initMap() &#123; // to do nothing &#125; &#125;; // 如果模板引擎是 freemarker // String templatePath = "/templates/mapper.xml.ftl"; // 如果模板引擎是 velocity String templatePath = "/templates/mapper.xml.vm"; // 自定义输出配置 List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;(); // 自定义配置会被优先输出 focList.add(new FileOutConfig(templatePath) &#123; @Override public String outputFile(TableInfo tableInfo) &#123; // 自定义输出文件名 return projectPath + "/src/main/resources/mapper/" + pc.getModuleName() + "/" + tableInfo.getEntityName() + "Mapper" + StringPool.DOT_XML; &#125; &#125;); cfg.setFileOutConfigList(focList); mpg.setCfg(cfg); // 配置模板 TemplateConfig templateConfig = new TemplateConfig(); // 配置自定义输出模板 // templateConfig.setEntity(); // templateConfig.setService(); // templateConfig.setController(); templateConfig.setXml(null); mpg.setTemplate(templateConfig); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); // 数据库表映射到实体的命名策略 strategy.setColumnNaming(NamingStrategy.underline_to_camel); // 数据库表字段映射到实体的命名策略, 未指定按照 naming 执行 // strategy.setSuperEntityClass("com.shiyu.BaseEntity"); //自定义继承的Entity类全称，带包名 // strategy.setSuperEntityColumns(new String[] &#123;"id","gmtCreate","gmtModified"&#125;);// 自定义基础的Entity类，公共字段 strategy.setEntityLombokModel(true); // 是否为lombok模型 strategy.setEntityBooleanColumnRemoveIsPrefix(true); // Boolean类型字段是否移除is前缀 strategy.setRestControllerStyle(true); // 生成 @RestController 控制器 // strategy.setSuperControllerClass("com.baomidou.ant.common.BaseController"); // strategy.setInclude("upms_user"); //包含的表名 strategy.setExclude("upms_role"); // 排除的表名 strategy.setControllerMappingHyphenStyle(true); // 驼峰转连字符 如 umps_user 变为 upms/user strategy.setTablePrefix(pc.getModuleName() + "_"); // 表前缀 mpg.setStrategy(strategy); // mpg.setTemplateEngine(new FreemarkerTemplateEngine()); //设置模板引擎类型，默认为 velocity // mpg.setTemplateEngine(new FreemarkerTemplateEngine()); // 切换为 freemarker 模板引擎 // mpg.setTemplateEngine(new BeetlTemplateEngine()); //切换为 beetl 模板引擎 mpg.execute(); &#125;&#125;]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>MyBatis-Plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 发送邮件实现（JavaMail 和 Spring 实现）]]></title>
    <url>%2Fblog%2Fjava-mail-javamail-spring%2F</url>
    <content type="text"><![CDATA[Java 实现邮件的发送，使用 JavaMail 和 Spring 实现 使用 JavaMailJavaMail 是 Java 处理电子邮件相关的编程接口，但是没有被加在标准的 Java 开发工具包中（Java Development Kit），所以我们使用 JavaMail 需要另外下载依赖包 javax.mail.jar 包实现了 SMTP、IMAP 和 POP3 协议 12345&lt;dependency&gt; &lt;groupId&gt;com.sun.mail&lt;/groupId&gt; &lt;artifactId&gt;javax.mail&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt;&lt;/dependency&gt; 发送一个简单邮件下面是用 qq 邮箱发送一个简单的纯文本邮件的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class SentSimpleMail &#123; private static final String MAIL_HOST = "smtp.qq.com"; // 发送邮件的主机 private static final String FROM = "827952316@qq.com"; // 发件人邮箱地址 /** * 用qq邮箱发送一个简单邮件 * * @param subject * @param text * @param toRecipients 接收邮件，逗号分隔 * @throws AddressException * @throws MessagingException */ public void sentSimpleMail(String subject, String text, String toRecipients) throws AddressException, MessagingException &#123; /* * 初始化JavaMail会话 */ Properties props = System.getProperties(); // 获得系统属性配置，用于连接邮件服务器的参数配置 props.setProperty("mail.smtp.host", MAIL_HOST); // 发送邮件的主机 props.setProperty("mail.smtp.auth", "true"); Session session = Session.getInstance(props, null);// 获得Session对象 session.setDebug(true); // 设置是否显示debug信息,true 会在控制台显示相关信息 /* * 创建邮件消息，发送邮件 */ Message message = new MimeMessage(session); message.setFrom(new InternetAddress(FROM)); // To: 收件人 // message.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress(toRecipient)); message.setRecipients(MimeMessage.RecipientType.TO, InternetAddress.parse(toRecipients, false)); // To: 增加收件人（可选） // message.addRecipient(MimeMessage.RecipientType.TO, new InternetAddress(toRecipient); // Cc: 抄送（可选） // message.setRecipient(MimeMessage.RecipientType.CC, new InternetAddress(ccRecipient)); // Bcc: 密送（可选） // message.setRecipient(MimeMessage.RecipientType.BCC, new InternetAddress(bccRecipient)); message.setSubject(subject); // 邮件标题 message.setText(text); // 邮件内容 // 简单发送邮件的方式 Transport.send(message, FROM, "xxxxxxxxxxx"); // 授权码 &#125; public static void main(String[] args) throws AddressException, MessagingException &#123; new SentSimpleMail().sentSimpleMail("标题", "邮件内容", "827952316@qq.com"); &#125;&#125; 授权 如果需要提供用户名和密码给 e-mail 服务器来达到用户认证的目的，需要另外添加授权信息123props.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;);props.setProperty(&quot;mail.user&quot;, &quot;$&#123;user&#125;&quot;);props.setProperty(&quot;mail.password&quot;, &quot;$&#123;password&#125;&quot;); 或者在发送的时候加上用户和授权码，如1Transport.send(message, FROM, &quot;xxxxxxxxxxx&quot;); // 授权码 如在使用 qq 邮箱发送邮件需要获取授权码，在邮箱的“设置-账户”中设置 发送基于 HTML 内容的邮件发送邮件的内容为 HTML 时，需要把 Mimemessage 的 ContentType 设为 “text/html”1message.setDataHandler(new DataHandler( new ByteArrayDataSource("&lt;h1&gt;This is html message&lt;/h1&gt;", "text/html"))); 或者1message.setContent("&lt;h1&gt;This is html message&lt;/h1&gt;", "text/html" ); 带有附件的邮件 MimeMessage 继承Message，表示整封邮件 MimeBodyPart 表示邮件的一个MIME消息 MimeMultipart 表示一个由多个MIME消息组合成的组合MIME消息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class SendMail &#123; public void sendMail(String subject, String text, String toRecipients) throws AddressException, MessagingException, IOException &#123; String host = "smtp.qq.com"; // 发送邮件的主机 String from = "827952316@qq.com"; // 发件人邮箱地址 /* * 初始化JavaMail会话 */ Properties props = System.getProperties(); // 获得系统属性配置，用于连接邮件服务器的参数配置 props.setProperty("mail.smtp.host", host); // 发送邮件的主机 props.setProperty("mail.smtp.auth", "true"); props.setProperty("mail.user", from); props.setProperty("mail.password", "xxxxxxxxxxxxxxx"); //密码或者授权码 Session session = Session.getInstance(props, null);// 获得Session对象 session.setDebug(true); // 设置是否显示debug信息,true 会在控制台显示相关信息 /* * 创建邮件消息，发送邮件 */ Message message = new MimeMessage(session); message.setFrom(new InternetAddress(from)); message.setRecipients(MimeMessage.RecipientType.TO, InternetAddress.parse(toRecipients, false)); message.setSubject(subject); // 邮件标题 //创建多重消息 MimeMultipart mp = new MimeMultipart(); // 文本部分 MimeBodyPart textPart = new MimeBodyPart(); textPart.setText(text); // 附件部分 MimeBodyPart filePart = new MimeBodyPart(); filePart.attachFile("D:/0.jpeg"); filePart.setFileName("0.jpeg"); mp.addBodyPart(textPart); mp.addBodyPart(filePart); message.setContent(mp); Transport.send(message); &#125; public static void main(String[] args) throws AddressException, MessagingException, IOException &#123; new SendMail().sendMail("标题", "邮件内容", "827952316@qq.com"); &#125;&#125; 使用 Spring 发送邮件在 Spring 中，关于邮件(JavaMail)的集成 API 是在 spring-context-supprot 中的 org.springframework.mail 包中，需要 JavaMail 的类库支持。 MailSender 是发送电子邮件的核心接口。SimpleMailMessage 类封装了简单的邮件属性(例如 from 和 to )的简单值 基本用法MailSender 和 SimpleMailMessage 的用法使用 MailSender 和 SimpleMailMessage 来发送邮件12345678910111213141516171819202122232425262728@Componentpublic class SendMailManagerImpl implements SendMailManager &#123; @Autowired private MailSender mailSender; @Autowired private SimpleMailMessage templateMessage; @Override public void sendMail(String[] to) &#123; // SimpleMailMessage SimpleMailMessage msg = new SimpleMailMessage(this.templateMessage); msg.setTo(to);//接收人 msg.setText("邮件内容"); //这里的邮件内容是 文本类型 // msg.setCc(cc);// 抄送 // msg.setBcc(bcc);// 密送 // msg.setReplyTo(replyTo);// 回复 // msg.setSentDate(new Date());// 发送时间 // msg.setSubject(subject);// 主题 // msg.setFrom(from);// 发送人 try&#123; this.mailSender.send(msg); &#125; catch (MailException ex) &#123; System.out.println(ex.getMessage()); &#125; &#125;&#125; 我们在 xml 中配置 MailSender 和 模板消息123456789101112&lt;bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl"&gt; &lt;property name="host" value="smtp.qq.com" /&gt; &lt;!-- 如果需要账号密码授权 --&gt; &lt;property name="username" value="827952316@qq.com"/&gt; &lt;property name="password" value="xxxxxxxxxxxxxxxx"/&gt;&lt;/bean&gt; &lt;!-- 可以做一个模板，把邮件的通用内容放到这里 --&gt;&lt;bean id="templateMessage" class="org.springframework.mail.SimpleMailMessage"&gt; &lt;property name="from" value="827952316@qq.com" /&gt; &lt;property name="subject" value="统一标题" /&gt;&lt;/bean&gt; 使用 JavaMailSender 和 MimeMessagePreparator上面的例子是利用了 Spring 所封装的 SimpleMailMessage 类。不过 Spring 框架的邮件支持也附带了标准 JavaMail 实现，JavaMailSender 类可以使用 JavaMail 的 MimeMessage 类12345678910111213141516171819202122232425262728@Componentpublic class SendMailManagerImpl2 implements SendMailManager &#123; @Autowired private JavaMailSender mailSender; public void sendMail(String[] to) &#123; MimeMessagePreparator preparator = (MimeMessage mimeMessage) -&gt; &#123; Arrays.asList(to).stream().forEach(x -&gt; &#123; try &#123; mimeMessage.setRecipient(Message.RecipientType.TO, new InternetAddress(x)); &#125; catch (MessagingException e) &#123; System.err.println(e.getMessage()); &#125; &#125;); mimeMessage.setFrom(new InternetAddress("827952316@qq.com")); mimeMessage.setText("邮件内容"); &#125;; try &#123; this.mailSender.send(preparator); &#125; catch (MailException ex) &#123; System.err.println(ex.getMessage()); &#125; &#125;&#125;` 使用 MimeMessageHelper 处理 JavaMail 消息使用 MimeMessageHelper 可以很方便的创建处理 JavaMail 的 MimeMessage 对象123456789JavaMailSenderImpl sender = new JavaMailSenderImpl();sender.setHost("smtp.qq.com");MimeMessage message = sender.createMimeMessage();MimeMessageHelper helper = new MimeMessageHelper(message);helper.setTo("test@qq.com");helper.setText("邮件内容");sender.send(message); 当我们想要邮件有附件和内联资源的时候，使用 MimeMessageHelper 就很方便了 发送带有附件和内联资源的邮件我们发送邮件通常会需要有附件或者是内联资源（比如，内嵌的图片），在创建这些相当复杂的邮件，SimpleMailMessage 就不好用了，使用 MimeMessageHelper 帮我们创建 MimeMessage 对象1234567891011121314151617181920212223242526272829303132@Componentpublic class SendMailManagerImpl3 implements SendMailManager &#123; @Autowired private JavaMailSender mailSender; public void sendMail(String[] to) &#123; MimeMessage message = mailSender.createMimeMessage(); try &#123; // 使用 true 表示要创建一个有多部分的邮件 MimeMessageHelper helper = new MimeMessageHelper(message, true, "utf-8"); helper.setFrom("827952316@qq.com"); helper.setTo(to); // 使用 true 表示邮件内容为 HTML，在这里引用内联资源 图片 helper.setText("&lt;html&gt;&lt;body&gt;&lt;h1&gt;邮件内容&lt;/h1&gt;&lt;img src='cid:inlineImg'/&gt;&lt;/body&gt;&lt;/html&gt;", true); // 添加附件 FileSystemResource file = new FileSystemResource(new File("D:/0.jpeg")); helper.addAttachment("CoolImage.jpeg", file); // 添加内联资源（在html中引用） FileSystemResource res = new FileSystemResource(new File("D:/0.jpeg")); helper.addInline("inlineImg", res); this.mailSender.send(message); &#125; catch (MailException | MessagingException ex) &#123; System.err.println(ex.getMessage()); &#125; &#125;&#125; 使用内联资源的时候要指定 Content-ID，MimeMessage在邮件内容中添加。添加文本和资源的顺序非常重要。要先添加文本，然后再添加资源 使用模板创建邮件通常我们在使用代码创建邮件是都不会是简单的纯文本邮件，在使用Java代码创建基于HTML的电子邮件内容非常繁琐且容易出错，而且更改电子邮件内容的显示结构需要编写Java代码，重新编译，重新部署 使用模板是可以解决这些问题的，使用模板库（例如FreeMarker、Velocity、Thymeleaf）来定义电子邮件内容的显示结构。从 Spring 4.3 之后，Velocity支持已被弃用。这里我们使用 FreeMaker 模板发送邮件做个例子 首先我们添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.28&lt;/version&gt;&lt;/dependency&gt; 配置 beanFreeMarker 配置123456789101112131415&lt;!-- web项目中 --&gt;&lt;!-- &lt;bean id="freeMarkerConfigurer" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;property name="templateLoaderPath" value="/WEB-INF/config/template/" /&gt; &lt;property name="freemarkerSettings"&gt; &lt;props&gt; &lt;prop key="template_update_delay"&gt;1800&lt;/prop&gt;模板更新延时 &lt;prop key="default_encoding"&gt;UTF-8&lt;/prop&gt; &lt;prop key="locale"&gt;zh_CN&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; --&gt;&lt;!-- 非web --&gt;&lt;bean id="freeMarkerConfiguration" class="org.springframework.ui.freemarker.FreeMarkerConfigurationFactoryBean"&gt; &lt;property name="templateLoaderPath" value="classpath:template/ftl/" /&gt;&lt;/bean&gt; 通过模板获得邮件内容FreeMarker 模板 user.ftl1234567&lt;html&gt; &lt;body&gt; &lt;h3&gt;username: $&#123;user.username&#125;&lt;/h3&gt; &lt;p&gt;password : $&#123;user.password&#125;&lt;/p&gt; &lt;span&gt;Sent using FreeMarker Template&lt;/span&gt; &lt;/body&gt;&lt;/html&gt; 使用 FreeMarker 模板获得邮件内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Componentpublic class TemplateManagerImpl implements SendMailManager &#123; @Autowired private JavaMailSender mailSender; @Autowired private Configuration freeMarkerConfiguration; @Override public void sendMail(String[] to,User user) &#123; MimeMessage message = mailSender.createMimeMessage(); try &#123; // 使用 true 表示要创建一个有多部分的邮件 MimeMessageHelper helper = new MimeMessageHelper(message, true, "utf-8"); helper.setFrom("827952316@qq.com"); helper.setTo(to); helper.setSubject("标题"); //获取模板 Map&lt;String, Object&gt; model = new HashMap&lt;String, Object&gt;(); model.put("user", user); String text = geFreeMarkerTemplateContent(model); // 使用 true 表示邮件内容为 HTML helper.setText(text, true); this.mailSender.send(message); &#125; catch (MailException | MessagingException ex) &#123; System.err.println(ex.getMessage()); &#125; &#125; /** * 获得模板内容 * @param model * @return */ private String geFreeMarkerTemplateContent(Map&lt;String, Object&gt; model) &#123; String content = null; try &#123; content = FreeMarkerTemplateUtils.processTemplateIntoString(freeMarkerConfiguration.getTemplate("user.ftl"), model); &#125; catch (Exception e) &#123; System.err.println(e.getMessage()); &#125; return content; &#125;&#125; 邮件如下]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>JavaMail</tag>
        <tag>邮件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Lambda 表达式使用]]></title>
    <url>%2Fblog%2Fjava-lambda-usage%2F</url>
    <content type="text"><![CDATA[Java8 引入了 Lambda 表达式，使用 Lambda 表达式可以让代码更加简洁。Lambda 表达式其实也就是一个匿名函数，我们可以用它去代替匿名函数，我们先来看一个例子 Lambda 表达式语法我们用接口 Runnable 举个例子123456789101112public static void main(String[] args) &#123; // 匿名函数 new Thread(new Runnable() &#123; public void run() &#123; System.out.println("anonymous function"); &#125; &#125;).start(); // lambda 表达式 new Thread(() -&gt; System.out.println("lambda")).start();&#125; 从上的例子可以看出我们使用 () -&gt; {} 的代码块代替了整个匿名函数 Lambda 表达式的语法格式如下 （ parameters ) -&gt; expression （ parameters ) -&gt; {statements;} 可以不需要声明参数类型，编译器可以统一识别参数值。 一个参数时可以不定义圆括号，但多个参数需要定义圆括号。 如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值（如果接口方法返回类型为 void 则不用）。 Lambda 表达式的简单例子1234567891011121314// 无参数,返回值为 10() -&gt; 10 // 单参数(数字类型),返回其2倍的值 x -&gt; 2 * x // 多个参数(数字),并返回他们的差值 (x, y) -&gt; x – y // 声明参数类型,返回他们的和 (int x, int y) -&gt; return x + y // 声明参数类型,并在控制台打印,不返回任何值(接口方法返回类型为 void) (String s) -&gt; System.out.print(s) Lambda 行为参数化和变量作用域我们可以将 lambda 表达式作为参数传递给方法，也就是说允许把函数作为一个方法的参数。 创建一个 Calculator 的函数接口。 在 Calculator 中有一个称为 calculate 的方法，它接受两个 int 参数并返回一个 int 值。在 engine 方法中，它接受函数接口 Calculator 作为参数。在主方法中，用不同的lambda表达式调用 engine 方法四次1234567891011121314151617181920public class LambdaTest &#123; public static void main(String[] argv) &#123; engine((x, y) -&gt; x + y); engine((x, y) -&gt; x * y); engine((x, y) -&gt; x / y); engine((x, y) -&gt; x % y); &#125; private static void engine(Calculator calculator) &#123; int x = 2, y = 4; int result = calculator.calculate(x, y); System.out.println(result); &#125;&#125;@FunctionalInterfaceinterface Calculator &#123; int calculate(int x, int y);&#125; lambda 表达式不定义自己的范围。如果我们在 lambda 中使用关键字 this 和 super，this 代表着 lambda 表达式所被包含的类 变量作用域 lambda 表达式与其外部方法具有相同的范围。 lambda表达式不会创建自己的作用域。 lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。123456789public static void main(String args[]) &#123; final int num = 1; Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num)); s.convert(2); // 输出结果为 3&#125; public interface Converter&lt;T1, T2&gt; &#123; void convert(int i);&#125; lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）12345int num = 1; Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));s.convert(2);num = 5; // Local variable num defined in an enclosing scope must be final or effectively final 在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量12String first = &quot;&quot;; Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length()); //编译会出错 函数式接口函数式接口只是具有一个方法的接口，用作 lambda 表达式的类型。通常会使用 @FunctionalInterface 注解来标注了函数式接口 在 java8 中为我们定义了很多常用的函数式接口，它们都放在java.util.function包下面,一般有以下常用的四大核心接口 函数式接口 参数类型 返回类型 描述 Consumer(消费型接口) T void 对类型为T的对象应用操作。void accept(T t) Supplier(供给型接口) 无 T 返回类型为T的对象。 T get(); Function&lt;T, R&gt;(函数型接口) T R 对类型为T的对象应用操作并返回R类型的对象。R apply(T t); Predicate(断言型接口) T boolean 确定类型为T的对象是否满足约束。boolean test(T t); 方法引用方法引用通过方法的名字来指向一个方法。 方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 方法引用使用一对冒号 :: 构造函数引用使用构造函数引用的语法是 ClassName::new123Function&lt;String,String&gt; func1 = str -&gt; new String(str);Function&lt;String,String&gt; func2 = String::new; 静态方法引用方法引用的一般语法是 Qualifier::MethodName123Function&lt;Integer, String&gt; func1 = x -&gt; Integer.toBinaryString(x);Function&lt;Integer, String&gt; func2 = Integer::toBinaryString; 实例方法引用123Supplier&lt;Integer&gt; supplier = () -&gt; "www.w3cschool.cn".length(); Supplier&lt;Integer&gt; supplier1 = "www.w3cschool.cn"::length; 通用方法引用123Function&lt;String[],List&lt;String&gt;&gt; asList = Arrays::&lt;String&gt;asList; System.out.println(asList.apply(new String[]&#123;"a","b","c"&#125;));]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Maven 运行 Mybatis-Generator]]></title>
    <url>%2Fblog%2Fmybatis-generator%2F</url>
    <content type="text"><![CDATA[使用 MyBatis 的时候，我们要花大量的时间在写 mapper 映射文件的sql。MyBatis Generator 是 MyBatis 的代码生成器，可以帮我们去生成 Model、Dao、Mapper 和映射的 sql，节省不少时间 这里介绍使用 maven 插件方式去使用 MyBatis Generator 1、首先先 pom.xml 添加 mybatis-generator 插件配置1234567891011121314151617181920&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.13&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/plugin&gt; 2、创建 Mybatis Generator XML配置文件 generatorConifg.xml，配置文件是来告诉生成器连接数据库的信息，要生成哪些对象，又要为哪些表生成对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 导入属性配置 --&gt; &lt;properties resource="conf/database.properties"&gt;&lt;/properties&gt; &lt;!-- 指定数据库的jdbc驱动程序的位置，如果在pom中指定了依赖，这里可以不用 --&gt; &lt;!-- &lt;classPathEntry location="$&#123;jdbc.driverLocation&#125;" /&gt; --&gt; &lt;!-- context 用于指定生成对象的配置 --&gt; &lt;!-- targetRuntime：设置生成的文件适用于那个 mybatis 版本 --&gt; &lt;context id="default" targetRuntime="MyBatis3"&gt; &lt;!-- optional, 用于为MBG生成的各种元素生成注释 --&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true" /&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 (默认) --&gt; &lt;property name="suppressAllComments" value="false" /&gt; &lt;property name="addRemarkComments" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!-- jdbc的数据库连接 --&gt; &lt;jdbcConnection driverClass="$&#123;jdbc.driver&#125;" connectionURL="$&#123;jdbc.url&#125;" userId="$&#123;jdbc.username&#125;" password="$&#123;jdbc.password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;!-- optional，类型处理器，在数据库类型和java类型之间的转换控制 --&gt; &lt;javaTypeResolver&gt; &lt;!-- 默认情况下数据库中的 decimal，bigInt 在 Java 对应是 BigDecimal 类 --&gt; &lt;!-- 比例大于零，或者长度大于18，使用BigDecimal --&gt; &lt;!-- 使用常用的基本类型代替 sql 包下的引用类型 --&gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- 用于定义Java模型生成器的属性。targetPackage：生成的实体类所在的包；targetProject：生成的实体类所在的项目和源文件夹 --&gt; &lt;javaModelGenerator targetPackage="com.brave.model" targetProject=".\src\main\java"&gt; &lt;!-- 针对数据库的一个配置，是否把 schema 作为字包名 默认false --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;!-- 是否对modal添加构造函数， 默认false --&gt; &lt;property name="constructorBased" value="true" /&gt; &lt;!-- 是否清理从数据库中查询出的字符串左右两边的空白字符，默认false --&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;!-- 建立modal对象是否不可改变 即生成的modal对象不会有setter方法，只有构造方法，默认false --&gt; &lt;property name="immutable" value="false" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- 用于定义SQL映射生成器的属性。targetPackage 和 targetProject：生成的 mapper 文件的包和位置 --&gt; &lt;sqlMapGenerator targetPackage="mappers" targetProject=".\src\main\resources"&gt; &lt;!-- 针对数据库的一个配置，是否把 schema 作为字包名，默认false --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage 和 targetProject：生成的 interface 文件的包和位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.brave.dao" targetProject=".\src\main\java"&gt; &lt;!-- 针对 oracle 数据库的一个配置，是否把 schema 作为字包名 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写 --&gt; &lt;table tableName="upms_user" domainObjectName="UpmsUser"&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 3、执行 maven 命令是 mvn mybatis-generator:generate 如果是用 idea 工具在Maven Porjects中点击插件，执行就好了 如果是用 eclipse，点击 maven build…，goals中填入mybatis-generator:generate 运行]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Mybatis-Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 的插件应用：分页处理（分页插件 PageHelper）]]></title>
    <url>%2Fblog%2Fmybatis-custom-plugin-pagehelper%2F</url>
    <content type="text"><![CDATA[MyBatis 框架虽然使用起来相当简单，且灵活，自己管理着 sql 语句，但是开发起来还是有着不少的工作量，比如在处理分页问题的时候，我们通常需要另外再查询一次总共的记录数 其实我们是希望把获取分页信息的工作给统一起来，简洁代码，减少工作量 我们可以利用 MyBatis 的插件功能（拦截器）来处理分页，这里我们尝试着自己去写一个简单的分页插件，后面也有介绍一个优秀的 MyBatis 分页插件 PageHelper 的使用方法 自定义一个简单的分页插件在 mybatis xml 配置文件中，我们可以配置插件（plugins），MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用，这样我们可以通过拦截查询方法，添加分页查询条件，包装查询结果 创建一个插件通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可12345678910111213141516171819202122232425262728293031323334353637383940/* * 指定方法签名： * 下面的配置表面 将会拦截在 Executor 实例中所有的 “query” 方法调用， * 这里的 Executor 是负责执行低层映射语句的内部对象 */@Intercepts(&#123;@Signature( type = Executor.class, method = "query", args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)public class PageInterceptor implements Interceptor &#123; /** * 拦截目标对象中目标方法的执行 */ @Override public Object intercept(Invocation invocation) throws Throwable &#123; //TODO 覆盖目标方法，我们在这里覆盖目标方法 // 执行目标方法，并返回结果（这里没有处理） return invocation.proceed(); &#125; /** * 包装目标对象,即为目标对象创建一个代理对象 */ @Override public Object plugin(Object target) &#123; // 借助 Plugin 的 wrap(Object target,Interceptor interceptor); 包装我们的目标对象 // target: 目标对象, interceptor: 拦截器, this 表示使用当前拦截器 return Plugin.wrap(target, this); &#125; /** * 获取插件注册时，传入的property属性 */ @Override public void setProperties(Properties properties) &#123; // TODO &#125;&#125; 同时在 MyBatis 的配置文件中注册插件1234&lt;plugins&gt; &lt;plugin interceptor="com.brave.interceptor.PageInterceptor"&gt; &lt;/plugin&gt; &lt;/plugins&gt; 上面的只是先创建了一个拦截器，还没有做具体的处理，现在我们先理清楚需要做的事情 拦截查询的目标方法，通过 Invocation 参数获取目标方法原来的参数信息 因为是分页查询，需要传入分页的参数条件，将通过是否传入有效的分页参数来判断是否要进行分页处理 除了要执行原本的查询语句，还要查询count总记录数，并计算出其他分页信息 将查询出来的结果和分页信息包装在一起并返回结果 创建接口和返回结果集查询的时候，我们需要传入分页条件，这里我们创建一个 IPage 接口，为了规范统一12345678910111213141516171819202122public interface IPage &#123; /** * 当前页 */ Integer getPageNum(); /** * 每页数量 */ Integer getPageSize(); /** * 开始行 */ Integer getStartRow(); /** * 排序条件 */ String getOrderBy();&#125; 并实现一个简单类 PageConfig.java1234567891011121314151617181920212223242526272829303132333435363738394041public class PageConfig implements IPage &#123; private Integer pageNum; private Integer pageSize; private Integer startRow; private String orderBy; public PageConfig() &#123; this(1,10); &#125; public PageConfig(Integer pageNum,Integer pageSize) &#123; this.pageNum = pageNum; this.pageSize = pageSize; this.startRow = (this.pageNum -1) * this.pageSize; &#125; public Integer getPageNum() &#123; return pageNum; &#125; public void setPageNum(Integer pageNum) &#123; this.pageNum = pageNum; this.startRow = (this.pageNum -1) * this.pageSize; &#125; public Integer getPageSize() &#123; return pageSize; &#125; public void setPageSize(Integer pageSize) &#123; this.pageSize = pageSize; this.startRow = (this.pageNum -1) * this.pageSize; &#125; public String getOrderBy() &#123; return orderBy; &#125; public void setOrderBy(String orderBy) &#123; this.orderBy = orderBy; &#125; public Integer getStartRow() &#123; return startRow; &#125; public void setStartRow(Integer startRow) &#123; this.startRow = startRow; &#125;&#125; 同时我们需要包装一下返回结果集，MyBatis 直接查询返回的结果集类型为 ArrayList，我们要在此基础上加上分页信息 Page.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Page&lt;E&gt; extends ArrayList&lt;E&gt; &#123; private static final long serialVersionUID = 1L; private int pageNum; // 页码 private int pageSize; // 每页数量 private long total; // 总记录数 private int pages; // 页数 public Page() &#123; super(); &#125; public Page(int pageNum, int pageSize) &#123; this(pageNum, pageSize, 0); &#125; public Page(int pageNum, int pageSize, long total) &#123; this.pageNum = pageNum; this.pageSize = pageSize; this.total = total; this.pages = (int)(this.pageSize == 0 ? 0 : this.total % this.pageSize == 0 ? this.total / this.pageSize : (this.total / this.pageSize + 1)); &#125; public int getPageNum() &#123; return pageNum; &#125; public void setPageNum(int pageNum) &#123; this.pageNum = pageNum; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125; public Long getTotal() &#123; return total; &#125; public void setTotal(long total) &#123; this.total = total; this.pages = (int)(this.pageSize == 0 ? 0 : this.total % this.pageSize == 0 ? this.total / this.pageSize : (this.total / this.pageSize + 1)); &#125; public int getPages() &#123; return pages; &#125; public void setPages(int pages) &#123; this.pages = pages; &#125; @Override public String toString() &#123; return "Page [pageNum=" + pageNum + ", pageSize=" + pageSize + ", total=" + total + ", pages=" + pages + "]"; &#125;&#125; 处理查询方法我们再顺一下拦截查询方法之后的流程 通过 Invocation 参数获取目标方法原来的参数信息 分析参数是否要进行分页处理，不需要不处理，执行原来的方法 添加分页条件，并查询结果（包括查询总数） 包装结果集并返回 这里直接附上实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192/* * 指定方法签名： 下面的配置表面 将会拦截在 Executor 实例中的 “query” 方法调用， 这里的 Executor 是负责执行低层映射语句的内部对象 */@SuppressWarnings(&#123;"rawtypes", "unchecked"&#125;)@Intercepts(&#123; @Signature( type = Executor.class, method = "query", args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)public class PageInterceptor implements Interceptor &#123; private final static String COUNT_SUFFIX = "_COUNT"; // count查询语句Id后缀 /** * 拦截目标对象中目标方法的执行 */ @Override public Object intercept(Invocation invocation) throws Throwable &#123; // 获得目标对象 Executor executor = (Executor)invocation.getTarget(); // 获得目标方法的参数 Object[] args = invocation.getArgs(); // MappedStatement表示的是XML中的一个SQL MappedStatement mappedStatement = (MappedStatement)args[0]; Object parameter = args[1]; System.out.println(parameter.getClass()); RowBounds rowBounds = (RowBounds)args[2]; ResultHandler resultHandler = (ResultHandler)args[3]; BoundSql boundSql = mappedStatement.getBoundSql(parameter); CacheKey cacheKey = executor.createCacheKey(mappedStatement, parameter, rowBounds, boundSql); //获取分页参数 IPage pageConfig = getPageConfig(parameter); if (pageConfig != null) &#123; return pageQuery(executor, mappedStatement, parameter, resultHandler, boundSql, cacheKey, pageConfig); &#125; else &#123; // 不用分页，执行目标方法 return invocation.proceed(); &#125; &#125; /** * 分页查询 * * @param executor * @param ms * @param parameter * @param resultHandler * @param boundSql * @param cacheKey * @param pageConfig * @return * @throws SQLException */ private Object pageQuery(Executor executor, MappedStatement ms, Object parameter, ResultHandler resultHandler, BoundSql boundSql, CacheKey cacheKey, IPage pageConfig) throws SQLException &#123; Page page = new Page(pageConfig.getPageNum(), pageConfig.getPageSize()); // 查询总数 Long count = countQuery(executor, ms, parameter, resultHandler, boundSql); // 总数大于 0 ,开始分页查询 if (count != null &amp;&amp; count &gt; 0) &#123; page.setTotal(count); // 生成分页的缓存 key CacheKey pageKey = cacheKey; // 获取分页 sql StringBuilder pageSql = new StringBuilder(boundSql.getSql()); if (pageConfig.getStartRow() == 0) &#123; pageSql.append(" LIMIT ").append(pageConfig.getPageSize()); &#125; else &#123; pageSql.append(" LIMIT ").append(pageConfig.getStartRow()).append(",").append(pageConfig.getPageSize()); &#125; BoundSql pageBoundSql = new BoundSql(ms.getConfiguration(), pageSql.toString(), boundSql.getParameterMappings(), parameter); List list = executor.query(ms, parameter, RowBounds.DEFAULT, resultHandler, pageKey, pageBoundSql); page.addAll(list); &#125; return page; &#125; /** * count 查询，获取总记录数 * * @param executor * @param mappedStatement * @param parameter * @param resultHandler * @param boundSql * @return * @throws SQLException */ private Long countQuery(Executor executor, MappedStatement mappedStatement, Object parameter, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123; // 创建新的 MappedStatement 用于count查询 MappedStatement countMs = newCountMappedStatement(mappedStatement); // 创建 count 查询的缓存 key CacheKey countKey = executor.createCacheKey(countMs, parameter, RowBounds.DEFAULT, boundSql); // 创建 countBoundSql String countSql = "SELECT COUNT(*) FROM (" + boundSql.getSql() + ") T"; BoundSql countBoundSql = new BoundSql(countMs.getConfiguration(), countSql, boundSql.getParameterMappings(), parameter); // 执行 count 查询 Object countResult = executor.query(countMs, parameter, RowBounds.DEFAULT, resultHandler, countKey, countBoundSql); Long count = (Long)((List)countResult).get(0); return count; &#125; /** * 新建用于count查询的MappedStatement * * @param ms * @return */ private MappedStatement newCountMappedStatement(MappedStatement ms) &#123; String countMsId = ms.getId() + COUNT_SUFFIX; MappedStatement.Builder builder = new MappedStatement.Builder(ms.getConfiguration(), countMsId, ms.getSqlSource(), ms.getSqlCommandType()); builder.resource(ms.getResource()); builder.fetchSize(ms.getFetchSize()); builder.statementType(ms.getStatementType()); builder.keyGenerator(ms.getKeyGenerator()); builder.resultSetType(ms.getResultSetType()); builder.cache(ms.getCache()); builder.flushCacheRequired(ms.isFlushCacheRequired()); builder.useCache(ms.isUseCache()); builder.timeout(ms.getTimeout()); builder.parameterMap(ms.getParameterMap()); if (ms.getKeyProperties() != null &amp;&amp; ms.getKeyProperties().length != 0) &#123; StringBuilder keyProperties = new StringBuilder(); for (String keyProperty : ms.getKeyProperties()) &#123; keyProperties.append(keyProperty).append(","); &#125; keyProperties.delete(keyProperties.length() - 1, keyProperties.length()); builder.keyProperty(keyProperties.toString()); &#125; // 设置返回结果为 Long List&lt;ResultMap&gt; resultMaps = new ArrayList&lt;ResultMap&gt;(); ResultMap resultMap = new ResultMap.Builder(ms.getConfiguration(), ms.getId(), Long.class, new ArrayList&lt;ResultMapping&gt;(0)) .build(); resultMaps.add(resultMap); builder.resultMaps(resultMaps); return builder.build(); &#125; /** * 获取分页信息 * * @param parameter * @param rowBounds * @return */ private IPage getPageConfig(Object parameter) &#123; IPage pageConfig = null; if (parameter instanceof IPage) &#123; pageConfig = (IPage)parameter; &#125;else if(parameter instanceof MapperMethod.ParamMap) &#123; MapperMethod.ParamMap paramMap = (MapperMethod.ParamMap)parameter; for(Object value:paramMap.values()) &#123; if (value instanceof IPage) &#123; pageConfig = (IPage)value; break; &#125; &#125; &#125; return pageConfig; &#125; /** * 包装目标对象,即为目标对象创建一个代理对象 */ @Override public Object plugin(Object target) &#123; // 借助 Plugin 的 wrap(Object target,Interceptor interceptor); 包装我们的目标对象 // target: 目标对象, interceptor: 拦截器, this 表示使用当前拦截器 return Plugin.wrap(target, this); &#125; /** * 获取插件注册时，传入的property属性 */ @Override public void setProperties(Properties properties) &#123; &#125;&#125; 测试结果要使用插件，记得在 mybatis xml 中配置 plugin1234&lt;plugins&gt; &lt;plugin interceptor="com.brave.interceptor.PageInterceptor"&gt; &lt;/plugin&gt; &lt;/plugins&gt; 我这个例子适用于使用 mapper 接口，只要接口方法有 IPage 的分页查询参数，就会分页查询12345public interface UpmsUserMapper &#123; List&lt;UpmsUser&gt; selectUser(UpmsUser upmsUser, PageConfig pageConfig); List&lt;UpmsUser&gt; selectUser(IPage pageConfig);&#125; 我们创建测试类测试一下结果123456789101112131415161718@RunWith(SpringJUnit4ClassRunner.class) //使用junit4进行测试 @ContextConfiguration ("/conf/spring/applicationContext*.xml") public class UpmsUserMapperTest &#123; @Autowired private UpmsUserMapper upmsUserMapper; @Test public void testSelectUserUpmsUserPageConfig() &#123; PageConfig pageConfig = new PageConfig(1, 2); List&lt;UpmsUser&gt; list = upmsUserMapper.selectUser(new UpmsUser(), pageConfig); System.out.println(list.getClass()); System.out.println(list.toString()); for (UpmsUser upmsUser : list) &#123; System.out.println(upmsUser.toString()); &#125; &#125;&#125; 测试结果如下1234class com.brave.page.PagePage [pageNum=1, pageSize=2, total=3, pages=2][userId=10001][loginname=zou][password=123456][locked=null][userId=10002][loginname=zou][password=123456][locked=null] 分页插件 PageHelper 使用上面的例子，只是简陋的实现一个分页插件，明白大概的流程。下面来介绍分页插件 PageHelper 的使用 PageHelper 的 github 地址 https://github.com/pagehelper/Mybatis-PageHelper 添加依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.8&lt;/version&gt;&lt;/dependency&gt; 由于使用了 sql 解析工具，还会引入 jsqlparser.jar 包，如果不是使用 maven，还需要自己导入 pagehelper 依赖版本一致的 jsqlparser.jar 包 配置拦截器插件在 MyBatis 配置文件中添加拦截器插件配置123456&lt;plugins&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;!-- 具体参数后面介绍 --&gt; &lt;property name="helperDialect" value="mysql"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 如果是 Spring 项目，也可以在 Spring 配置文件的 SqlSessionFactoryBean 里面添加插件配置12345678910111213141516171819&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 配置映射器文件 --&gt; &lt;property name="mapperLocations" value="classpath*:com/brave/dao/mapper/*Mapper.xml" /&gt; &lt;!-- 插件 --&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;!-- 具体参数后面介绍 --&gt; &lt;value&gt; helperDialect=mysql &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 两个地方的配置选其一就好，不要同时生效 下面是具体分页插件参数 参数 描述 默认值 helperDialect 分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。该属性可以指定分页插件使用哪种方言。配置值：oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby – offsetAsPageNum 该参数对使用 RowBounds 作为分页参数时有效。设为 true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分页 false rowBoundsWithCount 该参数对使用 RowBounds 作为分页参数时有效。设置为true时，使用 RowBounds 分页会进行 count 查询 false pageSizeZero 设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型） false reasonable 分页合理化参数。设置为 true 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时），会查询最后一页。默认false 时，直接根据参数进行查询 false params 为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值，可以配置 pageNum,pageSize,count,pageSizeZero,reasonable，不配置映射的用默认值 pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero supportMethodsArguments 支持通过 Mapper 接口参数来传递分页参数，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法可以参考测试代码中的 com.github.pagehelper.test.basic 包下的 ArgumentsMapTest 和 ArgumentsObjTest false autoRuntimeDialect 设置为 true 时，允许在运行时根据多数据源自动识别对应方言的分页 false closeConn 当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类型时，会自动获取一个数据库连接，通过该属性来设置是否关闭获取的这个连接，默认true关闭，设置为 false 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定 true aggregateFunctions(5.1.5+) 默认为所有常见数据库的聚合函数，允许手动添加聚合函数（影响行数），所有以聚合函数开头的函数，在进行 count 转换时，会套一层。其他函数和列会被替换为 count(0)，其中count列可以自己配置。 当 offsetAsPageNum=false 的时候，由于 PageNum 问题，RowBounds查询的时候 reasonable 会强制为 false。使用 PageHelper.startPage 方法不受影响。 这些参数是在默认情况（dialect）下有效，默认情况下会使用 PageHelper 方式进行分页，如果想要实现自己的分页逻辑，可以实现 Dialect(com.github.pagehelper.Dialect) 接口，然后配置该属性为实现类的全限定名称。 使用方法这里主要是4种使用方法 RowBounds方式的调用 PageHelper 的静态方法调用 接口方法使用分页参数 ISelect 接口方式 RowBounds方式的调用使用 RowBounds 参数进行分页，这种方式侵入性最小，用只是使用了这个参数，并没有增加其他任何内容123456789@Repositorypublic class UpmsUserDaoImpl extends SuperDao implements UpmsUserDao &#123; @Override public List&lt;UpmsUser&gt; selectUser(int offset,int limit) &#123; List&lt;UpmsUser&gt; list = getSqlSession().selectList("com.brave.dao.UpmsUserDao2.selectUser", null, new RowBounds(offset, limit)); return list;&#125;&#125; 测试代码1234567@Testpublic void testSelectUser() &#123; List&lt;UpmsUser&gt; upmsUsers = upmsUserDao.selectUser(0, 10); for (UpmsUser upmsUser : upmsUsers) &#123; System.out.println(upmsUser.toString()); &#125;&#125; 我们在配置插件的时候有两个参数是关于 RowBounds 的 offsetAsPageNum 设置为 true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分页，也就是说上面的例子，我们查第一页时为 upmsUserDao.selectUser(1, 10) rowBoundsWithCount RowBounds 查询默认是没有 count 查询的，设置为true时，使用 RowBounds 分页会进行 count 查询 当 rowBoundsWithCount 设置为true时，会有 count 查询，会获得查询记录总数12345678@Testpublic void testSelectUser() &#123; Page&lt;UpmsUser&gt; upmsUsers = (Page&lt;UpmsUser&gt;)upmsUserDao.selectUser(1, 10); System.out.println("总页数："+upmsUsers.getTotal()); for (UpmsUser upmsUser : upmsUsers) &#123; System.out.println(upmsUser.toString()); &#125;&#125; 没有设置或为false的话，total 为 -1 如果不设置 rowBoundsWithCount，也可以通过 PageRowBounds 进行 count 查询 getSqlSession().selectList(&quot;com.brave.dao.UpmsUserDao.selectUser&quot;, null, new PageRowBounds (offset, limit)) PageRowBounds 继承 RowBounds，多了 total 属性 另外使用接口的时候也可以增加RowBounds参数 List&lt;Country&gt; selectAll(RowBounds rowBounds); PageHelper 的静态方法调用PageHelper 类有 startPage 和 offsetPage 方法去设置分页参数 在需要进行分页的 mybatis 查询方法前调用 PageHelper.startPage 静态方法即可，紧跟在这个方法后的第一个 MyBatis 查询方法会被进行分页。 通常是在 service 的 bean 中调用 dao 的查询方法前 或者是 mapper 接口方法前 调用 PageHelper 的静态方法 123456789101112@Testpublic void testSelectUser2() &#123; // request: url?pageNum=1&amp;pageSize=10 // 支持 ServletRequest,Map,POJO 对象，需要配合 params 参数 // PageHelper.startPage(request); PageHelper.startPage(1, 10); Page&lt;UpmsUser&gt; upmsUsers = (Page&lt;UpmsUser&gt;)upmsUserDao.selectUser(); System.out.println("总页数：" + upmsUsers.getTotal()); for (UpmsUser upmsUser : upmsUsers) &#123; System.out.println(upmsUser.toString()); &#125;&#125; 使用 mapper 接口的时候1234567891011@Servicepublic class UpmsUserServiceImpl implements UpmsUserService &#123; @Autowired private UpmsUserMapper upmsUserMapper; @Override public List&lt;UpmsUser&gt; listUser(int pageNum, int pageSize) &#123; PageHelper.startPage(pageNum, pageSize); return upmsUserMapper.selectUser(); &#125;&#125; 使用 PageInfo PageInfo 包含了非常全面的分页属性 12List&lt;UpmsUser&gt; list = (Page&lt;UpmsUser&gt;)upmsUserDao.selectUser();PageInfo&lt;UpmsUser&gt; pageInfo = new PageInfo(list); 1234567891011121314151617181920private int pageNum;//当前页private int pageSize;//每页的数量private int size; //当前页的数量//由于startRow和endRow不常用，这里说个具体的用法//可以在页面中&quot;显示startRow到endRow 共size条数据&quot;private int startRow;//当前页面第一个元素在数据库中的行号private int endRow;//当前页面最后一个元素在数据库中的行号private int pages;//总页数private int prePage;//前一页private int nextPage;//下一页private boolean isFirstPage = false;//是否为第一页private boolean isLastPage = false;//是否为最后一页private boolean hasPreviousPage = false;//是否有前一页private boolean hasNextPage = false;//是否有下一页private int navigatePages;//导航页码数private int[] navigatepageNums;//所有导航页号private int navigateFirstPage;//导航条上的第一页private int navigateLastPage;//导航条上的最后一页 使用参数的方法想要使用参数方式，需要配置 supportMethodsArguments 参数为 true，同时要配置 params 参数1234567&lt;plugins&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="supportMethodsArguments" value="true"/&gt; &lt;!-- params 默认值为 pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero --&gt; &lt;property name="params" value="pageNum=pageNum;pageSize=pageSize;"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 可以在使用接口声明时就带上 pageNum 和 pageSize12345678910//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数public interface CountryMapper &#123; List&lt;Country&gt; selectByPageNumSize( @Param("upmsUser") UpmsUser upmsUser, @Param("pageNum") int pageNum, @Param("pageSize") int pageSize);&#125;//配置supportMethodsArguments=true//在代码中直接调用：List&lt;Country&gt; list = countryMapper.selectByPageNumSize(user, 1, 10); 也可以把 pageNum 和 pageSize 存在于对象中，如 UpmsUser123456//存在以下 Mapper 接口方法，不需要在 xml 处理后两个参数public interface CountryMapper &#123; List&lt;Country&gt; selectByPageNumSize(UpmsUser upmsUser);&#125;//当 user 中的 pageNum!= null &amp;&amp; pageSize!= null 时，会自动分页List&lt;Country&gt; list = countryMapper.selectByPageNumSize(upmsUser); 两种情况都需要 pageNum 和 pageSize 两个属性同时存在才会分页，且在 xml 中的sql中不需要处理这两个参数 ISelect 接口方式另外还可以使用 ISelect 接口方式方式12345678910111213141516171819202122232425262728Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(new ISelect() &#123; @Override public void doSelect() &#123; upmsUserMapper.selectUser(); &#125;&#125;);// lambda用法Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(()-&gt; upmsUserMapper.selectUser());//也可以直接返回PageInfo，注意doSelectPageInfo方法和doSelectPagepageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(new ISelect() &#123; @Override public void doSelect() &#123; upmsUserMapper.selectUser(); &#125;&#125;);//对应的lambda用法pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(() -&gt; upmsUserMapper.selectUser());//count查询，返回一个查询语句的count数long total = PageHelper.count(new ISelect() &#123; @Override public void doSelect() &#123; upmsUserMapper.selectUser(country); &#125;&#125;);//lambdatotal = PageHelper.count(()-&gt;upmsUserMapper.selectUser(country)); ISelect 接口方式除了可以保证安全外，还特别实现了将查询转换为单纯的 count 查询方式，这个方法可以将任意的查询方法，变成一个 select count(*) 的查询方法。 上述使用方法的安全性考虑 使用 RowBounds 和 PageRowBounds 参数方式是极其安全的 使用参数方式是极其安全的 使用 ISelect 接口调用是极其安全的 不安全的时候： PageHelper 方法使用了静态的 ThreadLocal 参数，分页参数和线程是绑定的。 只要你可以保证在 PageHelper 方法调用后紧跟 MyBatis 查询方法，这就是安全的。因为 PageHelper 在 finally 代码段中自动清除了 ThreadLocal 存储的对象。 如果代码在进入 Executor 前发生异常，就会导致线程不可用，这属于人为的 Bug（例如接口方法和 XML 中的不匹配，导致找不到 MappedStatement 时）， 这种情况由于线程不可用，也不会导致 ThreadLocal 参数被错误的使用。 下面这样的代码，就是不安全的用法：12345678//由于 param1 存在 null 的情况，就会导致 PageHelper 生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页PageHelper.startPage(1, 10);List&lt;UpmsUser&gt; list;if(param1 != null)&#123; list = UpmsUserMapper.selectUser(param1);&#125; else &#123; list = new ArrayList&lt;UpmsUser&gt;();&#125; 我们只要把 PageHelper.startPage(1, 10); 方法放到if里面查询语句之前就好了]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>PageHelper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis-Spring：Mybatis在Spring中的使用]]></title>
    <url>%2Fblog%2Fmybatis-spring%2F</url>
    <content type="text"><![CDATA[当我们想在 Spring 项目中使用 Mybatis 的时候就需要 MyBatis-Spring 了，它可以让 Spring 完美的整合 MyBatis 代码。使用这个类库中的类，Spring 将会加载必要的 MyBatis 工厂类和 session 类。 这个类库也提供一个简单的方式来注入 Mybatis 数据映射器和 SqlSession 到业务层的 bean 中。 而且它也会处理事务, 翻译 MyBatis 的异常到 Spring 的 DataAccessException 异常(数据访问异常)中 我们先走一个简单例子，再在基础上扩展 例子添加依赖使用 mybatis-spring 模块，需要添加 mybatis-spring-x.x.x.jar 包12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 同时加上 mybatis-x.x.x.jar 包和相关数据库连接包，spring 的依赖添加上 spring-context 和 spring-jdbc，如果是 web 项目，再加上 web 相关的 jar 包即可 创建 SqlSessionFactoryBean我们在使用 MyBatis 的时候，最关键的是去使用 SqlSession 去执行映射的 SQL 语句。而 SqlSession 是通过 SqlSesionFactory 来获取的。而 SqlSessionFactory 的实例则是由SqlSessionFactoryBuilder 从 XML 配置文件或一个预先定制的 Configuration 的实例构建出来的 现在，我们是要在 Spring 上整合 MyBatis，需要把 SqlSessionFactory 的创建和 注入交给 Spring容器，在 Mybatis-Spring 中 SqlSessionFactory 的创建交给了 SqlSessionFactoryBean 我们在项目中创建一个 Spring 的配置文件，添加相关配置，加上 SqlSessionFactoryBean 的配置 application-mybatis.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 使用注解声明 --&gt; &lt;context:component-scan base-package="com.brave"/&gt; &lt;!-- 加载属性资源 --&gt; &lt;context:property-placeholder location="classpath*:conf/*.properties"&gt;&lt;/context:property-placeholder&gt; &lt;!-- 配置 SqlSessionFactoryBean --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- mybatis 配置文件位置（默认配置的话，可以不用）--&gt; &lt;property name="configLocation" value="classpath:conf/mybatis/mybatis-config.xml"&gt;&lt;/property&gt; &lt;!-- 配置映射器文件 --&gt; &lt;property name="mapperLocations" value="classpath*:com/brave/dao/mapper/*Mapper.xml" /&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;!-- 这里使用的是 druid 连接池，需要另外导入 druid.jar --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt;&lt;/beans&gt; 要注意 SqlSessionFactoryBean 实现了 Spring 的 FactoryBean 接口。这就说明了由 Spring 最终创建的 bean 不是 SqlSessionFactoryBean 本身。 而是工厂类的 getObject()返回的方法的结果。这种情况下,Spring 将会在应用启动时为你 创建 SqlSessionFactory 对象,然后将它以 SqlSessionFactory 为名来存储。在 Java 中, 相同的代码是: SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();SqlSessionFactory sessionFactory = factoryBean.getObject(); 但是一般我们不直接使用 SqlSessionFactoryBean 或 SqlSessionFactory。因为 session 工厂将会被注入到映射器中 或其它扩展了 SqlSessionDaoSupport 的 DAO(Data Access Object, 数据访问对象)中 SqlSessionFactory有三个属性 dataSource 属性是必须的，配置数据源信息 configLocation 属性用来指定 MyBatis 的 XML 配置文件路径，如果基本的 MyBatis 配置需要改变（通常这会是 \&lt;settings> 或 \&lt;typeAliases> 的部分） mapperLocations 属性用来指定映射器文件的资源位置 mapperLocations 可以配置多个位置123456&lt;property name="mapperLocations"&gt; &lt;list&gt; &lt;value&gt;classpath*:conf/mybatis/**/*Mapper.xml&lt;/value&gt; &lt;value&gt;classpath*:conf/com/brave/**/*Mapper.xml&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; 使用 SqlSessionTemplate在 MyBatis 中，我们使用 SqlSessionFactory 来创建 SqlSession。获取了一个 session 之后，使用它来执行映射的 SQL 语句、提交或回滚连接，最后当不再需要它的时候关闭 session。 使用 MyBatis-Spring 之后，就不需要直接使用 SqlSessionFactory 了，因为你的 bean 可以通过一个线程安全的 SqlSession 来注入，基于 Spring 的事务配置来自动提交、回滚、关闭 session。 SqlSessionTemplateSqlSessionTemplate 是 MyBatis-Spring 的核心。它负责管理 MyBatis 的 SqlSession， 调用 MyBatis 的 SQL 方法、翻译异常。它是线程安全的，可以被多个 DAO 所共享使用。 当调用 SQL 方法时，包含从映射器 getMapper()方法返回的方法，SqlSessionTemplate 将会保证使用的 SqlSession 是和当前 Spring 的事务相关的。它管理这 session 的生命周期，包含必要的关闭,提交或回滚操作。 SqlSessionTemplate 对象可以使用 SqlSessionFactory 作为构造方法的参数来创建12345&lt;bean id="sqlSession" class="org.mybatis.spring.SqlSessionTemplate"&gt; &lt;constructor-arg index="0" ref="sqlSessionFactory" /&gt; &lt;!-- 配置了BATCH 表示所有的语句可以批量操作 --&gt; &lt;constructor-arg index="1" value="BATCH" /&gt;&lt;/bean&gt; SqlSessionTemplate 实现了 SqlSession 接口，不用再代码中对 MyBatis 的 SqlSession 进行替换，直接在 Dao bean中直接注入这个 SqlSession 属性就可以了123456789101112131415161718192021@Repositorypublic class UpmsUserDaoImpl implements UpmsUserDao &#123; @Autowired private SqlSession sqlSession; @Override public UpmsUser selectOne(Long userId) &#123; return sqlSession.selectOne("com.brave.dao.UpmsUserDao.selectOne", userId); &#125; @Override public List&lt;UpmsUser&gt; selectUser(UpmsUser upmsUser) &#123; return sqlSession.selectList("com.brave.dao.UpmsUserDao.selectUser", upmsUser); &#125; @Override public int insertUser(UpmsUser upmsUser) &#123; return sqlSession.insert("com.brave.dao.UpmsUserDao.insertUser", upmsUser); &#125;&#125; 这里附上我的映射文件 upmsUserMapper.xml12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.brave.dao.UpmsUserDao"&gt; &lt;resultMap type="com.brave.model.UpmsUser" id="upmsUser"&gt; &lt;id column="user_id" property="userId"/&gt; &lt;result column="loginname" property="loginname"/&gt; &lt;result column="password" property="password"/&gt; &lt;result column="realname" property="realname"/&gt; &lt;result column="phone" property="phone"/&gt; &lt;result column="email" property="email"/&gt; &lt;result column="is_locked" property="locked"/&gt; &lt;result column="gmt_create" property="gmtCreate"/&gt; &lt;result column="gmt_modified" property="gmtModified"/&gt; &lt;/resultMap&gt; &lt;select id="selectOne" resultMap="upmsUser"&gt; select * from upms_user where user_id = #&#123;userId&#125; &lt;/select&gt; &lt;select id="selectUser" resultMap="upmsUser"&gt; select * from upms_user &lt;where&gt; &lt;if test="loginname != null and loginname != '' "&gt; loginname like #&#123;loginname&#125; &lt;/if&gt; &lt;if test="realname != null and realname != '' "&gt; and realname like #&#123;realname&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;insert id="insertUser"&gt; insert into upms_user (user_id,loginname,password,realname,is_locked) value(#&#123;userId&#125;,#&#123;loginname&#125;,#&#123;password&#125;,#&#123;realname&#125;,#&#123;locked&#125;) &lt;/insert&gt;&lt;/mapper&gt; 使用 Junit 生成测试类1234567891011121314151617181920212223242526272829303132333435@RunWith(SpringJUnit4ClassRunner.class) //使用junit4进行测试 @ContextConfiguration ("/conf/spring/applicationContext*.xml") public class UpmsUserDaoImplTest &#123; @Autowired private UpmsUserDao upmsUserDao; @Test public void testSelectOne() &#123; System.out.println(upmsUserDao.selectOne(10001L).toString()); &#125; @Test public void testSelectUser() &#123; UpmsUser user = new UpmsUser(); user.setLoginname("zou"); user.setUserId(2L); List&lt;UpmsUser&gt; upmsUsers = upmsUserDao.selectUser(user); for (UpmsUser upmsUser : upmsUsers) &#123; System.out.println(upmsUser.toString()); &#125; &#125; @Test @Transactional //声明需要事务 public void testInsertUser() &#123; UpmsUser upmsUser = new UpmsUser(); upmsUser.setUserId(10002L); upmsUser.setLoginname("zou"); upmsUser.setPassword("123456"); upmsUser.setLocked(false); int n = upmsUserDao.insertUser(upmsUser); System.out.println("插入" + n + "行"); &#125;&#125; SqlSessionDaoSupportSqlSessionDaoSupport 是一个抽象的支持类，用来提供 SqlSession。getSqlSession()方法可以得到一个 SqlSessionTemplate123456public class UpmsUserDaoImpl2 extends SqlSessionDaoSupport implements UpmsUserDao &#123; @Override public UpmsUser selectOne(Long userId) &#123; return getSqlSession().selectOne("com.brave.dao.UpmsUserDao.selectOne", userId); &#125;&#125; SqlSessionDaoSupport 需要设置一个 sqlSessionFactory 或 sqlSessionTemplate 属性 假如是 UpmsUserDaoImpl2 继承了 SqlSessionDaoSupport： 123&lt;bean id="upmsUserDaoImpl" class="com.brave.dao.UpmsUserDaoImpl2"&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory" /&gt;&lt;/bean&gt; 可以创建一个公用的 SuperDao 去继承 SqlSessionDaoSupport，为 SuperDao 设置 sqlSessionFactory 属性，然后让其他 dao 去继承 SuperDao，这样就不用每个 dao 都去设置这个属性了123456public class SuperDao extends SqlSessionDaoSupport &#123; @Autowired public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) &#123; super.setSqlSessionFactory(sqlSessionFactory); &#125;&#125; 不过通常我们更常用 MapperFactoryBean（只需要接口，不用实现类），因为它不需要额外的代码。但是如果需要在 DAO 中做其它非 MyBatis 的工作或需要具体的类，那么这个类就很有用了。 事务MyBatis-Spring 允许 MyBatis 参与到 Spring 的事务管理中。利用了存在于 Spring 中的 DataSourceTransactionManager，而不是创建一个新的特定的事务管理器 一旦 Spring 的 PlatformTransactionManager 配置好了，可以在 Spring 中以通常的做法来配置事务。@Transactional 注解和 AOP 样式的配置都是支持的。在事务处理期间,一个单独的 SqlSession 对象将会被创建和使用。当事务完成时，这个 session 会以合适的方式提交或回滚。 一旦事务创建之后，MyBatis-Spring 将会透明的管理事务。在你的 DAO 类中就不需要额外的代码了 标准配置要 开 启 Spring 的 事 务 处 理 , 在 Spring 的 XML 配 置 文 件 中 简 单 创 建 一 个 DataSourceTransactionManager 对象:123&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt; 注入映射器在 MyBatis 中，我们可以创建一个来绑定映射的语句的接口映射器（实际上也就是我们的 dao 接口），在映射文件的命名空间与我们的映射器完全限定名一致，映射语句 id 名就是映射器的方法名，这样我们可以不用实现这个映射器，通过 sqlSession 获取映射器，直接使用 sql 方法12UpmsUserDao upmsUserDao = sqlSession.getMapper(UpmsUserDao.class);UpmsUse upmsUse = upmsUserDao.selectOne(10002L); 为了代替手工使用 SqlSessionDaoSupport 或 SqlSessionTemplate 编写数据访问对象 (DAO)的代码，MyBatis-Spring 也提供了一个动态代理的实现：MapperFactoryBean。这个类可以让你直接注入 数据映射器接口 到你的 service 层 bean 中。当使用映射器时，直接调用就可以了，不需要实现 DAO接口，因为 MyBatis-Spring 将会为你创建代理。 使用注入的映射器代码，在 MyBatis、Spring 或 MyBatis-Spring 上面不会有直接的依赖。 MapperFactoryBean 创建的代理控制开放和关闭 session，会翻译任意的异常到 Spring 的 DataAccessException 异常中。此外，如果需要或参与到一个已经存在活动事务中，代理将会开启一个新的 Spring 事务。 MapperFactoryBean想要直接使用 数据映射器接口，先添加 MapperFactoryBean 到 Spring 中:1234&lt;bean id="upmsUserMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="com.brave.mapper.UpmsUserMapper" /&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory" /&gt;&lt;/bean&gt; MapperFactoryBean 创建的代理类实现了 UpmsUserMapper 接口，并且注入到应用程序中。 因为代理创建在运行时环境中，那么指定的映射器必须是一个接口，而不是一个具体的实现类。 如果 XML 映射器文件在类路径的位置和映射器类相同时，它会被 MapperFactoryBean 自动解析，否则你需要在 SqlSessionFactoryBean 的 mapperLocations 或是在 MyBatis 的配置文件中指明映射文件的位置 这里附上映射文件，这里的命名空间一定要是映射器的完全限定名1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 这里的命名空间一定要是映射器的完全限定名 --&gt;&lt;mapper namespace="com.brave.mapper.UpmsUserMapper"&gt; &lt;!-- 这里的id与映射器的方法一致 --&gt; &lt;select id="selectUser" resultType="com.brave.model.UpmsUser"&gt; select * from upms_user &lt;/select&gt;&lt;/mapper&gt; 接口映射器 UpmsUserMapper.java123public interface UpmsUserMapper &#123; List&lt;UpmsUser&gt; selectUser();&#125; 然后我们在应用程序逻辑中可以直接使用12345678910@Servicepublic class UpmsUserServiceImpl implements UpmsUserService &#123; @Autowired private UpmsUserMapper upmsUserMapper; @Override public List&lt;UpmsUser&gt; listUser() &#123; return upmsUserMapper.selectUser(); &#125;&#125; MapperScannerConfigurer我们没有必要在 Spring 的 XML 配置文件中注册所有的映射器。只用使用一个 MapperScannerConfigurer 即可，它会查找类路径下的映射器并自动将它们创建成 MapperFactoryBean123&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.brave.mapper" /&gt;&lt;/bean&gt; 这样就不用每个 mapper 都配置一个 MapperFactoryBean 了 basePackage 属性是让你为映射器接口文件设置基本的包路径。 可以使用 分号 或 逗号 作为分隔符设置多于一个的包路径。每个映射器将会在指定的包路径中递归地被搜索到 @MapperScan 和 mybatis:scan另外还有两种扫描映射器的方法 &lt;mybatis:scan&gt; 元素 @MapperScan 注解 \mybatis:scan\ 元素&lt;mybatis:scan&gt; 元素将在特定的以逗号分隔的包名列表中搜索映射器 mapper 接口。 要使用这个元素需要添加以下的 schema 声明1234567891011&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mybatis="http://mybatis.org/schema/mybatis-spring" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd"&gt; &lt;mybatis:scan base-package="com.brave.mapper" /&gt;&lt;/beans&gt; @MapperScan 注解如果使用基于java的配置,可以使用@MapperScan 注解来扫描映射器 Mapper 接口。 @MapperScan 和 &lt;mybatis:scan/&gt; 工作方式 相同，并且也提供了对应的自定义选项 在 Spring-Boot 项目中可能会使用到 1234567@SpringBootApplication @MapperScan("com.brave.mapper") public class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125; &#125;]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>MyBatis-Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 的动态SQL使用]]></title>
    <url>%2Fblog%2Fmybatis-dynamic-sql%2F</url>
    <content type="text"><![CDATA[动态 SQL 是 MyBatis 一个很强大的特性，我们经常会因为不同的条件去拼接 sql，一不小心可能就会少了个空格，或是列名后面多了个逗号。利用动态 sql 可以很灵活的去为我们拼接sql，且相对简洁清晰。 动态 SQL 元素这里我们主要来了解下面几个元素： if choose (when, otherwise) trim (where, set) foreach if我们先看一下语法1234567&lt;select id="selectUser" resultMap="upmsUser"&gt; select * from upms_user where is_locked = 1 &lt;if test="loginname != null"&gt; and loginname like #&#123;loginname&#125; &lt;/if&gt;&lt;/select&gt; test 里面是对条件的判断，若里面为 true 的话，便会加上 if 元素里的内容。如上面的loginname 不为空的话，sql语句就会是 select * from upms_user where is_locked = 1 and loginname like #{loginname} test 里面的 与 和 或 不能用 &amp;&amp; 和 ||，而是要使用 and 和 or test 属性值是不能包含 ‘&lt;’ 字符的， 所以判断大小不能用 &lt; 和 &lt;=，用 lt 和 lte 代替。&gt; 和 &gt;= 虽然可以用，但规范起见，最好也用 gt 和 gte 代替 123456789&lt;select id="selectUser" resultMap="upmsUser"&gt; select * from upms_user where is_locked = 1 &lt;if test="upmsUser.age gte 10 and upmsUser.age lt 20"&gt; &lt;if test="loginname != null and loginname != '' "&gt; and loginname like #&#123;loginname&#125; &lt;/if&gt; &lt;/if&gt;&lt;/select&gt; choose (when, otherwise)有时候我们只想应用多个条件语句中的一个，我们就要用到 choose (when, otherwise) 了。它与 java 中的 if...else if...else 和 switch 很像。 123456789101112131415&lt;select id="selectUser" resultMap="upmsUser"&gt; select * from upms_user where is_locked = 1 &lt;choose&gt; &lt;when test="loginname != null and loginname != '' "&gt; and loginname like #&#123;loginname&#125; &lt;/when&gt; &lt;when test="upmsUser != null and upmsUser.realname != '' "&gt; and realname like #&#123;upmsUser.realname&#125; &lt;/when&gt; &lt;otherwise&gt; and phone is not null &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; test 属性值的语法和 if 元素的是一样的 trim (where, set)where这里我们先回到 if 的第一个例子，假如把 is_locked 字段也设为动态的12345678910&lt;select id="selectUser" resultMap="upmsUser"&gt; select * from upms_user where &lt;if test="locked != null"&gt; is_locked = #&#123;locked&#125; &lt;/if&gt; &lt;if test="loginname != null and loginname != '' "&gt; and loginname like #&#123;loginname&#125; &lt;/if&gt;&lt;/select&gt; 如果两个 if 的条件都成立，这时是没有问题的，但有两个情况下会出问题。 1、如果两个 if 都不成立，sql 语句就会变成 select * from upms_user where(多了一个where) 2、如果 locked 为 null，而后面的 if 成立，sql 语句就会变成 select * from upms_user where and loginname like #{loginname}(多了一个and) 这里其实我们可以在 where 后面加上一个 1=1，但 mabatis 给了我们一个更好的解决方法1234567891011&lt;select id="selectUser" resultMap="upmsUser"&gt; select * from upms_user &lt;where&gt; &lt;if test="locked != null"&gt; is_locked = #&#123;locked&#125; &lt;/if&gt; &lt;if test="loginname != null and loginname != '' "&gt; and loginname like #&#123;loginname&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 使用 where 元素，它会在没有条件成立时去掉where，在有条件成立的时候检查语句的开头，并去掉多余的 and 或是 or set同样的道理，我们在更新数据时使用 if 动态更新语句也可能会出现问题。这里可以使用 set 元素12345678910&lt;update id="updateUser"&gt; update user &lt;set&gt; &lt;if test="username != null"&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test="password != null"&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test="email != null"&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test="phone != null"&gt;phone=#&#123;phone&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; 它会删除set语句后面可能会多出来的逗号 trim有时候我们在其他地方可能也需要类似的功能，去除某些语句开头或结尾多出来的符号或是连接词。这时候我们可以使用 trim 去定制某些功能1234&lt;!-- prefix:前缀词 prefixOverrides:语句前多余要去除的内容 suffixOverrides:语句后多余要去除的内容 --&gt;&lt;trim prefix="" prefixOverrides="" suffixOverrides=""&gt; ...&lt;/trim&gt; 这里我们可以自定义与 where 和 set 元素等价的 trim 元素1234567&lt;trim prefix="WHERE" prefixOverrides="AND |OR "&gt; ... &lt;/trim&gt;&lt;trim prefix="SET" suffixOverrides=","&gt; ...&lt;/trim&gt; foreach动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候12345678&lt;select id="selectUser" resultMap="upmsUser"&gt; select * from upms_user where user_id in &lt;foreach item="item" index="index" collection="userIdList" open="(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; collection 表示要遍历的集合或数组，item 表示当前遍历的对象，index 表示当前遍历的序号或键，在元素体内使用的集合项（item）和索引（index）变量。 open、close、separator 可以指定开头与结尾的字符串以及在迭代结果之间放置分隔符 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象传递给 foreach 作为集合参数。当使用可迭代对象或者数组时，index 是当前迭代的次数，item 的值是本次迭代获取的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值 bindbind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文12345&lt;select id="selectUser" resultMap="User"&gt; &lt;bind name="pattern" value="'%' + user.getLoginname() + '%'" /&gt; SELECT * FROM upms_user WHERE loginname LIKE #&#123;pattern&#125;&lt;/select&gt;]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis的使用和配置]]></title>
    <url>%2Fblog%2Fmybatis-configuration-usage%2F</url>
    <content type="text"><![CDATA[MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 有以下特点： 简单易学，小且简单：没有第三方依赖，最简单安装只要两个jar包+配置几个sql映射文件，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：MyBatis 不会对应用程序或者数据库的现有设计强加任何影响。 sql 写在 xml 里，便于统一管理和优化。通过 sql 语句可以满足操作数据库的所有需求。 解除 sql 与程序代码的耦合：通过提供 DAO 层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql 和代码的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组建维护 提供xml标签，支持编写动态sql。 快速入门实例引用依赖单独使用 MyBatis，只需引入mybatis-x.x.x.jar 和相关的数据库连接包就行 使用 maven 的 dependency 配置为 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt; 我的例子的应用目录结构为下图 Mybatis配置和 xml映射文件配置每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。 SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。 而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。 mybatis XML 配置MyBatis 的XML配置文件（configuration XML）中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager） 这里先给出一个用 xml 配置的简单示例 mybatis-config.xml，详细的配置文件内容后面详说： 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 环境配置：事务管理器和数据源配置 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射器 --&gt; &lt;mappers&gt; &lt;mapper resource="com/brave/dao/mapper/UpmsUserMapper.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 数据源属性文件 database.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/shiyu?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8jdbc.username=zoujdbc.password=****** 通过配置文件我们可以从中构建 SqlSessionFactory 的实例12inputStream = Resources.getResourceAsStream("conf/mybatis-config.xml");sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); xml映射文件配置我们从上面的配置可以看到有映射器的配置 &lt;mapper resource=&quot;com/brave/dao/mapper/UpmsUserMapper.xml&quot; /&gt; 这里先给出该映射文件示例1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;!--- 命名空间 namespace --&gt;&lt;mapper namespace="com.brave.dao.UpmsUserDao"&gt; &lt;!-- 结果集映射 --&gt; &lt;resultMap type="com.brave.model.UpmsUser" id="upmsUser"&gt; &lt;id column="user_id" property="userId"/&gt; &lt;result column="loginname" property="loginname"/&gt; &lt;result column="password" property="password"/&gt; &lt;result column="realname" property="realname"/&gt; &lt;result column="phone" property="phone"/&gt; &lt;result column="email" property="email"/&gt; &lt;result column="is_locked" property="locked"/&gt; &lt;result column="gmt_create" property="gmtCreate"/&gt; &lt;result column="gmt_modified" property="gmtModified"/&gt; &lt;/resultMap&gt; &lt;!-- 查询sql --&gt; &lt;select id="selectOne" resultMap="upmsUser"&gt; select * from upms_user where user_id = #&#123;userId&#125; &lt;/select&gt; &lt;select id="selectUser" resultMap="upmsUser"&gt; select * from upms_user &lt;/select&gt; &lt;insert id="insertUser"&gt; insert into upms_user (user_id,loginname,password,realname,is_locked) value(#&#123;userId&#125;,#&#123;loginname&#125;,#&#123;password&#125;,#&#123;realname&#125;,#&#123;locked&#125;) &lt;/insert&gt;&lt;/mapper&gt; 上面我们通过 MyBatis 配置 xml 构建了 SqlSessionFactory，有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句：1234567SqlSession sqlSession = sqlSessionFactory.openSession();try &#123; //这里我们通过 命名空间+sql语句的Id来执行映射的sql语句 UpmsUser upmsUser = sqlSession.selectOne("com.brave.dao.UpmsUserDao.selectOne", 10001L);&#125;finally &#123; sqlSession.close();&#125; 构建 SqlSessionFactory，获取 SqlSession从上面的 MyBatis 配置和 xml 映射文件配置 我们可以了解到这样一个流程： 通过流读取 MyBatis 配置文件信息，使用 SqlSessionFactoryBuilder 构建 SqlSessionFactory，再从SqlSessionFactory 中获取 SqlSession 实例，通过 SqlSession 实例来直接执行已映射的 SQL 语句 在这里我们需要理解这三个对象的不同作用域和生命周期，错误的使用会导致非常严重的并发问题。 生命周期 作用域（Scope） SqlSessionFactoryBuilder 可以被实例化、使用和丢弃，一旦创建了SqlSessionFactory，就不再需要它了 方法（也就是局部方法变量） SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建 应用(最简单的就是使用单例模式或者静态单例模式) SqlSession 每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的 请求 / 方法 因为 SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，我们可以使用单例，创建一个 SqlSessionFactoryUtil123456789101112131415161718192021222324252627public class SqlSessionFactoryUtil &#123; private static SqlSessionFactory sqlSessionFactory; /** * 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。 * SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。 * 而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。 * * SqlSessionFactoryBuilder 最佳作用域是方法作用域（也就是局部方法变量） * SqlSessionFactory 最佳作用域是应用作用域 * SqlSession 最佳的作用域是请求或方法作用域 */ public static SqlSessionFactory getSqlSessionFactory() &#123; if (sqlSessionFactory != null) &#123; return sqlSessionFactory; &#125; InputStream inputStream; try &#123; inputStream = Resources.getResourceAsStream("conf/mybatis-config.xml"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return sqlSessionFactory; &#125;&#125; 我们可以创建一个 baseDao 获取 SqlSession123456789public class BaseDaoImpl implements BaseDao &#123; @Override public SqlSession getSqlSession() &#123; SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtil.getSqlSessionFactory(); return sqlSessionFactory.openSession(); &#125;&#125; 通过 命名空间+sql 语句的 Id 来执行映射的 sql 语句123456789101112131415161718192021222324252627282930313233343536373839public class UpmsUserDaoImpl extends BaseDaoImpl implements UpmsUserDao &#123; @Override public UpmsUser selectOne(Long userId) &#123; SqlSession sqlSession = getSqlSession(); UpmsUser upmsUser = null; try &#123; upmsUser = sqlSession.selectOne("com.brave.dao.UpmsUserDao.selectOne", userId); &#125; finally &#123; sqlSession.close(); &#125; return upmsUser; &#125; @Override public List&lt;UpmsUser&gt; selectUser() &#123; SqlSession sqlSession = getSqlSession(); List&lt;UpmsUser&gt; upmsUsers = null; try &#123; upmsUsers = sqlSession.selectList("com.brave.dao.UpmsUserDao.selectUser"); &#125; finally &#123; sqlSession.close(); &#125; return upmsUsers; &#125; @Override public int insertUser(UpmsUser upmsUser) &#123; SqlSession sqlSession = getSqlSession(); int n = 0; try &#123; n = sqlSession.insert("com.brave.dao.UpmsUserDao.insertUser", upmsUser); sqlSession.commit(); &#125; finally &#123; sqlSession.close(); &#125; return n; &#125;&#125; 我们用 Junit 创建测试类测试一下结果12345678910111213141516171819202122232425262728public class UpmsUserDaoImplTest &#123; UpmsUserDao userDao = new UpmsUserDaoImpl(); @Test public void testSelectOne() &#123; System.out.println(userDao.selectOne(10001L).toString()); &#125; @Test public void testSelectUser() &#123; List&lt;UpmsUser&gt; upmsUsers = userDao.selectUser(); for (UpmsUser upmsUser : upmsUsers) &#123; System.out.println(upmsUser.toString()); &#125; &#125; @Test public void testInsertUser() &#123; UpmsUser upmsUser = new UpmsUser(); upmsUser.setUserId(10002L); upmsUser.setLoginname("zou"); upmsUser.setPassword("123456"); upmsUser.setLocked(false); int n = userDao.insertUser(upmsUser); System.out.println("插入" + n + "行"); &#125;&#125; 到了这里我们其实可以发现，我们在映射文件中写的 命名空间 和 完全限定名 是一样的，如com.brave.dao.UpmsUserDao ，这个命名可以直接映射到在命名空间中同名的 Mapper 类，并将已映射的 sql 语句中的名字、参数和返回类型匹配成方法 这样我们就可以像上面那样很容易地调用这个对应 Mapper 接口的方法，只需要接口，不需要写实现类。我们的接口方法名称和 映射文件中的sql语句Id一致的话可以直接调用。 UpmsUserDao.java 12345678public interface UpmsUserDao extends BaseDao &#123; UpmsUser selectOne(Long userId); List&lt;UpmsUser&gt; selectUser(); int insertUser(UpmsUser upmsUser);&#125; 测试1234567891011@Testpublic void testInterface() &#123; SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtil.getSqlSessionFactory(); SqlSession session = sqlSessionFactory.openSession(); //可以直接映射到在命名空间中同名的 Mapper 类 （只要映射接口类就可以了，不需要实现） UpmsUserDao upmsUserDao = session.getMapper(UpmsUserDao.class); List&lt;UpmsUser&gt; upmsUsers = upmsUserDao.selectUser(); for (UpmsUser upmsUser : upmsUsers) &#123; System.out.println(upmsUser.toString()); &#125;&#125; 它们的映射的语句还可以不需要用 XML 来做，取而代之的是可以使用 Java 注解12@Select("select * from upms_user where user_id = #&#123;userId&#125;")UpmsUser getUser(Long userId); SqlSession 的使用和API使用 MyBatis 的主要 Java 接口就是 SqlSession。可以通过这个接口来执行命令，获取映射器和管理事务。SqlSessions 是由 SqlSessionFactory 实例创建的。SqlSessionFactory 对象包含创建 SqlSession 实例的所有方法。而 SqlSessionFactory 本身是由 SqlSessionFactoryBuilder 创建的，它可以从 XML、注解或手动配置 Java 代码来创建 SqlSessionFactory。 MyBatis XML配置MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置（settings）和属性（properties）信息。文档的顶层结构如下： configuration 配置 properties 属性 settings 设置 typeAliases 类型别名 typeHandlers 类型处理器 objectFactory 对象工厂 plugins 插件 environments 环境 environment 环境变量 transactionManager 事务管理器 dataSource 数据源 databaseIdProvider 数据库厂商标识 mappers 映射器 官方的文档很详细，这里不写了，直接参考过去http://www.mybatis.org/mybatis-3/zh/configuration.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 属性配置 --&gt; &lt;!-- 优先级：方法参数传递 &gt; resource/url 属性中指定的配置文件 &gt; 属性中指定的属性property --&gt; &lt;properties resource="conf/database.properties"&gt; &lt;property name="jdbc.username" value="zou" /&gt; &lt;property name="jdbc.password" value="******" /&gt; &lt;/properties&gt; &lt;!-- 调整设置，它们会改变 MyBatis 的运行时行为 --&gt; &lt;settings&gt; &lt;!-- 全局的映射器开启或禁用缓存 (默认true) --&gt; &lt;setting name="cacheEnabled" value="true" /&gt; &lt;!-- 全局开启或管理延迟加载。当开启时，所有关联对象都会延迟加载 (默认false) --&gt; &lt;setting name="lazyLoadingEnabled" value="true" /&gt; &lt;!-- 当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载 (默认false) --&gt; &lt;setting name="aggressiveLazyLoading" value="true"/&gt; &lt;!-- 允许单一sql语句返回多结果集 (默认true) --&gt; &lt;setting name="multipleResultSetsEnabled" value="true" /&gt; &lt;!-- 使用列标签代替列名 (默认true) --&gt; &lt;setting name="useColumnLabel" value="true" /&gt; &lt;!-- 允许 JDBC 支持自动生成主键 (默认false) --&gt; &lt;setting name="useGeneratedKeys" value="false" /&gt; &lt;!-- 指定 MyBatis 应如何自动映射列到字段或属性，NONE：不隐射 PARTIAL:部分 FULL:全部 (默认PARTIAL) --&gt; &lt;setting name="autoMappingBehavior" value="PARTIAL" /&gt; &lt;!-- 配置默认的执行器, SIMPLE:普通； REUSE: 执行器会重用预处理语句(prepared statements)； BATCH:执行器将重用语句并执行批量更新。--&gt; &lt;setting name="defaultExecutorType" value="SIMPLE" /&gt; &lt;!-- 超时时间 --&gt; &lt;setting name="defaultStatementTimeout" value="25" /&gt; &lt;!-- 为驱动的结果集获取数量（fetchSize）设置一个提示值 --&gt; &lt;setting name="defaultFetchSize" value="100" /&gt; &lt;!-- 允许在嵌套语句中使用分页,如果允许使用则设置为false (默认false) --&gt; &lt;setting name="safeRowBoundsEnabled" value="false" /&gt; &lt;!-- 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。(默认false) --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="false" /&gt; &lt;!-- 设置本地缓存范围 session:就会有数据的共享 statement:语句范围 (这样就不会有数据的共享 ) defalut:session --&gt; &lt;setting name="localCacheScope" value="SESSION" /&gt; &lt;!-- 设置但JDBC类型为空时,某些驱动程序 要指定值,default:OTHER，插入空值时不需要指定类型 --&gt; &lt;setting name="jdbcTypeForNull" value="OTHER" /&gt; &lt;!-- 指定哪个对象的方法触发一次延迟加载 --&gt; &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString" /&gt; &lt;/settings&gt; &lt;!-- 类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余 --&gt; &lt;typeAliases&gt; &lt;typeAlias alias="Author" type="domain.blog.Author" /&gt; &lt;typeAlias alias="Section" type="domain.blog.Section" /&gt; &lt;typeAlias alias="Tag" type="domain.blog.Tag" /&gt; &lt;!-- 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean --&gt; &lt;!-- 会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author --&gt; &lt;package name="domain.blog"/&gt; &lt;/typeAliases&gt; &lt;!-- 类型处理器 --&gt; &lt;typeHandlers&gt; &lt;typeHandler handler="org.mybatis.example.ExampleTypeHandler"/&gt; &lt;/typeHandlers&gt; &lt;!-- 插件 --&gt; &lt;plugins&gt; &lt;plugin interceptor="org.mybatis.example.ExamplePlugin"&gt; &lt;property name="someProperty" value="100"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!-- 环境配置：事务管理器和数据源配置 --&gt; &lt;!-- 尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- JDBC – 这个配置就是直接使用了 JDBC 的提交和回滚设置 --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- POOLED– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 插件 --&gt; &lt;plugins&gt; &lt;plugin interceptor="org.mybatis.example.ExamplePlugin"&gt; &lt;property name="someProperty" value="100" /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!-- 映射器 --&gt; &lt;mappers&gt; &lt;!-- 使用相对于类路径的资源引用 --&gt; &lt;mapper resource="com/brave/dao/mapper/UpmsUserMapper.xml" /&gt; &lt;!-- 使用完全限定资源定位符（URL） --&gt; &lt;mapper url="file:///var/mappers/PostMapper.xml"/&gt; &lt;!-- 使用映射器接口实现类的完全限定类名 --&gt; &lt;mapper class="org.mybatis.builder.PostMapper"/&gt; &lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt; &lt;package name="org.mybatis.builder"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; Mapper映射文件配置MyBatis 的真正强大在于它的映射语句，也是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 就是针对 SQL 构建的，并且比普通的方法做的更好。 SQL 映射文件有很少的几个顶级元素（按照它们应该被定义的顺序）： cache – 给定命名空间的缓存配置。 cache-ref – 其他命名空间缓存配置的引用。 resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。 parameterMap – 已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。 sql – 可被其他语句引用的可重用语句块。 insert – 映射插入语句 update – 映射更新语句 delete – 映射删除语句 select – 映射查询语句 每个元素的细节见官方文档http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 的 AOP 的支持]]></title>
    <url>%2Fblog%2Fspring-aop-capabilities-usage%2F</url>
    <content type="text"><![CDATA[面向切面编程 (Aspect-oriented Programming, AOP) 通过提供另一种思考程序结构的方法来补充面向对象编程(Object-oriented Programming, OOP)。OOP中模块化的关键单元是类，而 AOP 中模块化的单元是切面。切面支持跨多个类型和对象的关注点(例如事务管理)的模块化 AOP 的概念AOP 术语在使用 AOP 之前，先熟悉一下 AOP 概念和术语。这些术语并不特定于 Spring，而是与 AOP 有关的 项 描述 Aspect（切面） 跨越多个类的关注点的模块化，切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。事务处理和日志处理可以理解为切面 Join point（连接点） 程序执行过程中的一个点，如方法的执行或异常的处理 Advice（通知） 切面在特定连接点上采取的动作 Pointcut（切点） 匹配连接点的断言。通知与切入点表达式相关联，并在切入点匹配的任何连接点上运行(例如，具有特定名称的方法的执行)。切入点表达式匹配的连接点概念是 AOP 的核心，Spring 默认使用 AspectJ 切入点表达式语言 Introduction（引用） 为类型声明其他方法或字段。Spring AOP 允许您向任何建议的对象引入新的接口(和相应的实现)。例如，您可以使用介绍使 bean 实现 IsModified 接口，以简化缓存 Target object（目标） 由一个或多个切面通知的对象。也称为“通知对象”。由于 Spring AOP 是通过使用运行时代理实现的，所以这个对象始终是代理对象 AOP proxy（代理） AOP 框架为实现切面契约(通知方法执行等)而创建的对象。在 Spring 框架中，AOP 代理是 JDK 动态代理或 CGLIB 代理 Weaving（织入） 织入是将通知添加对目标类具体连接点上的过程，可以在编译时(例如使用AspectJ编译器)、加载时或运行时完成 Spring 切面可以应用5种类型的通知： 前置通知（Before）：在目标方法被调用之前调用通知 后置通知（After）：在目标方法完成之后调用通知（无论是正常还是异常退出） 返回通知（After-returning）：在目标方法成功执行之后调用通知 异常通知（After-throwing）：在目标方法抛出异常后调用通知 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为 其中环绕通知包括前置、后置、返回、异常通知，这个在后面的例子体现 使用 XML 配置的AOP支持xml配置中需要aop命名空间标记，需要先导入 spring-aop 模式123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- bean definitions here --&gt;&lt;/beans&gt; 也是需要 AspectJ 的 aspectjweaver.jar 包，spring-aspects 模块是依赖该jar包的 spring-aspects 模块集成自 AspectJ 框架， 主要是为 Spring AOP 提供多种 AOP 实现方法 声明一个切面使用 &lt;aop:aspect&gt; 标签声明切面，使用 ref 属性去引用支持的 bean12345678&lt;aop:config&gt; &lt;aop:aspect id="myAspect" ref="aspectBean"&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id="aspectBean" class="com.demo.aspect.AspectBean"&gt;...&lt;/bean&gt; 切面可以具有与任何其他类相同的方法和字段。它们还可以包含切入点、通知和引入(内部类型)声明。 声明切入点声明切入点是确定通知感兴趣的或是将要织入的连接点（即目标方法） 12345678910&lt;aop:config&gt; &lt;aop:aspect id="myAspect" ref="aspectBean"&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.demo.service.*.*(..))"/&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id="aspectBean" class="com.demo.aspect.AspectBean"&gt;&lt;/bean&gt; 表达式 expression 是对连接点的筛选，上面的例子是 com.demo.service 包下所有类的所有方法 详细的表达式语法见后面详说也还可以通过名称匹配切入点参数与建议方法参数 声明通知使用 &lt;aop:{ADVICE-NAME}&gt; 标签声明五个建议中的任意一个，如下123456789101112131415161718192021222324252627282930&lt;aop:config&gt; &lt;aop:aspect id="myAspect" ref="aspectBean"&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.demo.service.*.*(..))" /&gt; &lt;!-- 前置通知定义 --&gt; &lt;aop:before pointcut-ref="businessService" method="doBeforeTask" /&gt; &lt;!-- 后置通知定义 --&gt; &lt;aop:after pointcut-ref="businessService" method="doAfterTask" /&gt; &lt;!-- 返回通知定义 --&gt; &lt;!-- doReturnTask方法必须要有一个名字与“returning”值一致（如retVal）的参数，这个是目标方法的返回值 --&gt; &lt;aop:after-returning pointcut-ref="businessService" returning="retVal" method="doReturnTask" /&gt; &lt;!-- 异常通知定义 --&gt; &lt;!-- doRequiredTask方法必须要有一个名字与“throwing”值一致（如ex）的参数，这个是目标方法的抛出的异常--&gt; &lt;aop:after-throwing pointcut-ref="businessService" throwing="ex" method="doThrowTask" /&gt; &lt;!-- 环绕通知定义（环绕通知包含了其他的通知） --&gt; &lt;!-- &lt;aop:around pointcut-ref="businessService" method="doAroundTask" /&gt; --&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id="aspectBean" class="com.demo.aspect.AspectBean"&gt;&lt;/bean&gt; 其中环绕通知包括前置、后置、返回、异常通知，在待会的例子中可以看出 这里 pointcut-ref=&quot;businessService&quot; 是在 &lt;aop:config&gt; 里定义的切入点。也可以改为内联切入点，使用 pointcut 属性替换 pointcut-ref 属性 123456&lt;aop:aspect id="beforeExample" ref="aBean"&gt; &lt;aop:before pointcut="execution(* com.demo.service.*.*(..))" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt; 例子 我们使用上面的例子，定义的切入点为 com.demo.service 下的所有的类的所有方法，该切面支持的 bean 为 com.demo.aspect 下的 AspectBean。我们的切入点也是需要在IoC容器中被管理的 bean，可以用注解也可以xml配置 1&lt;bean id="targetService" class="com.demo.service.TargetService"/&gt; TargetService，目标对象，这个operation方法便是我们的切入点12345678public class TargetService &#123; public String operation(String msg) &#123; System.out.println("执行目标方法，方法参数[msg:" + msg + "]"); // 测试异常通知 // throw new RuntimeException("我是个异常"); return msg; &#125;&#125; 同时我也写一下 AspectBean 里面的方法12345678910111213141516171819202122232425262728293031323334353637383940414243public class AspectBean &#123; private static int step = 0; public void doBeforeTask(String msg) &#123; System.out.println(++step + " 前置通知,参数为[msg:" + msg + "]"); &#125; public void doAfterTask() &#123; System.out.println(++step + " 后置通知"); &#125; public void doReturnTask(Object retVal) &#123; System.out.println(++step + " 返回通知，返回值为：" + retVal.toString()); &#125; public void doThrowTask(Exception ex) &#123; System.out.println(++step + " 异常通知，异常信息为：" + ex.getMessage()); &#125; /** * 环绕通知需要携带ProceedingJoinPoint类型的参数 * 环绕通知类似于动态代理的全过程ProceedingJoinPoint类型的参数可以决定是否执行目标方法 * 且环绕通知必须有返回值，返回值即目标方法的返回值 */ public Object doAroundTask(ProceedingJoinPoint pjp) &#123; String methodname = pjp.getSignature().getName(); Object result = null; try &#123; // 前置通知 System.out.println("目标方法" + methodname + "开始，参数为" + Arrays.asList(pjp.getArgs())); // 执行目标方法 result = pjp.proceed(); // 返回通知 System.out.println("目标方法" + methodname + "执行成功，返回" + result); &#125; catch (Throwable e) &#123; // 异常通知 System.out.println("目标方法" + methodname + "抛出异常: " + e.getMessage()); &#125; // 后置通知 System.out.println("目标方法" + methodname + "结束"); return result; &#125;&#125; 我们先注释掉xml中环绕通知的配置，运行一下看下结果如何1234567public class MainApp &#123; public static void main( String[] args )&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("application.xml"); TargetService targetService = (TargetService) applicationContext.getBean("targetService"); targetService.operation("zou"); &#125;&#125; 结果为12341 前置通知执行目标方法，方法参数[msg:zou]2 后置通知3 返回通知，返回值为：zou 然后我们注释掉其他其他通知，测试一下环绕通知，并且我们在目标方法中抛出一个异常，再运行一下，结果为1234目标方法operation开始，参数为[zou]执行目标方法，方法参数[msg:zou]目标方法operation抛出异常: 我是个异常目标方法operation结束 使用 @AspectJ 的AOP支持启用@AspectJ支持要在 Spring 配置中使用 @AspectJ 切面，需要启用 Spring 支持 使用 XML 配置启用 @AspectJ 支持 1&lt;aop:aspectj-autoproxy/&gt; 这里也需要 AspectJ 的 aspectjweaver.jar 包，spring-aspects 模块是依赖该 jar 包的 声明一个切面Aspects 类和其他任何正常的 bean 一样，除了它们将会用 @AspectJ 注释之外，它和其他类一样可能有方法和字段12345import org.aspectj.lang.annotation.Aspect;@Aspectpublic class AnnotationAspect &#123;&#125; 也可以在 xml 中配置，和其他 bean 一样123&lt;bean id="myAspect" class="org.xyz.AnnotationAspect"&gt; &lt;!-- configure properties of the aspect here --&gt;&lt;/bean&gt; 切面(用 @Aspect 标注的类)可以具有与任何其他类相同的方法和字段。它们还可以包含切入点、通知和引入(内部类型)声明。 声明切入点切入点声明有两部分:包含名称和任何参数的签名，以及准确确定我们感兴趣的方法执行的切入点表达式 在 AOP 的 @AspectJ 注释样式中，切入点签名是由一个常规方法定义提供的，切入点表达式是通过使用 @Pointcut 注释表示的(作为切入点签名的方法必须为 void 返回类型) 如下代码，定义了一个名为 anyOldTransfer 的切入点，该切入点与任何名为 transfer 的方法的执行匹配12@Pointcut("execution(* transfer(..))")// the pointcut expressionprivate void anyOldTransfer() &#123;&#125;// the pointcut signature 声明通知你可以使用 @{advice-name} 注释声明五个建议中的任意一个，如下所示。这假设你已经定义了一个切入点标签方法 operation()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Aspectpublic class AnnotationAspect &#123; private static int step = 0; @Pointcut("execution(* transfer(..))") // the pointcut expression private void operation() &#123;&#125; @Before("operation()") public void doBeforeTask() &#123; System.out.println(++step + " 前置通知"); &#125; @After("operation()") public void doAfterTask() &#123; System.out.println(++step + " 后置通知"); &#125; @AfterReturning(pointcut = "operation()", returning = "retVal") public void doAfterReturnningTask(Object retVal) &#123; System.out.println(++step + " 返回通知，返回值为：" + retVal.toString()); &#125; @AfterThrowing(pointcut = "operation()", throwing = "ex") public void doAfterThrowingTask(Exception ex) &#123; System.out.println(++step + " 异常通知，异常信息为：" + ex.getMessage()); &#125; /** * 环绕通知需要携带ProceedingJoinPoint类型的参数 * 环绕通知类似于动态代理的全过程ProceedingJoinPoint类型的参数可以决定是否执行目标方法 * 且环绕通知必须有返回值，返回值即目标方法的返回值 */ //@Around("operation()") public Object doAroundTask(ProceedingJoinPoint pjp) &#123; String methodname = pjp.getSignature().getName(); Object result = null; try &#123; // 前置通知 System.out.println("目标方法" + methodname + "开始，参数为" + Arrays.asList(pjp.getArgs())); // 执行目标方法 result = pjp.proceed(); // 返回通知 System.out.println("目标方法" + methodname + "执行成功，返回" + result); &#125; catch (Throwable e) &#123; // 异常通知 System.out.println("目标方法" + methodname + "抛出异常: " + e.getMessage()); &#125; // 后置通知 System.out.println("目标方法" + methodname + "结束"); return result; &#125;&#125; 也可以为任意一个通知直接写入内联切入点1234@Before("execution(* com.xyz.myapp.dao.*.*(..))")public void doAccessCheck() &#123; // ...&#125; 其中环绕通知包括前置、后置、返回、异常通知运行的结果这里不给了，可以参考上面xml配置的例子]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 的 IoC 容器]]></title>
    <url>%2Fblog%2Fspring-ioc-container%2F</url>
    <content type="text"><![CDATA[依赖注入DI 和 控制反转IoC 在spring文档中是这样描述的： IoC也称为依赖注入(dependency injection, DI)。它是一个对象去定义它的依赖的过程，这些依赖（即它去使用的其他对象），只能通过构造函数参数注入、工厂方法的参数注入、或是在对象实例化或是从工厂方法返回一个实例之后去设置属性。而容器是在创建bean的时候，注入这些依赖。这个过程基本上是反向的，因此称为控制反转(IoC)，因为bean本身是通过使用类的直接构造或一种如服务定位器模式的机制来控制依赖的实例化或位置 依赖注入(Dependency Injection,DI) 是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现 控制反转(Inversion of Control,IOC) 是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IOC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了IOC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IOC容器了，通过IOC容器来建立它们之间的关系。 DI(依赖注入)其实就是IOC的另外一种说法，DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结道：控制的什么被反转了？就是获得依赖对象的方式反转了。 个人理解： 简单来说，依赖注入就是控制反转，我把控制反转理解成是一个过程，依赖注入是一个动作（这里简化为一个动作）。控制反转把创建对象（依赖）的控制权交给了IoC容器，容器根据组件之间配置的依赖关系来创建对象，而依赖注入就是这个创建对象的动作，它在IoC的基础上完成操作（即为类里面的属性设置值） IoC 容器构成应用程序主干并由 Spring IoC 容器管理的对象称为 bean org.springframework.context.ApplicationContext 代表 Spring IoC 容器，负责实例化、配置和组装 bean。容器通过读取配置元数据获取有关实例化、配置和组装哪些对象的说明。配置元数据用 XML、Java 注释或 Java 代码表示（用来描述对象之间的依赖关系）。 ApplicationContext 容器最常被使用的 ApplicationContext 接口实现： FileSystemXmlApplicationContext 该容器从XML文件中加载已被定义的bean，需要提供给构造器XML文件的完整路径 ClassPathXmlApplicationContext 该容器从XML文件中加载已被定义的bean，可以不需要提供XML文件的完整路径，只需正确配置CLASSPATH环境变量即可，容器会从CLASSPATH中搜索bean配置文件 WebXmlApplicationContext 该容器会在一个 web 应用程序的范围内加载在XML文件中已被定义的bean 这里用 ClassPathXmlApplicationContext 来举一个例子 HelloWorldDaoImpl.java 123456789public class HelloWorldDaoImpl implements HelloWorldDao &#123; private String message; public void setMessage(String message) &#123; this.message = message; &#125; public void say() &#123; System.out.println(message); &#125;&#125; HelloWorldSeriveceImpl.java123456789public class HelloWorldServiceImpl implements HelloWorldService&#123; private HelloWorldDao helloWorldDao; public void setHelloWorldDao(HelloWorldDao helloWorldDao) &#123; this.helloWorldDao = helloWorldDao; &#125; public void say() &#123; helloWorldDao.say(); &#125;&#125; application.xml 文件描述着bean之间的依赖关系12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloWorldDao" class="com.spring.dao.HelloWorldDaoImpl"&gt; &lt;property name="message" value="Hello World!"/&gt; &lt;/bean&gt; &lt;bean id="helloWorldService" class="com.spring.service.HelloWorldServiceImpl"&gt; &lt;property name="helloWorldDao" ref="helloWorldDao"/&gt; &lt;/bean&gt;&lt;/beans&gt; MainApp.java1234567public class MainApp &#123; public static void main( String[] args )&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("application.xml"); HelloWorldService service = (HelloWorldService) applicationContext.getBean("helloWorldService"); service.say(); &#125;&#125; 第一步生成工厂对象。加载 bean 配置文件后，ClassPathXmlApplicationContext 负责生成和初始化XML配置文件中的 bean。 第二步利用第一步生成的上下文中的 getBean() 方法得到所需要的 bean。 这个方法通过配置文件中的 bean 的 id 来返回一个真正的对象。得到这个对象，就可以利用这个对象来调用任何方法。 HelloWorldDaoImpl 中 message , HelloWorldServiceImpl中的 helloWorldDao 都是通过容器根据 xml 文件里描述的依赖关系装配好的 运行程序： Hello World! Spring Bean构成应用程序主干并由Spring IoC容器管理的对象称为 bean, bean 是被Spring IoC容器实例化、组装、管理的对象。Spring IoC容器管理一个或多个 bean。这些 bean 是用我们提供给容器的配置元数据创建的(例如，XML \&lt;bean/> 定义的形式)。 配置元数据转换为一组 组成每个bean定义的属性。下表描述了这些属性: 属性 描述 class 这个属性是强制性的，指定用来创建 bean 的 bean 类 name 这个属性指定唯一的 bean 标识符。在基于 XML 的配置元数据中，你可以使用 ID 和/或 name 属性来指定 bean 标识符 scope 这个属性指定由特定的 bean 定义创建的对象的作用域 constructor arguments 它是用来注入依赖关系的 properties 它是用来注入依赖关系的 autowiring mode 它是用来注入依赖关系的 lazy-initialization mode 延迟初始化的 bean 告诉 IoC 容器在它第一次被请求时，而不是在启动时去创建一个 bean 实例 initialization 方法 在 bean 的所有必需的属性被容器设置之后，调用回调方法 destruction 方法 当包含该 bean 的容器被销毁时，使用回调方法 bean 的作用域 作用域 描述 singleton (默认值) Spring IoC容器中只有一个bean实例，bean以单例方式存在 prototype 一个Bean定义可以创建任意多个实例对象，每次从容器中调用Bean时，都返回一个新的实例 request 限定一个Bean的作用域为单个HTTP请求的生命周期;也就是说，每次HTTP请求都会创建新的bean实例。仅在基于web的Spring ApplicationContext有效 session 限定一个Bean的作用域为HTTPSession的生命周期。仅在基于web的Spring ApplicationContext可用 globalSession 限定一个Bean的作用域为全局HTTPSession的生命周期。通常用于Portlet场景。仅基于web的Spring ApplicationContext可用 application 限定一个Bean的作用域为ServletContext的生命周期。仅基于web的Spring ApplicationContext可用 websocket 限定一个Bean的作用域为WebSocket的生命周期。仅基于web的Spring ApplicationContext可用 依赖注入依赖注入主要使用两种方式，一种是基于构造函数的注入，另一种的基于Setter方法的依赖注入。 基于构造函数的注入基于构造函数的依赖注入是由IoC容器来调用类的构造函数，构造函数的参数代表这个Bean所依赖的对象。 构造函数的参数解析 构造函数的参数解析是通过参数的类型来匹配的。如果在Bean的构造函数参数不存在歧义，那么构造器参数的顺序也就是就是这些参数实例化以及装载的顺序1234567package x.y;public class Foo &#123; public Foo(Bar bar, Baz baz) &#123; // ... &#125;&#125; 假设Bar和Baz在继承层次上不相关，也没有什么歧义的话，下面的配置完全可以工作正常，不需要再去&lt;constructor-arg&gt;元素中指定构造函数参数的索引或类型信息。123456789&lt;beans&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;constructor-arg ref="bar"/&gt; &lt;constructor-arg ref="baz"/&gt; &lt;/bean&gt; &lt;bean id="bar" class="x.y.Bar"/&gt; &lt;bean id="baz" class="x.y.Baz"/&gt;&lt;/beans&gt; 当使用简单的类型的时候，容器可以通过使用构造函数参数的type属性来实现简单类型的匹配。例如1234&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg type="int" value="7500000"/&gt; &lt;constructor-arg type="java.lang.String" value="42"/&gt;&lt;/bean&gt; 或者使用index属性来指定构造参数的位置，这个索引也同时是为了解决构造函数中有多个相同类型的参数无法精确匹配的问题1234&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg index="0" value="7500000"/&gt; &lt;constructor-arg index="1" value="42"/&gt;&lt;/bean&gt; 基于Setter方法的依赖注入基于Setter函数的依赖注入则是容器会调用Bean的无参构造函数，或者无参数的工厂方法，然后再来调用Setter方法来实现的依赖注入12345678910&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;property name="beanOne"&gt; &lt;ref bean="anotherExampleBean"/&gt; &lt;/property&gt; &lt;property name="beanTwo" ref="yetAnotherBean"/&gt; &lt;property name="integerProperty" value="1"/&gt;&lt;/bean&gt;&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt; 12345678910111213141516public class ExampleBean &#123; private AnotherBean beanOne; private YetAnotherBean beanTwo; private int i; public void setBeanOne(AnotherBean beanOne) &#123; this.beanOne = beanOne; &#125; public void setBeanTwo(YetAnotherBean beanTwo) &#123; this.beanTwo = beanTwo; &#125; public void setIntegerProperty(int i) &#123; this.i = i; &#125;&#125; 基于构造函数注入中，我们使用的是〈bean〉标签中的〈constructor-arg〉元素，而在基于设值函数的注入中，我们使用的是〈bean〉标签中的〈property〉元素 把一个引用传递给一个对象，那么你需要使用标签的 ref 属性，而如果你要直接传递一个值，那么你应该使用 value 属性 使用 p-namespace 实现 XML 配置p-namespace允许您使用bean元素的属性（而不是嵌套 &lt;property/&gt;元素）来描述属性值或是bean Spring支持具有命名空间的可扩展配置格式，这些命名空间基于XML Schema定义 带有标签的标准 XML 配置文件12345678&lt;bean id="john-classic" class="com.example.Person"&gt; &lt;property name="name" value="John Doe"/&gt; &lt;property name="spouse" ref="jane"/&gt;&lt;/bean&gt;&lt;bean name="jane" class="com.example.Person"&gt; &lt;property name="name" value="John Doe"/&gt;&lt;/bean&gt; 使用 p-namespace 实现 XML 配置12345678910111213&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="john-classic" class="com.example.Person" p:name="John Doe" p:spouse-ref="jane"/&gt; &lt;bean name="jane" class="com.example.Person" p:name="John Doe"/&gt;&lt;/beans&gt; -ref 部分表明这不是一个直接的值，而是对另一个 bean 的引用 内部bean定义在元素的或者元素之内的 Bean 叫做内部Bean12345678&lt;bean id="outer" class="..."&gt; &lt;property name="target"&gt; &lt;bean class="com.example.Person"&gt; &lt;!-- this is the inner bean --&gt; &lt;property name="name" value="Fiona Apple"/&gt; &lt;property name="age" value="25"/&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 内部Bean的定义是不需要指定id或者名字的。如果指定了，容器也不会用之作为分别Bean的区分标识。容器同时也会无视内部Bean的scope标签：内部Bean 总是匿名的，而且随着外部的Bean同时创建的。不能将内部的Bean注入到外部Bean以外的其他Bean 注入集合在 \&lt;list/>, \&lt;set/>, \&lt;map/> 和 \&lt;props/>元素中，可以配置 Java 集合类型 List, Set, Map 以及 Properties 的属性和参数12345678910111213141516171819202122232425262728293031&lt;bean id="moreComplexObject" class="example.ComplexObject"&gt; &lt;property name="adminEmails"&gt; &lt;props&gt; &lt;prop key="administrator"&gt;administrator@example.org&lt;/prop&gt; &lt;prop key="support"&gt;support@example.org&lt;/prop&gt; &lt;prop key="development"&gt;development@example.org&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name="someList"&gt; &lt;list&gt; &lt;value&gt;a list element followed by a reference&lt;/value&gt; &lt;ref bean="myDataSource" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="someMap"&gt; &lt;map&gt; &lt;entry key="an entry" value="just some string"/&gt; &lt;entry key ="a ref" value-ref="myDataSource"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="someSet"&gt; &lt;set&gt; &lt;value&gt;just some string&lt;/value&gt; &lt;ref bean="myDataSource" /&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; map的key或者value，或者是集合的value都可以配置为下列之中的一些元素 bean | ref | idref | list | set | map | props | value | null null 和空字符串的注入123456789&lt;bean id="..." class="exampleBean"&gt; &lt;property name="email" value=""/&gt;&lt;/bean&gt;&lt;bean class="ExampleBean"&gt; &lt;property name="email"&gt; &lt;null/&gt; &lt;/property&gt;&lt;/bean&gt; beans自动装配Spring 容器可以根据 Bean 之间的依赖关系自动装配 自动装载能够明显的减少指定的属性或者是构造参数。 自动装载可以扩展开发者的对象。比如说，如果需要加一个依赖，依赖就能够不需要开发者特别关心更改配置就能够自动满足。这样，自动装载在开发过程中是极度高效的，不用明确的选择装载的依赖会使系统更加的稳定。 当使用基于XML的元数据配置的时候，开发者可以指定自动装配的方式。通过配置 \&lt;bean/> 元素的 autowire 属性就可以了。自动装载有如下四种方式，开发者可以指定每个 Bean 的装载方式，这样 Bean 就知道如何加载自己的依赖。 模式 解释 no （默认）不装载。Bean的引用必须通过ref元素来指定。对于比较大项目的部署，不建议修改默认的配置，因为特指会加剧控制。在某种程度上来说，默认的形式也说明了系统的结构 byName 通过名字来装配。Spring会查找所有的Bean直到名字和属性相同的一个Bean来进行装载。比如说，如果Bean配置为根据名字来自动装配，它包含了一个属性名字为master(也就是包含一个setMaster(..)方法)，Spring就会查找名字为master的Bean，然后用之装载 byType 如果需要自动装配的属性的类型在容器之中存在的话，就会自动装配。如果容器之中存在不止一个类型匹配的话，就会抛出一个重大的异常，说明开发者最好不要使用byType来自动装配那个Bean。如果没有匹配的Bean存在的话，不会抛出异常，只是属性不会配置 constructor 类似于byType的注入，但是应用的构造函数的参数。如果没有一个Bean的类型和构造函数参数的类型一致，那么仍然会抛出一个重大的异常 正常情况下的配置文件 Beans.xml 文件123456&lt;bean id="textEditor" class="com.tutorialspoint.TextEditor"&gt; &lt;property name="spellChecker" ref="spellChecker" /&gt; &lt;property name="name" value="Generic Text Editor" /&gt;&lt;/bean&gt;&lt;bean id="spellChecker" class="com.tutorialspoint.SpellChecker"&gt;&lt;/bean&gt; 如果使用自动装配 “byName”，那么你的 XML 配置文件，byType 和 constructor 也是类似的123456&lt;bean id="textEditor" class="com.tutorialspoint.TextEditor" autowire="byName"&gt; &lt;property name="name" value="Generic Text Editor" /&gt;&lt;/bean&gt;&lt;bean id="spellChecker" class="com.tutorialspoint.SpellChecker"&gt;&lt;/bean&gt; 基于注解的配置注解注入在XML注入之前执行。因此XML配置覆盖了通过这两种方法连接的属性的注解 想在 Spring 应用程序中使用注解，需要在配置文件中声明1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Required@Required 注释应用于bean属性设置方法12345678public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Required public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125;&#125; 使用 @Autowired可以将@Autowired注释应用于构造函数12345678public class MovieRecommender &#123; private final CustomerPreferenceDao customerPreferenceDao; @Autowired public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123; this.customerPreferenceDao = customerPreferenceDao; &#125;&#125; 也可以将@Autowired注释应用于setter方法12345678public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Autowired public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125;&#125; 还可以将注释应用于具有任意名称和多个参数的方法123456789101112public class MovieRecommender &#123; private MovieCatalog movieCatalog; private CustomerPreferenceDao customerPreferenceDao; @Autowired public void prepare(MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) &#123; this.movieCatalog = movieCatalog; this.customerPreferenceDao = customerPreferenceDao; &#125;&#125; 还可以将@Autowired应用于字段，甚至可以将其与构造函数混合1234567891011public class MovieRecommender &#123; private final CustomerPreferenceDao customerPreferenceDao; @Autowired private MovieCatalog movieCatalog; @Autowired public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123; this.customerPreferenceDao = customerPreferenceDao; &#125;&#125; 确保您的目标组件(例如MovieCatalog或CustomerPreferenceDao)是由您用于@ autowiated注释注入点的类型一致声明的。否则，注入可能会由于在运行时没有找到类型匹配而失败。 对于通过类路径扫描找到的xml定义的bean或组件类，容器通常预先知道具体类型。但是，对于@Bean工厂方法，您需要确保声明的返回类型具有足够的表达能力。对于实现多个接口的组件或可能由其实现类型引用的组件，请考虑在工厂方法上声明最特定的返回类型(至少与引用bean的注入点所需的相同)。 还可以从ApplicationContext中提供特定类型的所有bean，方法是将注释添加到需要该类型数组的字段或方法，集合1234567891011public class MovieRecommender &#123; @Autowired private MovieCatalog[] movieCatalogs; private Set&lt;MovieCatalog&gt; movieCatalogs; @Autowired public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) &#123; this.movieCatalogs = movieCatalogs; &#125;&#125; @Qualifier当需要对选择过程进行更多控制时，可以使用Spring的@Qualifier注释。可以将限定符值与特定参数关联，缩小类型匹配集，以便为每个参数选择特定的bean123456public class MovieRecommender &#123; @Autowired @Qualifier("main") private MovieCatalog movieCatalog;&#125; 这是xml的配置1234567&lt;bean class="example.SimpleMovieCatalog"&gt; &lt;qualifier value="main"/&gt;&lt;/bean&gt;&lt;bean class="example.SimpleMovieCatalog"&gt; &lt;qualifier value="action"/&gt;&lt;/bean&gt; 或者是12345&lt;bean id="main" class="example.SimpleMovieCatalog"&gt;&lt;/bean&gt;&lt;bean id="action" class="example.SimpleMovieCatalog"&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架概述和体系结构]]></title>
    <url>%2Fblog%2Fspring-framework-introduction-overview%2F</url>
    <content type="text"><![CDATA[介绍什么是SpringSpring是一个轻量级框架，是构建企业级应用程序的一站式解决方案。它的目标就是要简化Java企业级开发 Spring是分层的、模块化的，你可以按需引入需要的模块。最核心的模块就是IoC容器，这是Spring的基础，IoC容器用来管理bean的生命周期，在此基础之上，我们可以自行集成Web、消息传递、数据持久化、事务管理等组件。另一大核心是Spring所推崇的AOP（Aspect Oriented Programming，面向切面编程）编程方式，使用AOP编程方法补充了OOP（Object Oriented Programming，面向对象编程），减少了代码的重复，让我们更专注于业务 Spring是开源的，在多年不断的发展和创新中，除了Spring Framework（即我们通常说的Spring框架）之外，Spring家族还有如Spring Boot、Spring Data、Spring Cloud、Spring Batch等项目，几乎涵盖了应用程序所需的所有基础设施（从配置到安全，从web应用程序到大数据），体现着Spring的模块化设计 依赖注入和控制反转Spring框架体系（本框架体系描述的是spring 4.x版本）Spring框架由大约20个模块组成的特性组成。这些模块分为核心容器、数据访问/集成、Web、AOP(面向方面编程)、工具、消息传递和测试。 核心容器核心容器由spring-core、spring-beans、spring-context、spring-context-support和spring-expression(Spring Expression Language)模块组成。 spring-core和spring-beans 模块提供了框架的基本部分，包括控制反转（Inversion of Control, IOC）和依赖注入（Dependency Injection, DI）。BeanFactory是一个复杂的工厂模式实现。它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦，BeanFactory 容器实例化后并不会自动实例化 Bean，只有当 Bean被使用时 BeanFactory 容器才会对该 Bean 进行实例化与依赖关系的装配。 spring-context 上下文模块构建在core和bean模块之上:它是以一种类似JNDI注册的方式访问对象。Context模块继承Beans模块的特性，并添加了国际化(例如使用资源包)、事件广播、资源加载和透明地创建上下文(例如使用Servlet容器)的支持。context模块还支持EJB、JMX和基本远程处理等JavaEE特性。ApplicationContext是Context模块的核心接口。spring-context-support支持将常见的第三方库集成到Spring应用程序上下文中，用于缓存(EhCache、Guava、JCache)、邮件(JavaMail)、调度(CommonJ、Quartz)和模板引擎(FreeMarker、JasperReports、Velocity)。 spring-expression 模块是统一表达式语言(unified expression language，unified EL)的扩展，用于在运行时查询和操作对象图。该语言支持设置和获取属性值、属性赋值、方法调用、访问数组、集合和索引的内容、逻辑和算术操作符、命名变量，以及从Spring的IoC容器按名称检索对象。还支持列表映射、选择以及常见的列表聚合。AOP 和 Instrumentation spring-aop 模块提供面向切面的编程实现，允许你定义方法拦截器和切入点对代码干净地解耦分离。使用源码级的元数据功能，还可以将行为信息以类似.NET属性的方式合并到代码中。 spring-aspects 模块集成自 AspectJ 框架， 主要是为 Spring AOP 提供多种 AOP 实现方法 spring-instrument 模块提供用于某些应用服务器的类instrumentation 支持和类加载器实现。spring-instrument-tomcat 模块用于Tomcat的Spring的instrumentation代理 Messaging Spring Framework 4 包含spring-messaging模块，来自Spring集成项目的抽象，如Message、MessageChannel、MessageHandler等，用来提供基于消息的基础服务。该模块还包括一组用于将消息映射到方法的注解，类似于基于编程模型的Spring MVC的注解。 数据访问和集成Data Access/Integration 层由JDBC、ORM、OXM、JMS和Transaction 模块组成。 spring-jdbc 模块提供了JDBC抽象层，它消除了冗长的JDBC编码和对数据库供应商特定错误代码解析的需要。主要是提供JDBC模板方式、关系数据库对象化方式、SimpleJdbc方式、事务管理来简化JDBC编程，主要实现类是 JdbcTemplate、SimpleJdbcTemplate 以及 NamedParameterJdbcTemplate spring-tx 模块支持对实现特殊接口的类和所有pojo(普通旧Java对象)进行编程式和声明式事务管理。 spring-orm 模块为流行的 object-relational mapping（对象-关系映射）API(包括JPA、JDO和Hibernate)提供了集成层。使用spring-orm模块，可以结合O/R映射框架与Spring提供的所有其他特性结合，如简单声明性事务管理特性。 spring-oxm模块提供了一个抽象层用于支持 Object/XML mapping （对象/XML映射）的实现，如JAXB、Castor、XMLBeans、JiBX和XStream。 spring-jms模块包含生成和消费消息的功能。从Spring4.1开始，提供了与spring-messaging模块的集成。 WebWeb层由spring-web、spring-webmvc、spring-websocket和spring-webmvc-portlet模块组成。 spring-web 模块提供了基本的面向web的集成功能。例如多部分文件上传功能，使用Servlet listeners和面向Web的应用程序上下文初始化IoC容器。它还包含HTTP客户端和Spring远程访问web相关的部分的支持。 spring-webmvc 模块(也称为Web servlet模块)包含Spring的模型-视图-控制器(model-view-controller，MVC)和Web应用程序的REST Web服务实现。Spring的MVC框架提供了domain model（域模型）代码和web form之间的完全分离，并集成了Spring框架的所有其他特性。 spring-websocket 模块主要是与 Web 前端的全双工通讯的协议。 spring-webmvc-portlet 模块(也称为Web-Portlet模块)提供了要在Portlet环境中使用的MVC实现，并反映了基于servlet的spring-webmvc模块的功能。（该模块在Spring5中移除） spring-webflux 是一个新的非堵塞函数式 Reactive Web 框架， 可以用来建立异步的、非阻塞、事件驱动的服务，并且扩展性非常好。（Spring5新模块） Test spring -test模块支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。它提供了Spring ApplicationContext的一致加载和这些上下文的缓存。它还提供了模拟对象，您可以使用这些模拟对象单独测试代码。 Spring 包之间的依赖关系包列表 spring-core 核心工具类 spring-beans bean支持 spring-expression Spring表达式语言(SpEL) spring-aop 基于代理的AOP支持 spring-aspects 基于AspectJ方面 spring-context 应用程序上下文运行时，包括调度和远程抽象 spring-context-support 支持将公共第三方库集成到Spring应用程序上下文中的类 spring-messaging 支持消息传递体系结构和协议 spring-instrument 用于JVM引导的插装代理 spring-instrument-tomcat Tomcat的插装代理 spring-jdbc JDBC支持包，包括数据源设置和JDBC访问支持 spring-tx 事务基础设施，包括DAO支持和JCA集成 spring-orm 对象/关系映射，包括JPA和Hibernate支持 spring-oxm Object/XML Mipmg 对象/ XML映射 spring-jms JMS支持包，包括发送/接收JMS消息的帮助类 spring-test 支持单元测试和集成测试Spring组件 spring-web 基本的web支持，包括web客户机和基于web的远程处理 spring-webmvc Servlet栈的基于http的模型-视图-控制器和REST端点 spring-websocket WebSocket和SockJS基础架构，包括STOMP消息传递支持 spring-webmvc-portlet 要在Portlet环境中使用的MVC实现 依赖关系图spring-core依赖了commons-logging，而其他模块都依赖了spring-core，所以整个spring框架都依赖了commons-logging，如果有自己的日志实现如log4j，可以排除对commons-logging的依赖，没有日志实现而排除了commons-logging依赖，编译报错 下图是spring4的jar之间的直接依赖图，在maven中配置spring依赖时不会再混乱了，简洁配置]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 下安装 MySql 8]]></title>
    <url>%2Fblog%2Flinux-mysql8-install%2F</url>
    <content type="text"><![CDATA[Linux 下安装 MySql 8 下载安装包去到 MySql官网 https://www.mysql.com/downloads/ 下载对应的安装包 选择 MySQL Community Server，我这里下载的是 mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz 安装 mysql1.上传压缩文件到服务器，并解压文件 tar -xvf mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz *.tar.xz文件解压要分两步，但我上面直接解压也成功了 xz -d mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz tar -xvf mysql-8.0.13-linux-glibc2.12-x86_64.tar 2.将解压后目录复制到安装目录/usr/local/下并更改文件名 mv -r mysql-8.0.13-linux-glibc2.12-x86_64 /usr/local/mysql 在目录下新建一个文件夹data,用于存放数据 mkdir /usr/local/mysql/data 3.添加mysql组和用户 groupadd mysql useradd -r -g mysql mysql 把安装目录的权限给到 mysql组的mysql用户 chown -R mysql:mysql /usr/local/mysql 让mysql运行的时候使用一个独立的账号,如果mysql被黑了那么开始拿到的权限就是那个创建的账号而不是默认的root 我们在编译安装的时候创建一个mysql组和一个mysql用户,并把datadir和安装目录属主改为mysql,在MySQL启动的时候,单进程mysqld,该进程的属主就是mysql,这样就保证了mysql服务的独立性,即便mysql服务被黑掉,得到了mysql用户权限,也不会影响整个系统的安全 4.配置my.cnf文件 修改 /etc/my.cnf 文件 12345user=mysqlport=3306basedir=/usr/local/mysqldatadir=/usr/local/mysql/datasocket=/tmp/mysql.sock 5.初始化mysql 配置 /usr/local/mysql/bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data mysql5.7之前命令是：bin/mysql_install_db --user=mysql，之后的版本已经被mysqld --initialize替代，后面的配置在my.cnf配置了，也可以不带 如果没有异常，会自动生成账号root和密码 1232018-12-11T01:31:14.713646Z 0 [System] [MY-013169] [Server] /usr/local/mysql/bin/mysqld (mysqld 8.0.13) initializing of server in progress as process 1288762018-12-11T01:31:19.886238Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: l;PS&gt;rl4sl(B2018-12-11T01:31:21.653302Z 0 [System] [MY-013170] [Server] /usr/local/mysql/bin/mysqld (mysqld 8.0.13) initializing of server has completed 启动服务、配置账号密码开启服务/usr/local/mysql/bin/mysqld_safe --user=mysql &amp; &amp;是后台运行的意思，执行命令之后，终端会卡在一个位置，再按一下Enter即可 执行后报了个错 mysqld_safe error: log-error set to &#39;/var/log/mariadb/mariadb.log&#39;, however file don&#39;t exists. Create writable for user &#39;mysql&#39;. 很明显是因为路径文件不存在，且需要给mysql权限，之前在配置 /etc/my.cnf时，里面的配置为 [mysqld_safe]log-error=/var/log/mariadb/mariadb.logpid-file=/var/run/mariadb/mariadb.pid 创建这个路径，并授权给mysql,重新开启服务 mkdir /var/log/mariadbtouch /var/log/mariadb/mariadb.logchown -R mysql:mysql /var/log/mariadb/ 加入开机自启项1.将{mysql}/support-files/mysql.server 拷贝为/etc/init.d/mysql并设置运行权限，这样就可以使用service mysql命令启动/停止服务 cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql chmod +x /etc/init.d/mysql 2.注册启动服务 chkconfig --add mysql 查看chkconfig --list mysql 使用 service 启动：service mysql start 使用 service 停止：service mysql stop 使用 service 重启：service mysql restart 环境变量配置全局环境变量，可以在其他位置使用 mysql 编辑 / etc/profile 文件 vim /etc/profile 在 profile 文件底部添加如下，保存后退出 export PATH=/usr/local/mysql/bin:/usr/local/mysql/lib:$PATH 设置环境变量立即生效 source /etc/profile 修改密码，创建用户1.登录 mysql -uroot -p 密码使用初始化时生成的密码 2.修改密码 alter user &#39;root&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;***&#39;; 这里修改密码的时候加上 with mysql_native_password，mysql_native_password 8.0改变了 身份验证插件caching_sha2_password， 打开 my.ini (或者my.cofg) 可以看到变更了 5.7及其以前的方式mysql_native_password 3.创建用户，并授予权限 create user &#39;zou&#39;@&#39;%&#39; identified with mysql_native_password by &#39;***&#39;; grant replication slave on *.* to &#39;zou&#39;@&#39;%&#39;; flush privileges; //刷新 可以使用该账号远程连接 4.可以修改root用户可远程连接 update mysql.user set host=&#39;%&#39; where user = &#39;root&#39;;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下安装JDK]]></title>
    <url>%2Fblog%2Flinux-jdk-install%2F</url>
    <content type="text"><![CDATA[Linux下安装JDK 下载文件从官网下载合适版本如：jdk-8u191-linux-x64.tar.gz 安装文件1.在 /usr/ 目录下创建 java文件夹mkdir /usr/java 2.将压缩包 jdk-8u191-linux-x64.tar.gz 复制到该目录，并解压tar -zxvf jdk-8u191-linux-x64.tar.gz 修改环境变量1.修改 /etc/profile 文件vim /etc/profile 2.在文件后面添加 java 的配置并保存，如下 123456JAVA_HOME=/usr/java/jdk1.8.0_191PATH=$JAVA_HOME/bin:$PATHCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOMEexport PATHexport CLASSPATH 3.让配置生效source /etc/profile 4.验证配置信息 123echo $JAVA_HOMEecho $PATHecho $CLASSPATH 测试查看java版本 java -version，显示如下信息，配置成功 123java version &quot;1.8.0_191&quot;Java(TM) SE Runtime Environment (build 1.8.0_191-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode) rpm方式安装JDK rpm是由红帽公司开发的软件包管理方式，使用rpm我们可以方便的进行软件的安装、查询、卸载、升级等工作。但是rpm软件包之间的依赖性问题往往会很繁琐,尤其是软件由多个rpm包组成时 1.获取rpm 格式的安装包，如 jdk-11.0.1_linux-x64_bin.rpm，复制到 /usr/java 目录下2.执行安装rpm -ivh jdk-7u79-linux-x64.rpm 12345[root@instance-idjn8dpx java]# rpm -ivh jdk-11.0.1_linux-x64_bin.rpmwarning: jdk-11.0.1_linux-x64_bin.rpm: Header V3 RSA/SHA256 Signature, key ID ec551f03: NOKEYPreparing... ################################# [100%]Updating / installing... 1:jdk-11.0.1-2000:11.0.1-ga ################################# [100%] 使用命令 # rpm -qa|grep jdk 查看安装的java 12[root@instance-idjn8dpx java]# rpm -qa|grep jdkjdk-11.0.1-11.0.1-ga.x86_64 3.环境变量的配置如上4.rmp卸载使用 rpm -e --nodeps 卸载rpm -e --nodeps jdk-11.0.1-11.0.1-ga.x86_64]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
</search>
